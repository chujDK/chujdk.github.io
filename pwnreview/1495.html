<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>seccomp 中的 bpf - blog of chuj</title><link rel=icon type=image/png href=https://chujdk.github.io/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="学习这个问题的原因是想做 pwnable.tw 的 seccomp-tool 一题，此题的 elf 可以读取、模拟、加载用户输入的 bpf 代码，其中加载使用的是 prctl 系统调用，功能号为 PR_GET_SECCOMP。
暂时还不知道怎么做，原来觉得应该是通过 bpf 来完成利用，总不会是 elf 某处写渣了的溢出。由于我对 bpf 和 seccomp 不甚了解，所以先花了点时间了解了一下。了解了之后我感觉还真可能是 elf 本身的洞，在 emulate 功能中，也实现了一个类似于 Linux cbpf 解码器和模拟器的虚拟机，这里的代码还是有一点的，还没来的及看，说不定就是这里存在问题。"><meta property="og:image" content><meta property="og:url" content="https://chujdk.github.io/pwnreview/1495.html"><meta property="og:site_name" content="blog of chuj"><meta property="og:title" content="seccomp 中的 bpf"><meta property="og:description" content="学习这个问题的原因是想做 pwnable.tw 的 seccomp-tool 一题，此题的 elf 可以读取、模拟、加载用户输入的 bpf 代码，其中加载使用的是 prctl 系统调用，功能号为 PR_GET_SECCOMP。
暂时还不知道怎么做，原来觉得应该是通过 bpf 来完成利用，总不会是 elf 某处写渣了的溢出。由于我对 bpf 和 seccomp 不甚了解，所以先花了点时间了解了一下。了解了之后我感觉还真可能是 elf 本身的洞，在 emulate 功能中，也实现了一个类似于 Linux cbpf 解码器和模拟器的虚拟机，这里的代码还是有一点的，还没来的及看，说不定就是这里存在问题。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-24T15:26:00+00:00"><meta property="article:modified_time" content="2021-07-24T15:26:00+00:00"><meta property="article:tag" content="Curious"><meta name=twitter:card content="summary"><meta name=twitter:title content="seccomp 中的 bpf"><meta name=twitter:description content="学习这个问题的原因是想做 pwnable.tw 的 seccomp-tool 一题，此题的 elf 可以读取、模拟、加载用户输入的 bpf 代码，其中加载使用的是 prctl 系统调用，功能号为 PR_GET_SECCOMP。
暂时还不知道怎么做，原来觉得应该是通过 bpf 来完成利用，总不会是 elf 某处写渣了的溢出。由于我对 bpf 和 seccomp 不甚了解，所以先花了点时间了解了一下。了解了之后我感觉还真可能是 elf 本身的洞，在 emulate 功能中，也实现了一个类似于 Linux cbpf 解码器和模拟器的虚拟机，这里的代码还是有一点的，还没来的及看，说不定就是这里存在问题。"><script src=https://chujdk.github.io/js/feather.min.js></script><link href=https://chujdk.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://chujdk.github.io/css/main.6dc922b4122291f1967a53b3e802e564596ed5068a8571e4221c9ead17563c3a.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://chujdk.github.io/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://chujdk.github.io/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>seccomp 中的 bpf</h1><div class=meta>Posted on Jul 24, 2021</div></div><section class=body><p>学习这个问题的原因是想做 pwnable.tw 的 seccomp-tool 一题，此题的 elf 可以读取、模拟、加载用户输入的 bpf 代码，其中加载使用的是 prctl 系统调用，功能号为 PR_GET_SECCOMP。</p><p>暂时还不知道怎么做，原来觉得应该是通过 bpf 来完成利用，<del>总不会是 elf 某处写渣了的溢出</del>。由于我对 bpf 和 seccomp 不甚了解，所以先花了点时间了解了一下。了解了之后我感觉还真可能是 elf 本身的洞，在 emulate 功能中，也实现了一个类似于 Linux cbpf 解码器和模拟器的虚拟机，这里的代码还是有一点的，还没来的及看，说不定就是这里存在问题。</p><p>首先，根据上下文，seccomp 可能指代三种东西</p><ul><li>Linux 内核 seccomp 沙箱机制，运行在该沙箱中的程序只能使用 exit，sigreturn，read 和 write 四种系统调用。</li><li>seccomp-bpf，seccomp 机制的扩展，通过 bpf 的支持可以使用户自定义需要过滤的系统调用。</li><li>seccomp lib，提供了一系列函数，使用该库可以实现类似 seccomp-bpf 的过滤效果，并且使用者不需要了解 bpf 即可使用。</li></ul><p>seccomp-tools 此题中使用的就是 seccomp-bpf，所以这里主要说一下 seccomp-bpf。其实看雪的 <a href=https://bbs.pediy.com/thread-258146.htm>[原创]seccomp沙箱机制 & 2019ByteCTF VIP</a> 这篇文章写的非常详细，看这篇就差不多了。但是我这里按自己的习惯还是半写半抄在这里再弄一遍。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* part of seccomp-tools install function */</span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> ( bpf_bytes_len )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> ( (<span style=color:#902000>unsigned</span> <span style=color:#007020;font-weight:700>__int8</span>)check_filter() <span style=color:#666>==</span> <span style=color:#40a070>1</span> )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      prctl(<span style=color:#40a070>38</span>, <span style=color:#40a070>1LL</span>, <span style=color:#40a070>0LL</span>, <span style=color:#40a070>0LL</span>, <span style=color:#40a070>0LL</span>);            <span style=color:#60a0b0;font-style:italic>// PR_SET_NO_NEW_PRIVS
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>      bpf_filter_prog.filter <span style=color:#666>=</span> (<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>sock_filter</span> <span style=color:#666>*</span>)<span style=color:#666>&amp;</span>bpf_code_arr;
</span></span><span style=display:flex><span>      <span style=color:#666>*</span>(_QWORD <span style=color:#666>*</span>)<span style=color:#666>&amp;</span>bpf_filter_prog.len <span style=color:#666>=</span> (<span style=color:#902000>int</span>)(<span style=color:#902000>unsigned</span> <span style=color:#007020;font-weight:700>__int16</span>)bpf_bytes_len <span style=color:#666>&gt;&gt;</span> <span style=color:#40a070>3</span>;
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> ( prctl(<span style=color:#40a070>22</span>, <span style=color:#40a070>2LL</span>, <span style=color:#666>&amp;</span>bpf_filter_prog) )   <span style=color:#60a0b0;font-style:italic>// PR_SET_SECCOMP
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>        perror(<span style=color:#4070a0>&#34;prctl&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>        <span style=color:#06287e>puts</span>(<span style=color:#4070a0>&#34;Installed!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><h2 id=bpf>BPF</h2><p>BPF（伯克利包过滤器，<strong>B</strong>erkeley <strong>P</strong>acket <strong>F</strong>ilter）最初的设计目标是更快地捕获和过滤网络数据包。引用 <a href=https://zh.wikipedia.org/wiki/BPF>wiki</a> 的介绍</p><blockquote><p><strong>伯克利包过滤器</strong> （Berkeley Packet Filter，缩写 BPF），是<a href=https://zh.wikipedia.org/wiki/%E7%B1%BBUnix title=类Unix>类Unix</a>系统上<a href=https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82 title=数据链路层>数据链路层</a>的一种原始接口，提供原始链路层<a href=https://zh.wikipedia.org/wiki/%E5%B0%81%E5%8C%85 title=封包>封包</a>的收发。除此之外，如果网卡驱动支持<a href=https://zh.wikipedia.org/wiki/%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F title=混杂模式>混杂模式</a>，那么它可以让网卡处于此种模式，这样可以收到<a href=https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C title=网络>网络</a>上的所有包，不管他们的目的地是不是所在<a href=https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%A9%9F title=主机>主机</a>。</p><p>另外，BPF支持过滤数据包——用户态的进程可以提供一个过滤程序来声明它想收到哪些数据包。通过这种过滤可以避免从<a href=https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F>操作系统</a><a href=https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8 title=内核>内核</a>向用户态复制其他对用户态程序无用的数据包，从而极大地提高性能。</p><p>BPF有时也只表示过滤机制，而不是整个接口。一些系统，比如<a href=https://zh.wikipedia.org/wiki/Linux title=Linux>Linux</a>和Tru64 Unix，提供了数据链路层的原始接口，而不是BPF的接口，但使用了BPF的过滤机制。</p><p>BSD 内核实现例程如 <code>bpf_mtap()</code>和 <code>bpf_tap()</code>，以<code>BPF_MTAP()</code>和 <code>BPF_TAP()</code>等<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AE%8F%E5%AE%9A%E4%B9%89&amp;action=edit&amp;redlink=1" title=宏定义（页面不存在）>宏定义</a>的形式进行包裹由网卡驱动(以及伪驱动pseudo-drivers) 向BPF机制发送进出的封包。</p></blockquote><p>我的理解就是在内核建立一个以寄存器为基础的虚拟机，用户向内核注入虚拟机字节码，通过内核中的 JIT 编译器就可以高效地在内核态执行用户添加的额外代码。是一个相对高效且安全地在用户态执行代码的机制</p><ul><li><strong>高效</strong>：不需要重启、不需要修改内核，JIT 编译直接在 CPU 上执行。</li><li><strong>安全</strong>：在内核态运行之前会先通过一个 verifier 检测字节码是否安全，比 module 直接插入用户代码会更加安全。</li></ul><p>BPF 刚被实现时其虚拟机只有两个寄存器，后来又有技术人员对它进行了扩展，增加到了 12 个寄存器和一些新的机制，扩展后的 BPF 就被称为 eBPF（extended BPF），原来的 BPF 就被称为 cBPF（classic BPF）。</p><h3 id=seccomp-中的使用>seccomp 中的使用</h3><p>seccomp-bpf 使用的是 cBPF（当然一些情况下这句话不怎么准确，因为如果内核支持 eBPF 的话，cBPF 会被翻译成 eBPF 执行）。cBPF 有一个 32 位累加寄存器 BPF_A，一个 32 位索引寄存器和 16 * 32 位的内存（也有人把这个当作 32 位寄存器，用 M[] 访问，这样说也是很有道理的，也就是有 16 个映射到内存的 32 位寄存器），当然还有一个不可编程的 PC。每条指令被抽象为了一个结构体</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	Try and keep these values and structures similar to BSD, especially
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	the BPF code definitions which need to match so you can share filters
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>sock_filter</span> {	<span style=color:#60a0b0;font-style:italic>/* Filter block */</span>
</span></span><span style=display:flex><span>	__u16	code;   <span style=color:#60a0b0;font-style:italic>/* Actual filter code */</span>
</span></span><span style=display:flex><span>	__u8	jt;	<span style=color:#60a0b0;font-style:italic>/* Jump true */</span>
</span></span><span style=display:flex><span>	__u8	jf;	<span style=color:#60a0b0;font-style:italic>/* Jump false */</span>
</span></span><span style=display:flex><span>	__u32	k;      <span style=color:#60a0b0;font-style:italic>/* Generic multiuse field */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>整条指令链就被抽象为了</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>sock_fprog</span> {	<span style=color:#60a0b0;font-style:italic>/* Required for SO_ATTACH_FILTER. */</span>
</span></span><span style=display:flex><span>	<span style=color:#902000>unsigned</span> <span style=color:#902000>short</span>		len;	<span style=color:#60a0b0;font-style:italic>/* Number of filter blocks */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>sock_filter</span> <span style=color:#666>*</span>filter;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>为了便于书写，在 filter.h 中封装了 cBPF 结构体宏，宏展开后实际上就是指令结构体。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * Macros for filter block array initializers.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#define BPF_STMT(code, k) { (unsigned short)(code), 0, 0, k }
</span></span></span><span style=display:flex><span><span style=color:#007020>#define BPF_JUMP(code, k, jt, jf) { (unsigned short)(code), jt, jf, k }
</span></span></span></code></pre></div><p>可用的指令被定义在了 bpf_common.h 中</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* Instruction classes */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#define BPF_CLASS(code) ((code) &amp; 0x07)
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_LD		0x00 </span><span style=color:#60a0b0;font-style:italic>// load, 赋值到寄存器中
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020>#define		BPF_LDX		0x01
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_ST		0x02 </span><span style=color:#60a0b0;font-style:italic>// store, 赋值到内存中
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020>#define		BPF_STX		0x03
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_ALU		0x04
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_JMP		0x05
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_RET		0x06
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_MISC        0x07
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* ld/ldx fields */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#define BPF_SIZE(code)  ((code) &amp; 0x18)
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_W		0x00 </span><span style=color:#60a0b0;font-style:italic>/* 32-bit */</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_H		0x08 </span><span style=color:#60a0b0;font-style:italic>/* 16-bit */</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_B		0x10 </span><span style=color:#60a0b0;font-style:italic>/*  8-bit */</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020></span><span style=color:#60a0b0;font-style:italic>/* eBPF		BPF_DW		0x18    64-bit */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#define BPF_MODE(code)  ((code) &amp; 0xe0)
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_IMM		0x00
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_ABS		0x20
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_IND		0x40
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_MEM		0x60
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_LEN		0x80
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_MSH		0xa0
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* alu/jmp fields */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#define BPF_OP(code)    ((code) &amp; 0xf0)
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_ADD		0x00
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_SUB		0x10
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_MUL		0x20
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_DIV		0x30
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_OR		0x40
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_AND		0x50
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_LSH		0x60
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_RSH		0x70
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_NEG		0x80
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_MOD		0x90
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_XOR		0xa0
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_JA		0x00
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_JEQ		0x10
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_JGT		0x20
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_JGE		0x30
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_JSET        0x40
</span></span></span><span style=display:flex><span><span style=color:#007020>#define BPF_SRC(code)   ((code) &amp; 0x08)
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_K		0x00
</span></span></span><span style=display:flex><span><span style=color:#007020>#define		BPF_X		0x08
</span></span></span></code></pre></div><p>以禁用 execve 为例，使用 bpf 禁用就是这样</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;unistd.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;stdio.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;stdint.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sys/syscall.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;linux/seccomp.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;linux/filter.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sys/prctl.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>sock_filter</span> filter[] <span style=color:#666>=</span> 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        BPF_STMT(BPF_LD <span style=color:#666>+</span> BPF_W <span style=color:#666>+</span> BPF_ABS, <span style=color:#40a070>0</span>),
</span></span><span style=display:flex><span>        BPF_JUMP(BPF_JMP <span style=color:#666>+</span> BPF_JEQ, SYS_execve, <span style=color:#40a070>0</span>, <span style=color:#40a070>1</span>),  <span style=color:#60a0b0;font-style:italic>/* sys_number == execve */</span>
</span></span><span style=display:flex><span>        BPF_STMT(BPF_RET <span style=color:#666>+</span> BPF_K, SECCOMP_RET_KILL),    <span style=color:#60a0b0;font-style:italic>/* true */</span>
</span></span><span style=display:flex><span>        BPF_STMT(BPF_RET <span style=color:#666>+</span> BPF_K, SECCOMP_RET_ALLOW)    <span style=color:#60a0b0;font-style:italic>/* false */</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>sock_fprog</span> bpf_prog;
</span></span><span style=display:flex><span>    bpf_prog.filter <span style=color:#666>=</span> filter;
</span></span><span style=display:flex><span>    bpf_prog.len <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span>(filter) <span style=color:#666>/</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>sock_filter</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    prctl(PR_SET_NO_NEW_PRIVS, <span style=color:#40a070>1</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>    prctl(PR_SET_SECCOMP, <span style=color:#40a070>2</span>, <span style=color:#666>&amp;</span>bpf_prog);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>while</span>(<span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* code */</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里在设置 seccomp 之前先执行了 <code>prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);</code>，这条语句禁止了此进程提权。这么做的原因是使用 prctl 的 PR_SET_SECCOMP 需要 CAP_SYS_ADMIN 这个 capabilities，如果没有这个 capabilities 就需要设置 PR_SET_NO_NEW_PRIVS 为 1，否则对于非 root 用户 seccomp 就会失效。</p><p>bpf 的每一条指令中的 <code>code</code> 都由 <code>指令类型 + 指令</code> 的方法组成。filter.h 提供的宏 BPF_STMT 是普通语句，做运算和内存操作等，BPF_JUMP 就是跳转语句，jf 和 jt 的值就是相应情况下跳过的指令数。</p><p>编译后用 seccomp-tools dump 一下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ seccomp-tools dump ./seccomp_bpf
</span></span><span style=display:flex><span> line  CODE  JT   JF      <span style=color:#bb60d5>K</span>
</span></span><span style=display:flex><span><span style=color:#666>=================================</span>
</span></span><span style=display:flex><span> 0000: 0x20 0x00 0x00 0x00000000  <span style=color:#bb60d5>A</span> <span style=color:#666>=</span> sys_number
</span></span><span style=display:flex><span> 0001: 0x15 0x00 0x01 0x0000003b  <span style=color:#007020;font-weight:700>if</span> <span style=color:#666>(</span>A !<span style=color:#666>=</span> execve<span style=color:#666>)</span> goto <span style=color:#40a070>0003</span>
</span></span><span style=display:flex><span> 0002: 0x06 0x00 0x00 0x00000000  <span style=color:#007020;font-weight:700>return</span> KILL
</span></span><span style=display:flex><span> 0003: 0x06 0x00 0x00 0x7fff0000  <span style=color:#007020;font-weight:700>return</span> ALLOW
</span></span></code></pre></div><p>可以发现成功过滤了。</p><p>到这里就搞清楚了如何用 bpf 来进行系统调用过滤了。</p><h3 id=宏观地来看实现流程>宏观地来看实现流程</h3><p>然后再宏观地看一下 prctl 对 bpf 的处理流程，以 linux-5.12.9 版本的代码为例。</p><p>首先是 prctl 系统调用</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>SYSCALL_DEFINE5(prctl, <span style=color:#902000>int</span>, option, <span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>, arg2, <span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>, arg3,
</span></span><span style=display:flex><span>		<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>, arg4, <span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>, arg5)
</span></span></code></pre></div><p>这个系统调用使用了一个巨大的 switch 来处理各种功能选项，我们关心的是这个 case</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>PR_SET_SECCOMP</span>:
</span></span><span style=display:flex><span>		error <span style=color:#666>=</span> prctl_set_seccomp(arg2, (<span style=color:#902000>char</span> __user <span style=color:#666>*</span>)arg3);
</span></span></code></pre></div><p>此功能由 prctl_set_seccomp 函数实现，函数比较简短，这里全部放一下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * prctl_set_seccomp: configures current-&gt;seccomp.mode
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @seccomp_mode: requested mode to use
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @filter: optional struct sock_fprog for use with SECCOMP_MODE_FILTER
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * Returns 0 on success or -EINVAL on failure.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#902000>long</span> <span style=color:#06287e>prctl_set_seccomp</span>(<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span> seccomp_mode, <span style=color:#902000>void</span> __user <span style=color:#666>*</span>filter)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> op;
</span></span><span style=display:flex><span>	<span style=color:#902000>void</span> __user <span style=color:#666>*</span>uargs;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>switch</span> (seccomp_mode) {
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>SECCOMP_MODE_STRICT</span>:
</span></span><span style=display:flex><span>		op <span style=color:#666>=</span> SECCOMP_SET_MODE_STRICT;
</span></span><span style=display:flex><span>		<span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		 * Setting strict mode through prctl always ignored filter,
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		 * so make sure it is always NULL here to pass the internal
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		 * check in do_seccomp().
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		 */</span>
</span></span><span style=display:flex><span>		uargs <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>SECCOMP_MODE_FILTER</span>:
</span></span><span style=display:flex><span>		op <span style=color:#666>=</span> SECCOMP_SET_MODE_FILTER;
</span></span><span style=display:flex><span>		uargs <span style=color:#666>=</span> filter;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>default</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* prctl interface doesn&#39;t have flags, so they are always zero. */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> do_seccomp(op, <span style=color:#40a070>0</span>, uargs);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020>#define SECCOMP_MODE_STRICT 1
</span></span></span><span style=display:flex><span><span style=color:#007020>#define SECCOMP_MODE_FILTER 2
</span></span></span></code></pre></div><p>seccomp_mode 就是指定设置的模式了，strict mode 就是只允许 exit，sigreturn，read 和 write，filter mode 就是通过 bpf 来自定义过滤了。然后调用 do_seccomp 函数，也比较短</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* Common entry point for both prctl and syscall. */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>long</span> <span style=color:#06287e>do_seccomp</span>(<span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> op, <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> flags,
</span></span><span style=display:flex><span>		       <span style=color:#902000>void</span> __user <span style=color:#666>*</span>uargs)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>switch</span> (op) {
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>SECCOMP_SET_MODE_STRICT</span>:
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (flags <span style=color:#666>!=</span> <span style=color:#40a070>0</span> <span style=color:#666>||</span> uargs <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> seccomp_set_mode_strict();
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>SECCOMP_SET_MODE_FILTER</span>:
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> seccomp_set_mode_filter(flags, uargs);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>SECCOMP_GET_ACTION_AVAIL</span>:
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (flags <span style=color:#666>!=</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> seccomp_get_action_avail(uargs);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>SECCOMP_GET_NOTIF_SIZES</span>:
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (flags <span style=color:#666>!=</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> seccomp_get_notif_sizes(uargs);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>default</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们关系的是 SECCOMP_SET_MODE_FILTER 这个 case，可见实际调用的是 seccomp_set_mode_filter 函数，这个函数比较长，这里就不放了，我们主要关心的是流程对用户 bpf 代码的处理，也就是编译的过程，最后进行编译的函数为 bpf_prepare_filter，调用链为</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>seccomp_prepare_user_filter
</span></span><span style=display:flex><span>seccomp_prepare_filter
</span></span><span style=display:flex><span>bpf_prog_create_from_user
</span></span><span style=display:flex><span>bpf_prepare_filter
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>bpf_prog</span> <span style=color:#666>*</span><span style=color:#06287e>bpf_prepare_filter</span>(<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>bpf_prog</span> <span style=color:#666>*</span>fp,
</span></span><span style=display:flex><span>					   bpf_aux_classic_check_t trans)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> err;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fp<span style=color:#666>-&gt;</span>bpf_func <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	fp<span style=color:#666>-&gt;</span>jited <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	err <span style=color:#666>=</span> bpf_check_classic(fp<span style=color:#666>-&gt;</span>insns, fp<span style=color:#666>-&gt;</span>len);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (err) {
</span></span><span style=display:flex><span>		__bpf_prog_release(fp);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> ERR_PTR(err);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* There might be additional checks and transformations
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * needed on classic filters, f.e. in case of seccomp.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (trans) {
</span></span><span style=display:flex><span>		err <span style=color:#666>=</span> trans(fp<span style=color:#666>-&gt;</span>insns, fp<span style=color:#666>-&gt;</span>len);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (err) {
</span></span><span style=display:flex><span>			__bpf_prog_release(fp);
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> ERR_PTR(err);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* Probe if we can JIT compile the filter and if so, do
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * the compilation of the filter.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	bpf_jit_compile(fp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* JIT compiler couldn&#39;t process this filter, so do the
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * internal BPF translation for the optimized interpreter.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>fp<span style=color:#666>-&gt;</span>jited)
</span></span><span style=display:flex><span>		fp <span style=color:#666>=</span> bpf_migrate_filter(fp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> fp;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里会尝试 jit 编译，如果失败就通过 bpf_migrate_filter 函数来进行转换，此函数会两次调用 bpf_convert_filter 函数，两次调用的注释为</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* 1st pass: calculate the new program length. */</span>
</span></span><span style=display:flex><span>err <span style=color:#666>=</span> bpf_convert_filter(old_prog, old_len, <span style=color:#007020>NULL</span>, <span style=color:#666>&amp;</span>new_len,
</span></span><span style=display:flex><span>				 <span style=color:#666>&amp;</span>seen_ld_abs);
</span></span><span style=display:flex><span>..
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* 2nd pass: remap sock_filter insns into bpf_insn insns. */</span>
</span></span><span style=display:flex><span>err <span style=color:#666>=</span> bpf_convert_filter(old_prog, old_len, fp, <span style=color:#666>&amp;</span>new_len,
</span></span><span style=display:flex><span>				 <span style=color:#666>&amp;</span>seen_ld_abs);
</span></span></code></pre></div><p>可见第一次是计算转换后的程序长度，第二次是正式的代码转换。bpf_convert_filter 的实现挺复杂的，我也没仔细看，这里就不多说了。</p><p>通过调试我发现 cBPF 代码是无法 jit 编译的，返回后 fp->jited 的值仍为 0</p><div style=text-align:center><img src=https://chujdk.github.io/usr/uploads/2021/07/287347397.png></div><p>我的理解是，jit 是 eBPF 实现的，所以 cBPF 代码需要被 bpf_migrate_filter 转换。</p><h3 id=ebpf-简单介绍>eBPF 简单介绍</h3><p>这玩意很复杂，不了解。这里为了解题，简单的了解了一下，相比于 cBPF 还是有不少变动的，首先是指令</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>bpf_insn</span> {
</span></span><span style=display:flex><span>	__u8	code;		<span style=color:#60a0b0;font-style:italic>/* opcode */</span>
</span></span><span style=display:flex><span>	__u8	<span style=color:#002070;font-weight:700>dst_reg</span>:<span style=color:#40a070>4</span>;	<span style=color:#60a0b0;font-style:italic>/* dest register */</span>
</span></span><span style=display:flex><span>	__u8	<span style=color:#002070;font-weight:700>src_reg</span>:<span style=color:#40a070>4</span>;	<span style=color:#60a0b0;font-style:italic>/* source register */</span>
</span></span><span style=display:flex><span>	__s16	off;		<span style=color:#60a0b0;font-style:italic>/* signed offset */</span>
</span></span><span style=display:flex><span>	__s32	imm;		<span style=color:#60a0b0;font-style:italic>/* signed immediate constant */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>寄存器也被扩充到了 10 个</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* Register numbers */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>enum</span> {
</span></span><span style=display:flex><span>	BPF_REG_0 <span style=color:#666>=</span> <span style=color:#40a070>0</span>,
</span></span><span style=display:flex><span>	BPF_REG_1,
</span></span><span style=display:flex><span>	BPF_REG_2,
</span></span><span style=display:flex><span>	BPF_REG_3,
</span></span><span style=display:flex><span>	BPF_REG_4,
</span></span><span style=display:flex><span>	BPF_REG_5,
</span></span><span style=display:flex><span>	BPF_REG_6,
</span></span><span style=display:flex><span>	BPF_REG_7,
</span></span><span style=display:flex><span>	BPF_REG_8,
</span></span><span style=display:flex><span>	BPF_REG_9,
</span></span><span style=display:flex><span>	BPF_REG_10,
</span></span><span style=display:flex><span>	__MAX_BPF_REG,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这些寄存器有约定功能</p><ul><li>R0：内核函数返回值存储再改寄存器中，同时也是 eBPF 程序的返回值寄存器</li><li>R1 - R5：调用内核函数的参数寄存器</li><li>R6 - R9：被调函数负责备份的寄存器</li><li>R10：用于访问栈的只读寄存器</li></ul><p>这十个寄存器在实际运行的时候是直接映射到 CPU 寄存器上的，以 x86_64 为例，R0 - R10 就依次映射到</p><ul><li>rax, rdi, rsi, rdx, rcx, r8, rbx, r13, r14, r15, rbp</li></ul><p>结合 cdecl 调用约定就很好理解了。</p><h2 id=参考>参考</h2><blockquote><p><a href=https://blog.csdn.net/ljy1988123/article/details/50444693>Linux内核工程导论——网络：Filter（LSF、BPF、eBPF）</a>
<a href=https://bbs.pediy.com/thread-258146.htm>[原创]seccomp沙箱机制 & 2019ByteCTF VIP</a></p></blockquote></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/curious>Curious</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/chujdk rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=mailto:chujj31@gmail.com rel=me title=Mail><i data-feather=mail></i></a>
<a class=border></a><a class=soc href=https://chujdk.github.io/index.xml rel=me title=Rss><i data-feather=rss></i></a>
<a class=border></a></div><div class=footer-info>2024 © chuj | Based on <a href=https://github.com/athul/archie>Archie</a> | Built with <a href=https://gohugo.io>Hugo</a> | <a href=#>Goto Top</a></div></footer><script>feather.replace()</script></div></body></html>