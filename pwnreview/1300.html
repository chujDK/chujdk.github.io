<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>ptmalloc 的简单分析 - blog of chuj</title><link rel=icon type=image/png href=https://chujdk.github.io/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="前言
断断续续写了一个多月，终于写完了。写本文的主要目的是获得一个对堆的理性认知，从知其然到知其所以然。主要分析了 __libc_malloc，_int_malloc，__libc_free，_int_free，malloc_consolidate 五个比较长且核心的函数。基本覆盖了较小（即未大到需要进行 sys_malloc）的情况。当然对于较大的请求的处理也是有必要学习的，之后应该会再写一篇。总的来说本文写的比较简略，且略过了对 malloc_chunk 结构体、unlink 函数的介绍，您在看之前应该需要对 ptmalloc 的流程和基础结构已有一定了解。"><meta property="og:image" content><meta property="og:url" content="https://chujdk.github.io/pwnreview/1300.html"><meta property="og:site_name" content="blog of chuj"><meta property="og:title" content="ptmalloc 的简单分析"><meta property="og:description" content="前言 断断续续写了一个多月，终于写完了。写本文的主要目的是获得一个对堆的理性认知，从知其然到知其所以然。主要分析了 __libc_malloc，_int_malloc，__libc_free，_int_free，malloc_consolidate 五个比较长且核心的函数。基本覆盖了较小（即未大到需要进行 sys_malloc）的情况。当然对于较大的请求的处理也是有必要学习的，之后应该会再写一篇。总的来说本文写的比较简略，且略过了对 malloc_chunk 结构体、unlink 函数的介绍，您在看之前应该需要对 ptmalloc 的流程和基础结构已有一定了解。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-23T22:42:00+00:00"><meta property="article:modified_time" content="2021-05-23T22:42:00+00:00"><meta property="article:tag" content="Curious"><meta name=twitter:card content="summary"><meta name=twitter:title content="ptmalloc 的简单分析"><meta name=twitter:description content="前言 断断续续写了一个多月，终于写完了。写本文的主要目的是获得一个对堆的理性认知，从知其然到知其所以然。主要分析了 __libc_malloc，_int_malloc，__libc_free，_int_free，malloc_consolidate 五个比较长且核心的函数。基本覆盖了较小（即未大到需要进行 sys_malloc）的情况。当然对于较大的请求的处理也是有必要学习的，之后应该会再写一篇。总的来说本文写的比较简略，且略过了对 malloc_chunk 结构体、unlink 函数的介绍，您在看之前应该需要对 ptmalloc 的流程和基础结构已有一定了解。"><script src=https://chujdk.github.io/js/feather.min.js></script><link href=https://chujdk.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://chujdk.github.io/css/main.d24d3471089d3a4f095edc4a6857e25a9f1c6dd3e7d17026141ccad319438873.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://chujdk.github.io/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://chujdk.github.io/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>ptmalloc 的简单分析</h1><div class=meta>Posted on May 23, 2021</div></div><section class=body><h1 id=前言>前言</h1><p>断断续续写了一个多月，终于写完了。写本文的主要目的是获得一个对堆的理性认知，从知其然到知其所以然。主要分析了 __libc_malloc，_int_malloc，__libc_free，_int_free，malloc_consolidate 五个比较长且核心的函数。基本覆盖了较小（即未大到需要进行 sys_malloc）的情况。当然对于较大的请求的处理也是有必要学习的，之后应该会再写一篇。总的来说本文写的比较简略，且略过了对 malloc_chunk 结构体、unlink 函数的介绍，您在看之前应该需要对 ptmalloc 的流程和基础结构已有一定了解。</p><p>当然由于本人才学疏浅，肯定会有许多纰漏，欢迎各位指正。</p><p><em>本文分析的 libc 版本为 glibc 2.33</em></p><h1 id=约定>约定：</h1><ul><li>如无特别说明，<strong>内部大小</strong>指用户申请的空间所对应的 chunk 的大小（包括 overhead），即 normalized request size。<strong>申请的大小</strong>则需要根据上下文来区分，可能指用户传入的大小，也可能指内部大小。</li><li>bin 和链表：四大 bin（fastbin，smallbin，largebin，unsorted bin）和 tcache 都是由一个或多个储存特定大小的 chunk 的 <strong>bin</strong> 组成的，而每个 <strong>bin</strong> 从数据结果上的角度来说都是<strong>隔离链表</strong>，以下对这样的 bin 可能会有多种称呼，如 <strong>bin</strong>，<strong>链表</strong>，<strong>隔离链表</strong>等，他们都指同样的东西。</li><li>largebin 的特性保证了其大小可以容纳两对双向链表指针，一对是和其他 chunk 类似的隔离链表指针，另一对是用来加速 largebin 遍历的 fd_nextsize 和 bk_nextsize 指针，我称之为 <strong>skip 链表</strong>（glibc 的注释中，称该链表为 <strong>skip list</strong>）</li><li>源码中注释使用的都是 C 风格的（<code>/*..*/</code>），所以笔者使用 <code>//</code> 来表示该注释是笔者加入的。</li><li>关于 best-fit 和 exact-fit：在 ptmalloc 中，exact-fit 代表返回的 chunk 大小和内部大小恰好相等，best-fit 则是最优的分配，这样的分配是可能会进行切割的，被切割的 chunk 是大小最接近的内部大小的 chunk。总的来说 ptmalloc 大多数情况下是 exact-fit 的，在 largebin 中则是 best-fit。</li></ul><h1 id=一些容易忘记的数据>一些容易忘记的数据</h1><p><code>MINSIZE</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#define MINSIZE  \
</span></span></span><span style=display:flex><span><span style=color:#007020>  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))
</span></span></span></code></pre></div><p>64 位下值为 0x20，32 位下值为 0x10，不过这个也不绝对，在 2.26 及之后，由于头文件包含优先级的问题，导致 32 位下的 MALLOC_ALIGN_MASK 也变成了 15，及此时 MINSIZE 为 0x20，每个 chunk 以 0x10 对齐。具体可以参考<a href=https://www.freebuf.com/articles/system/272335.html>此文</a>。</p><p><code>SIZE_SZ</code>：</p><p>32 位下为 4，64 位下为 8，就是机器字长。</p><h1 id=malloc>malloc</h1><h2 id=__libc_malloc>__libc_malloc</h2><p>glibc 通过 <code>strong_alias (__libc_malloc, malloc)</code> 使 malloc 成了 __libc_malloc 的别名，我们在调用 malloc 时，实际调用的是 __libc_malloc。其实现如下。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#666>*</span>
</span></span><span style=display:flex><span><span style=color:#06287e>__libc_malloc</span> (size_t bytes)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  mstate ar_ptr;
</span></span><span style=display:flex><span>  <span style=color:#902000>void</span> <span style=color:#666>*</span>victim;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  _Static_assert (PTRDIFF_MAX <span style=color:#666>&lt;=</span> SIZE_MAX <span style=color:#666>/</span> <span style=color:#40a070>2</span>,
</span></span><span style=display:flex><span>                  <span style=color:#4070a0>&#34;PTRDIFF_MAX is not more than half of SIZE_MAX&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#902000>void</span> <span style=color:#666>*</span>(<span style=color:#666>*</span>hook) (size_t, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>void</span> <span style=color:#666>*</span>)
</span></span><span style=display:flex><span>    <span style=color:#666>=</span> atomic_forced_read (__malloc_hook);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (__builtin_expect (hook <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>, <span style=color:#40a070>0</span>))
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> (<span style=color:#666>*</span>hook)(bytes, RETURN_ADDRESS (<span style=color:#40a070>0</span>));
</span></span><span style=display:flex><span><span style=color:#007020>#if USE_TCACHE
</span></span></span><span style=display:flex><span><span style=color:#007020></span>  <span style=color:#60a0b0;font-style:italic>/* int_free also calls request2size, be careful to not pad twice.  */</span>
</span></span><span style=display:flex><span>  size_t tbytes;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>checked_request2size (bytes, <span style=color:#666>&amp;</span>tbytes))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      __set_errno (ENOMEM);
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  size_t tc_idx <span style=color:#666>=</span> csize2tidx (tbytes);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  MAYBE_INIT_TCACHE ();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  DIAG_PUSH_NEEDS_COMMENT;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (tc_idx <span style=color:#666>&lt;</span> mp_.tcache_bins
</span></span><span style=display:flex><span>      <span style=color:#666>&amp;&amp;</span> tcache
</span></span><span style=display:flex><span>      <span style=color:#666>&amp;&amp;</span> tcache<span style=color:#666>-&gt;</span>counts[tc_idx] <span style=color:#666>&gt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      victim <span style=color:#666>=</span> tcache_get (tc_idx);
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>return</span> TAG_NEW_USABLE (victim);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  DIAG_POP_NEEDS_COMMENT;
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (SINGLE_THREAD_P)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      victim <span style=color:#666>=</span> TAG_NEW_USABLE (_int_malloc (<span style=color:#666>&amp;</span>main_arena, bytes));
</span></span><span style=display:flex><span>      assert (<span style=color:#666>!</span>victim <span style=color:#666>||</span> chunk_is_mmapped (mem2chunk (victim)) <span style=color:#666>||</span>
</span></span><span style=display:flex><span>	      <span style=color:#666>&amp;</span>main_arena <span style=color:#666>==</span> arena_for_chunk (mem2chunk (victim)));
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>return</span> victim;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  arena_get (ar_ptr, bytes);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  victim <span style=color:#666>=</span> _int_malloc (ar_ptr, bytes);
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/* Retry with another arena only if we were able to find a usable arena
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     before.  */</span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>victim <span style=color:#666>&amp;&amp;</span> ar_ptr <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      LIBC_PROBE (memory_malloc_retry, <span style=color:#40a070>1</span>, bytes);
</span></span><span style=display:flex><span>      ar_ptr <span style=color:#666>=</span> arena_get_retry (ar_ptr, bytes);
</span></span><span style=display:flex><span>      victim <span style=color:#666>=</span> _int_malloc (ar_ptr, bytes);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (ar_ptr <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>    __libc_lock_unlock (ar_ptr<span style=color:#666>-&gt;</span>mutex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  victim <span style=color:#666>=</span> TAG_NEW_USABLE (victim);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert (<span style=color:#666>!</span>victim <span style=color:#666>||</span> chunk_is_mmapped (mem2chunk (victim)) <span style=color:#666>||</span>
</span></span><span style=display:flex><span>          ar_ptr <span style=color:#666>==</span> arena_for_chunk (mem2chunk (victim)));
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> victim;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>libc_hidden_def (__libc_malloc)
</span></span></code></pre></div><p><code>_Static_assert</code> 是静态断言，在编译期完成，和我们分析的关系不大。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#666>*</span>(<span style=color:#666>*</span>hook) (size_t, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>void</span> <span style=color:#666>*</span>)
</span></span><span style=display:flex><span>    <span style=color:#666>=</span> atomic_forced_read (__malloc_hook);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (__builtin_expect (hook <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>, <span style=color:#40a070>0</span>))
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> (<span style=color:#666>*</span>hook)(bytes, RETURN_ADDRESS (<span style=color:#40a070>0</span>));
</span></span></code></pre></div><h3 id=初始化>初始化</h3><p>进入流程第一步是对 <code>__malloc_hook</code> 进行检测，如果 <code>__malloc_hook</code> 的值不为零，则直接调用其所指的函数。在第一次执行 <code>__libc_malloc</code>，也就是堆尚未初始化的情况下，<code>__malloc_hook</code> 指向的是 <code>malloc_hook_ini</code> 这个函数。</p><hr><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>void</span> <span style=color:#666>*</span>
</span></span><span style=display:flex><span><span style=color:#06287e>malloc_hook_ini</span> (size_t sz, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>void</span> <span style=color:#666>*</span>caller)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  __malloc_hook <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>  ptmalloc_init ();
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> __libc_malloc (sz);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个函数会调用 <code>ptmalloc_init ()</code> 来对堆进行一些初始化，主要是对 main_arena 的初始化等，然后重新调用 <code>__libc_malloc</code> 来为用户申请空间。</p><hr><h3 id=tcache>Tcache</h3><p>完成堆初始化后，进入 Tcache 分支，总体如下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#if USE_TCACHE
</span></span></span><span style=display:flex><span><span style=color:#007020></span>  <span style=color:#60a0b0;font-style:italic>/* int_free also calls request2size, be careful to not pad twice.  */</span>
</span></span><span style=display:flex><span>  size_t tbytes;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>checked_request2size (bytes, <span style=color:#666>&amp;</span>tbytes))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      __set_errno (ENOMEM);
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  size_t tc_idx <span style=color:#666>=</span> csize2tidx (tbytes);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  MAYBE_INIT_TCACHE ();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  DIAG_PUSH_NEEDS_COMMENT;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (tc_idx <span style=color:#666>&lt;</span> mp_.tcache_bins
</span></span><span style=display:flex><span>      <span style=color:#666>&amp;&amp;</span> tcache
</span></span><span style=display:flex><span>      <span style=color:#666>&amp;&amp;</span> tcache<span style=color:#666>-&gt;</span>counts[tc_idx] <span style=color:#666>&gt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      victim <span style=color:#666>=</span> tcache_get (tc_idx);
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>TAG_NEW_USABLE</span> (victim);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  DIAG_POP_NEEDS_COMMENT;
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span></code></pre></div><h4 id=预处理>预处理</h4><p>首先通过 <code>checked_request2size</code> 将用户请求的大小转为内部的大小并存储到 tbytes 中，注意到它在 2.33 下它已经成为函数，定义如下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>inline</span> <span style=color:#902000>bool</span>
</span></span><span style=display:flex><span><span style=color:#06287e>checked_request2size</span> (size_t req, size_t <span style=color:#666>*</span>sz) __nonnull (<span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (req <span style=color:#666>&gt;</span> PTRDIFF_MAX))
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020>#ifdef USE_MTAG
</span></span></span><span style=display:flex><span><span style=color:#007020></span>  <span style=color:#60a0b0;font-style:italic>/* When using tagged memory, we cannot share the end of the user
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     block with the header for the next chunk, so ensure that we
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     allocate blocks that are rounded up to the granule size.  Take
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     care not to overflow from close to MAX_SIZE_T to a small
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     number.  Ideally, this would be part of request2size(), but that
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     must be a macro that produces a compile time constant if passed
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     a constant literal.  */</span>
</span></span><span style=display:flex><span>  req <span style=color:#666>=</span> (req <span style=color:#666>+</span> <span style=color:#666>~</span>__mtag_granule_mask) <span style=color:#666>&amp;</span> __mtag_granule_mask;
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span>  <span style=color:#666>*</span>sz <span style=color:#666>=</span> request2size (req);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>和旧版本主要区别在于不再会主动报错，需要主调函数自行判断申请的空间是否过大</p><p>然后通过 <code>csize2tidx(tbytes)</code> 算出请求的大小所处的 idx，存入 tc_idx 中</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020># define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)
</span></span></span></code></pre></div><p>如果此时 Tcache 还未初始化，自然要先初始化 Tcache，通过宏 <code>MAYBE_INIT_TCACHE()</code> 判断执行</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020># define MAYBE_INIT_TCACHE() \
</span></span></span><span style=display:flex><span><span style=color:#007020>  if (__glibc_unlikely (tcache == NULL)) \
</span></span></span><span style=display:flex><span><span style=color:#007020>    tcache_init();
</span></span></span></code></pre></div><h4 id=tcache-管理结构体>Tcache 管理结构体</h4><p>此处的指针 tcache 的定义为 <code>static __thread tcache_perthread_struct *tcache = NULL;</code>，注意到该全局变量使用了 __thread 关键字修饰，在每个线程对这个变量访问时，访问的都是其副本，修改时只会修改副本的值，而不会对原值（image）发生修改，也就是说每个线程都拥有一个自己的 Tcache。tcache_perthread_struct 的定义如下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>tcache_perthread_struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#902000>uint16_t</span> counts[TCACHE_MAX_BINS];
</span></span><span style=display:flex><span>  tcache_entry <span style=color:#666>*</span>entries[TCACHE_MAX_BINS];
</span></span><span style=display:flex><span>} tcache_perthread_struct;
</span></span></code></pre></div><p>在 2.30 及之后版本中，counts 数组每一个计数器都占两字节，而不是旧版本中的一字节，改变的原因尚无权威的说法，这里不做揣测。TCACHE_MAX_BINS 的值为 64，也就是 Tcache 最多支持 64 个不同大小的隔离链表，内部大小从 0x20 到 0x410。由于 counts 类型的变化，新版本中每一个该结构体多会多占用 0x40 的空间，比如 64 位下总共占用 0x290 字节。</p><p>tcache_entry 结构体的定义为</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>tcache_entry</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>tcache_entry</span> <span style=color:#666>*</span>next;
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/* This field exists to detect double frees.  */</span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>tcache_perthread_struct</span> <span style=color:#666>*</span>key;
</span></span><span style=display:flex><span>} tcache_entry;
</span></span></code></pre></div><p>key 字段是在 2.28 及之后的版本后加入的，存在的意义是检测 double free，具体原理后面再说。</p><p>注意对 entries 的定义，使用的是 <code>tcache_entry *entries[TCACHE_MAX_BINS];</code>。可知 entries[tc_idx] 指向是链表中的第一个 chunk。</p><h4 id=初始化-1>初始化</h4><p>如果 tcache 指针指向 NULL，就代表该线程中 tcache 尚未初始化，就会调用 tcache_init 尝试为该结构体分配空间。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>void</span>
</span></span><span style=display:flex><span><span style=color:#06287e>tcache_init</span>(<span style=color:#902000>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  mstate ar_ptr;
</span></span><span style=display:flex><span>  <span style=color:#902000>void</span> <span style=color:#666>*</span>victim <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>const</span> size_t bytes <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span> (tcache_perthread_struct);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (tcache_shutting_down)
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  arena_get (ar_ptr, bytes);
</span></span><span style=display:flex><span>  victim <span style=color:#666>=</span> _int_malloc (ar_ptr, bytes);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>victim <span style=color:#666>&amp;&amp;</span> ar_ptr <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      ar_ptr <span style=color:#666>=</span> arena_get_retry (ar_ptr, bytes);
</span></span><span style=display:flex><span>      victim <span style=color:#666>=</span> _int_malloc (ar_ptr, bytes);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (ar_ptr <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>    __libc_lock_unlock (ar_ptr<span style=color:#666>-&gt;</span>mutex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/* In a low memory situation, we may not be able to allocate memory
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     - in which case, we just keep trying later.  However, we
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     typically do this very early, so either there is sufficient
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     memory, or there isn&#39;t enough memory to do non-trivial
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     allocations anyway.  */</span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (victim)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      tcache <span style=color:#666>=</span> (tcache_perthread_struct <span style=color:#666>*</span>) victim;
</span></span><span style=display:flex><span>      memset (tcache, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span> (tcache_perthread_struct));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>初始化的过程也比较简单，就是获取分配区加锁（这里的 ar_ptr 通过 arena_get 宏指向了 thread_arena），调用 _int_malloc 来为 tcache 分配管理器所需空间然后解锁并对分配的空间清零。</p><h4 id=分配>分配</h4><p>完成初始化后执行</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>DIAG_PUSH_NEEDS_COMMENT;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (tc_idx <span style=color:#666>&lt;</span> mp_.tcache_bins
</span></span><span style=display:flex><span>      <span style=color:#666>&amp;&amp;</span> tcache
</span></span><span style=display:flex><span>      <span style=color:#666>&amp;&amp;</span> tcache<span style=color:#666>-&gt;</span>counts[tc_idx] <span style=color:#666>&gt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      victim <span style=color:#666>=</span> tcache_get (tc_idx);
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>TAG_NEW_USABLE</span> (victim);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  DIAG_POP_NEEDS_COMMENT;
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span></code></pre></div><p><code>DIAG_PUSH_NEEDS_COMMENT; DIAG_POP_NEEDS_COMMENT;</code> 这两句比较怪异，定义在 libc-diag.h 中，不是很重要。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (tc_idx <span style=color:#666>&lt;</span> mp_.tcache_bins
</span></span><span style=display:flex><span>      <span style=color:#666>&amp;&amp;</span> tcache
</span></span><span style=display:flex><span>      <span style=color:#666>&amp;&amp;</span> tcache<span style=color:#666>-&gt;</span>counts[tc_idx] <span style=color:#666>&gt;</span> <span style=color:#40a070>0</span>)
</span></span></code></pre></div><p>这里判断了</p><ul><li>申请的空间是否在 tcache 的范围中（即小于 0x410）</li><li>tcache 是否被成功初始化，当机器所能支持的最大堆内存非常小（这种情况应该比较少）或者其他分配区占用了过多的空间时，初始化就会失败，这个时候自然不能再使用 tcache 进行分配。</li><li>对应的大小的链表中是否有 chunk。（注意这是在 2.30 版本修改的，在旧版本中是用 <code>tcache->entries[tc_idx] != NULL</code> 来判断的，建议思考一下两者的区别。在旧版本中相对更容易利用一些，直接改最底部的 tcache chunk 的 next 就可以实现任意地址分配）</li></ul><p>如果三个条件都满足，则调用 tcache_get (tc_idx) 来为 victim 分配空间</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* Caller must ensure that we know tc_idx is valid and there&#39;s
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   available chunks to remove.  */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> __always_inline <span style=color:#902000>void</span> <span style=color:#666>*</span>
</span></span><span style=display:flex><span><span style=color:#06287e>tcache_get</span> (size_t tc_idx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  tcache_entry <span style=color:#666>*</span>e <span style=color:#666>=</span> tcache<span style=color:#666>-&gt;</span>entries[tc_idx];
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (<span style=color:#666>!</span>aligned_OK (e)))
</span></span><span style=display:flex><span>    malloc_printerr (<span style=color:#4070a0>&#34;malloc(): unaligned tcache chunk detected&#34;</span>);
</span></span><span style=display:flex><span>  tcache<span style=color:#666>-&gt;</span>entries[tc_idx] <span style=color:#666>=</span> REVEAL_PTR (e<span style=color:#666>-&gt;</span>next);
</span></span><span style=display:flex><span>  <span style=color:#666>--</span>(tcache<span style=color:#666>-&gt;</span>counts[tc_idx]);
</span></span><span style=display:flex><span>  e<span style=color:#666>-&gt;</span>key <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>) e;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>首先取出链表头存入局部变量 e 中，先检测 e 指向的 chunk 是否对齐（64 位下和 0x10 对齐，32 位下和 0x8 对齐），然后对 e->next 通过 REVEAL_PTR 解密后更新 entries[tc_idx]，并更新 counts[tc_idx] 的值，完成取出 chunk 的操作，并对将要返还给用户的 chunk 的 key 字段清零。</p><hr><p>关于这里的 REVEAL_PTR，与 2.32（包括）之后的版本中加入的 Safe-Linking 操作有关。</p><p><strong>是 2.32 加入的不是 2.31，2.31 下就放心去打吧，不用泄露堆地址</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* Safe-Linking:
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   Use randomness from ASLR (mmap_base) to protect single-linked lists
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   of Fast-Bins and TCache.  That is, mask the &#34;next&#34; pointers of the
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   lists&#39; chunks, and also perform allocation alignment checks on them.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   This mechanism reduces the risk of pointer hijacking, as was done with
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   Safe-Unlinking in the double-linked lists of Small-Bins.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   larger pages provide less entropy, although the pointer mangling
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   still works.  */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#define PROTECT_PTR(pos, ptr) \
</span></span></span><span style=display:flex><span><span style=color:#007020>  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))
</span></span></span><span style=display:flex><span><span style=color:#007020>#define REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)
</span></span></span></code></pre></div><p>核心的是</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#define PROTECT_PTR(pos, ptr) \
</span></span></span><span style=display:flex><span><span style=color:#007020>  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))
</span></span></span></code></pre></div><p>这个宏，进行了异或加密，将 next 指针（对 tcache 而言）或 fd 指针（对 fastbin 而言）与该指针所在的地址的高 52 位相异或进行加解密（这里的位移操作还是有必要的，不然由于高地址相同的概率较大，低 12 位又可预测，容易被爆破）。<strong>当前版本只对 tcache 和 fastbin 进行了 Safe-Linking 的操作</strong>，加上了这一层保护后进行相关的攻击的时候就可能需要 leak 堆的地址了，给我们的利用增加了不少难度。</p><hr><p>通过 tcache_get 取得目标 chunk 了后，就会通过 <code>return TAG_NEW_USABLE (victim);</code> 返回给用户。（这里的 TAG_NEW_USABLE 默认情况下也没做，就是简单的将 victim 返回给用户，这也是在 2.33 中新加入的）。</p><p>到这里就可以看出 Tcache 的优先级是所有 bins 中最高的，在 __libc_malloc 中就完成了分配。</p><h4 id=准备调用-_int_malloc>准备调用 _int_malloc</h4><p>如果 Tcache 无法完成分配，就会执行下面的流程来调用 _int_malloc 来分配</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (SINGLE_THREAD_P)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      victim <span style=color:#666>=</span> TAG_NEW_USABLE (_int_malloc (<span style=color:#666>&amp;</span>main_arena, bytes));
</span></span><span style=display:flex><span>      assert (<span style=color:#666>!</span>victim <span style=color:#666>||</span> chunk_is_mmapped (mem2chunk (victim)) <span style=color:#666>||</span>
</span></span><span style=display:flex><span>	      <span style=color:#666>&amp;</span>main_arena <span style=color:#666>==</span> arena_for_chunk (mem2chunk (victim)));
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>return</span> victim;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  arena_get (ar_ptr, bytes);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  victim <span style=color:#666>=</span> _int_malloc (ar_ptr, bytes);
</span></span></code></pre></div><p>这里会对线程模式进行判断，但都是获取线程的分配区然后调用 _int_malloc 来分配。</p><h2 id=_int_malloc>_int_malloc</h2><h3 id=引言>引言</h3><p>这个基本上是 malloc 的核心函数了，比较长。</p><p>先粗略地说一下 _int_malloc 中的分配流程</p><ul><li>从 <code>fast bin</code> 中用 <code>best fit</code> 策略进行分配，如果成功，退出流程</li><li>从 <code>small bin</code> 中用 <code>best fit</code> 策略进行分配，如果成功，退出流程</li><li>到了这一步，说明 <code>fast bin</code> 和 <code>small bin</code> 中都不存在合适的 chunk，就可能需要从 <code>unsorted bin 和 large bin</code> 中尝试分配，但并不是直接分配，还要经过下面的流程<ul><li>如果申请是 large request，则调用 <code>malloc_consolidate</code> 函数。这个函数做的就是把 <code>fast bin</code> 中所有的 <code>bin</code> 能合并的都合并掉，然后把整个 <code>fast bin</code> 中的 <code>bin</code> 都放到 <code>Unsorted Bin</code> 中。</li><li>遍历 <code>Unsorted Bin</code>，对其中的每个 chunk 分为两种情况<ul><li><code>small request</code>：存在<strong>合适的 chunk</strong>（注意这个合适的条件是十分苛刻的，详见后文中“唯一的切割分配”）就会进行切割（tcache 加入后这里会进行一个 stash 操作，tcache 加入前会直接把 chunk 返回给用户），否则就把当前的 chunk 放到其对应的 <code>bin</code> 中</li><li>非 <code>small request</code>：放到对应的 <code>bin</code> 中</li></ul></li><li>尝试从 <code>large bin</code> 中对于 idx 的链表中分配</li></ul></li><li>到了这里表面没有对应的链表中都没有 chunk 可以分配，从更大的链表中尝试分配，这里使用 bitmap 来遍历。</li></ul><p>tcache，fastbin，smallbin 都是基于 <strong>bestfit</strong> 策略的，而 unsorted bin 是几个 bin 的缓冲区，必要时会切割合并。当然几个 bin 中的 chunk 也会在少数情况下合并。</p><p>定义在开头的一些常用变量</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>INTERNAL_SIZE_T nb;               <span style=color:#60a0b0;font-style:italic>/* normalized request size */</span>
</span></span><span style=display:flex><span>  <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> idx;                 <span style=color:#60a0b0;font-style:italic>/* associated bin index */</span>
</span></span><span style=display:flex><span>  mbinptr bin;                      <span style=color:#60a0b0;font-style:italic>/* associated bin */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  mchunkptr victim;                 <span style=color:#60a0b0;font-style:italic>/* inspected/selected chunk */</span>
</span></span><span style=display:flex><span>  INTERNAL_SIZE_T size;             <span style=color:#60a0b0;font-style:italic>/* its size */</span>
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> victim_index;                 <span style=color:#60a0b0;font-style:italic>/* its bin index */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  mchunkptr remainder;              <span style=color:#60a0b0;font-style:italic>/* remainder from a split */</span>
</span></span><span style=display:flex><span>  <span style=color:#902000>unsigned</span> <span style=color:#902000>long</span> remainder_size;     <span style=color:#60a0b0;font-style:italic>/* its size */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> block;               <span style=color:#60a0b0;font-style:italic>/* bit map traverser */</span>
</span></span><span style=display:flex><span>  <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> bit;                 <span style=color:#60a0b0;font-style:italic>/* bit map traverser */</span>
</span></span><span style=display:flex><span>  <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> map;                 <span style=color:#60a0b0;font-style:italic>/* current word of binmap */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  mchunkptr fwd;                    <span style=color:#60a0b0;font-style:italic>/* misc temp for linking */</span>
</span></span><span style=display:flex><span>  mchunkptr bck;                    <span style=color:#60a0b0;font-style:italic>/* misc temp for linking */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020>#if USE_TCACHE
</span></span></span><span style=display:flex><span><span style=color:#007020></span>  size_t tcache_unsorted_count;	    <span style=color:#60a0b0;font-style:italic>/* count of unsorted chunks processed */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span></code></pre></div><p>这里的变量 block，bit，map 三个变量是为了从 binmap 中寻址的，这个机构我们比较陌生，这里多说一点，binmap 是在结构体 mstate 中的一个成员数组，定义为</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> binmap[BINMAPSIZE];
</span></span></code></pre></div><p>相关的宏为</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   Binmap
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>    To help compensate for the large number of bins, a one-level index
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>    structure is used for bin-by-bin searching.  `binmap&#39; is a
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>    bitvector recording whether bins are definitely empty so they can
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>    be skipped over during during traversals.  The bits are NOT always
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>    cleared as soon as bins are empty, but instead only
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>    when they are noticed to be empty during traversal in malloc.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* Conservatively use 32 bits per map word, even if on 64bit system */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#define BINMAPSHIFT      5
</span></span></span><span style=display:flex><span><span style=color:#007020>#define BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)
</span></span></span><span style=display:flex><span><span style=color:#007020>#define BINMAPSIZE       (NBINS / BITSPERMAP)
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#007020>#define idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)
</span></span></span><span style=display:flex><span><span style=color:#007020>#define idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#007020>#define mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))
</span></span></span><span style=display:flex><span><span style=color:#007020>#define unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))
</span></span></span><span style=display:flex><span><span style=color:#007020>#define get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))
</span></span></span></code></pre></div><p>NBINS 为 128，所以 BINMAPSIZE 为 4。即 binmap 一共 128 位，4 个 int 大小，存在的意义是每一个 bit 对应一个 bin，用来标志此 bin 中是否有 chunk，这样可以在后面遍历时跳过那些没有 chunk 的链表。每一个 int，即 32 位作为一个 block，总共有 4 个 block。</p><p>通过 idx2block 可以算出 idx 所对应的 bin 在 binmap 上所处的 block。通过 idx2bit 可以算出 idx 在段上所对应的 bit 的位置。其余的一些宏可以对每个 bit 进行操作。mark_bin 可以置 bit 为 1，表示该 bin 中有 chunk，unmark_bin 则可以置 bit 为 0，表示 bin 中没有 chunk。</p><p>然后需要做一些初始化工作，主要是转换用户申请的大小为内部大小同时判断申请的合法性，仍然使用 <code>checked_request2size</code> 的方法</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>checked_request2size (bytes, <span style=color:#666>&amp;</span>nb))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      __set_errno (ENOMEM);
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>然后检验当前分配区是否初始化，在没有的时候通过 sysmalloc 为分配区分配空间</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (av <span style=color:#666>==</span> <span style=color:#007020>NULL</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#902000>void</span> <span style=color:#666>*</span>p <span style=color:#666>=</span> sysmalloc (nb, av);
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (p <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>	alloc_perturb (p, bytes);
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>return</span> p;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>接下来正式进入四大 bins 的分配。</p><h3 id=fastbin>fastbin</h3><p>首先是 fastbin，在 2.26 之后的版本中，由于增加了 fastbin stash 的机制，fastbin 可能需要进行多次解链，将该操作在多线程情况下的处理抽离成了一个宏</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#define REMOVE_FB(fb, victim, pp)			\
</span></span></span><span style=display:flex><span><span style=color:#007020>  do							\
</span></span></span><span style=display:flex><span><span style=color:#007020>    {							\
</span></span></span><span style=display:flex><span><span style=color:#007020>      victim = pp;					\
</span></span></span><span style=display:flex><span><span style=color:#007020>      if (victim == NULL)				\
</span></span></span><span style=display:flex><span><span style=color:#007020>	break;						\
</span></span></span><span style=display:flex><span><span style=color:#007020>      pp = REVEAL_PTR (victim-&gt;fd);                                     \
</span></span></span><span style=display:flex><span><span style=color:#007020>      if (__glibc_unlikely (pp != NULL &amp;&amp; misaligned_chunk (pp)))       \
</span></span></span><span style=display:flex><span><span style=color:#007020>	malloc_printerr (&#34;malloc(): unaligned fastbin chunk detected&#34;); \
</span></span></span><span style=display:flex><span><span style=color:#007020>    }							\
</span></span></span><span style=display:flex><span><span style=color:#007020>  while ((pp = catomic_compare_and_exchange_val_acq (fb, pp, victim)) \
</span></span></span><span style=display:flex><span><span style=color:#007020>	 != victim);					\
</span></span></span></code></pre></div><p>注意调用时的方法为 <code>REMOVE_FB (fb, pp, victim);</code>，宏中的 <code>catomic_compare_and_exchange_val_acq</code> 解释如下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>/* Atomically store NEWVAL in *MEM if *MEM is equal to OLDVAL.
</span></span><span style=display:flex><span>   Return the old *MEM value.  */
</span></span></code></pre></div><p>可见该宏通过原子变量来避免多线程情况下的赋值错误，而做的事情和单线程下也无区别，就是 <code>*fb = REVEAL_PTR (victim->fd);</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> ((<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (nb) <span style=color:#666>&lt;=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (get_max_fast ()))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      idx <span style=color:#666>=</span> fastbin_index (nb);
</span></span><span style=display:flex><span>      mfastbinptr <span style=color:#666>*</span>fb <span style=color:#666>=</span> <span style=color:#666>&amp;</span>fastbin (av, idx);
</span></span><span style=display:flex><span>      mchunkptr pp;
</span></span><span style=display:flex><span>      victim <span style=color:#666>=</span> <span style=color:#666>*</span>fb;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (victim <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (misaligned_chunk (victim)))
</span></span><span style=display:flex><span>	    malloc_printerr (<span style=color:#4070a0>&#34;malloc(): unaligned fastbin chunk detected 2&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> (SINGLE_THREAD_P)
</span></span><span style=display:flex><span>	    <span style=color:#666>*</span>fb <span style=color:#666>=</span> REVEAL_PTR (victim<span style=color:#666>-&gt;</span>fd);
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>	    <span style=color:#06287e>REMOVE_FB</span> (fb, pp, victim);
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> (__glibc_likely (victim <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>))
</span></span><span style=display:flex><span>	    {
</span></span><span style=display:flex><span>	      size_t victim_idx <span style=color:#666>=</span> fastbin_index (chunksize (victim));
</span></span><span style=display:flex><span>	      <span style=color:#007020;font-weight:700>if</span> (__builtin_expect (victim_idx <span style=color:#666>!=</span> idx, <span style=color:#40a070>0</span>))
</span></span><span style=display:flex><span>		malloc_printerr (<span style=color:#4070a0>&#34;malloc(): memory corruption (fast)&#34;</span>);
</span></span><span style=display:flex><span>	      check_remalloced_chunk (av, victim, nb);
</span></span></code></pre></div><hr><p>如果内部大小小于 fastbin 的最大大小，则尝试从 fastbin 中分配，通过 get_max_fast 函数来取得最大大小</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>inline</span> INTERNAL_SIZE_T
</span></span><span style=display:flex><span><span style=color:#06287e>get_max_fast</span> (<span style=color:#902000>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/* Tell the GCC optimizers that global_max_fast is never larger
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     than MAX_FAST_SIZE.  This avoids out-of-bounds array accesses in
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     _int_malloc after constant propagation of the size parameter.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     (The code never executes because malloc preserves the
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     global_max_fast invariant, but the optimizers may not recognize
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     this.)  */</span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (global_max_fast <span style=color:#666>&gt;</span> MAX_FAST_SIZE)
</span></span><span style=display:flex><span>    __builtin_unreachable ();
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> global_max_fast;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>也就是直接返回 global_max_fast，是一个全局变量（pwn 中有时可以通过修改这个变量来进行进一步利用）。</p><hr><p>fastbin 的分配处理比较简单：</p><ul><li>通过 <code>idx = fastbin_index (nb);</code> 算出申请的空间所属的下标，然后通过 <code>mfastbinptr *fb = &amp;fastbin (av, idx);</code> 取得链表头，两函数的定义为</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])
</span></span></span><span style=display:flex><span><span style=color:#007020></span>  
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/* offset 2 to use otherwise unindexable first 2 bins */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#define fastbin_index(sz)
</span></span></span><span style=display:flex><span><span style=color:#007020></span>  ((((<span style=color:#902000>unsigned</span> <span style=color:#902000>int</span>) (sz)) <span style=color:#666>&gt;&gt;</span> (SIZE_SZ <span style=color:#666>==</span> <span style=color:#40a070>8</span> <span style=color:#666>?</span> <span style=color:#40a070>4</span> <span style=color:#666>:</span> <span style=color:#40a070>3</span>)) <span style=color:#666>-</span> <span style=color:#40a070>2</span>)
</span></span></code></pre></div><ul><li>把取得的链表头给 victim，判断 victim 是否为 NULL，若不为 NULL，则代表 fastbin 中存在至少一个 chunk，然后就会进行解链，也就是 <code>*fb = REVEAL_PTR (victim->fd);</code>，将头节点指向链表中的下一个节点</li><li>进行 size 的合法性检查，正是此检查使我们在做 house of spirit 的时候必须在目标地址伪造 size。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (__glibc_likely (victim <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>))
</span></span><span style=display:flex><span>	  {
</span></span><span style=display:flex><span>	    size_t victim_idx <span style=color:#666>=</span> fastbin_index (chunksize (victim));
</span></span><span style=display:flex><span>	    <span style=color:#007020;font-weight:700>if</span> (__builtin_expect (victim_idx <span style=color:#666>!=</span> idx, <span style=color:#40a070>0</span>))
</span></span><span style=display:flex><span>		malloc_printerr (<span style=color:#4070a0>&#34;malloc(): memory corruption (fast)&#34;</span>);
</span></span><span style=display:flex><span>	    check_remalloced_chunk (av, victim, nb);<span style=color:#60a0b0;font-style:italic>// 这一句仅调试时启用，做了更细致的检查
</span></span></span></code></pre></div><p>在 2.26 tcache 加入后，便增加了 fastbin stash 的机制，紧跟在合法性检查之后，其实现如下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#if USE_TCACHE
</span></span></span><span style=display:flex><span><span style=color:#007020></span>	      <span style=color:#60a0b0;font-style:italic>/* While we&#39;re here, if we see other chunks of the same size,
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		 stash them in the tcache.  */</span>
</span></span><span style=display:flex><span>	      size_t tc_idx <span style=color:#666>=</span> csize2tidx (nb);
</span></span><span style=display:flex><span>	      <span style=color:#007020;font-weight:700>if</span> (tcache <span style=color:#666>&amp;&amp;</span> tc_idx <span style=color:#666>&lt;</span> mp_.tcache_bins)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>		  mchunkptr tc_victim;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		  <span style=color:#60a0b0;font-style:italic>/* While bin not empty and tcache not full, copy chunks.  */</span>
</span></span><span style=display:flex><span>		  <span style=color:#007020;font-weight:700>while</span> (tcache<span style=color:#666>-&gt;</span>counts[tc_idx] <span style=color:#666>&lt;</span> mp_.tcache_count
</span></span><span style=display:flex><span>			 <span style=color:#666>&amp;&amp;</span> (tc_victim <span style=color:#666>=</span> <span style=color:#666>*</span>fb) <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>		    {
</span></span><span style=display:flex><span>		      <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))
</span></span><span style=display:flex><span>			malloc_printerr (<span style=color:#4070a0>&#34;malloc(): unaligned fastbin chunk detected 3&#34;</span>);
</span></span><span style=display:flex><span>		      <span style=color:#007020;font-weight:700>if</span> (SINGLE_THREAD_P)
</span></span><span style=display:flex><span>			<span style=color:#666>*</span>fb <span style=color:#666>=</span> REVEAL_PTR (tc_victim<span style=color:#666>-&gt;</span>fd);
</span></span><span style=display:flex><span>		      <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>			{
</span></span><span style=display:flex><span>			  REMOVE_FB (fb, pp, tc_victim);
</span></span><span style=display:flex><span>			  <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (tc_victim <span style=color:#666>==</span> <span style=color:#007020>NULL</span>))
</span></span><span style=display:flex><span>			    <span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		      tcache_put (tc_victim, tc_idx);
</span></span><span style=display:flex><span>		    }
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span></code></pre></div><p>实现也简单，就是从 fastbin 中一个个取出，同时一个个放到 tcache 中，直到 fastbin 空或 tcache 满，注意这里仅做了 chunk 是否对齐的检查，也就是说如果能控制一个 fastbin 的指针，借用 stash 机制，我们可以将任意地址放入 tcache 中，但是一般不会这么做（可以直接用 tcache 打..）。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#666>*</span>p <span style=color:#666>=</span> chunk2mem (victim);
</span></span><span style=display:flex><span>	      alloc_perturb (p, bytes);
</span></span><span style=display:flex><span>	      <span style=color:#007020;font-weight:700>return</span> p;
</span></span></code></pre></div><p>完成 stash 之后就可以返回分配的 chunk 了，return 前的两个语句一般情况下都不会生效。</p><hr><p>在加入 tcache 机制后，fastbin attack 变得黯然失色，这里我也放一下 2.23 下 fastbin 的实现</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     If the size qualifies as a fastbin, first check corresponding bin.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     This code is safe to execute even if av is not yet initialized, so we
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     can try it without checking, which saves some time on this fast path.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> ((<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (nb) <span style=color:#666>&lt;=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (get_max_fast ()))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      idx <span style=color:#666>=</span> fastbin_index (nb);
</span></span><span style=display:flex><span>      mfastbinptr <span style=color:#666>*</span>fb <span style=color:#666>=</span> <span style=color:#666>&amp;</span>fastbin (av, idx);
</span></span><span style=display:flex><span>      mchunkptr pp <span style=color:#666>=</span> <span style=color:#666>*</span>fb;
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>do</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          victim <span style=color:#666>=</span> pp;
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (victim <span style=color:#666>==</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>            <span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>while</span> ((pp <span style=color:#666>=</span> catomic_compare_and_exchange_val_acq (fb, victim<span style=color:#666>-&gt;</span>fd, victim))
</span></span><span style=display:flex><span>             <span style=color:#666>!=</span> victim);
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (victim <span style=color:#666>!=</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (__builtin_expect (fastbin_index (chunksize (victim)) <span style=color:#666>!=</span> idx, <span style=color:#40a070>0</span>))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              errstr <span style=color:#666>=</span> <span style=color:#4070a0>&#34;malloc(): memory corruption (fast)&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#002070;font-weight:700>errout</span>:
</span></span><span style=display:flex><span>              malloc_printerr (check_action, errstr, chunk2mem (victim), av);
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>          check_remalloced_chunk (av, victim, nb);
</span></span><span style=display:flex><span>          <span style=color:#902000>void</span> <span style=color:#666>*</span>p <span style=color:#666>=</span> chunk2mem (victim);
</span></span><span style=display:flex><span>          alloc_perturb (p, bytes);
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>return</span> p;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>和 2.33 相比基本上只是少了 tcache stash、safe-linking、align_check 三个操作。</p><hr><h3 id=smallbin>smallbin</h3><p>如果 fastbin 无法完成分配，则尝试到 smallbin 中寻找 bestfit。（其实 ctf 的堆题中 smallbin 的存在感并不是很高，到现在为止只在 <a href=https://chujdk.github.io/WP/1167.html>house of orange</a>，<a href=https://chujdk.github.io/WP/1226.html>tcache stash unlink</a> 以及<a href=https://chujdk.github.io/WP/1289.html>一次通过 unsortedbin leak 不出来而不得不使用 smallbin leak</a> 中碰到过相关的利用。）</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     If a small request, check regular bin.  Since these &#34;smallbins&#34;
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     hold one size each, no searching within bins is necessary.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     (For a large request, we need to wait until unsorted chunks are
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     processed to find best fit. But for small ones, fits are exact
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     anyway, so we can check now, which is faster.)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (in_smallbin_range (nb))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      idx <span style=color:#666>=</span> smallbin_index (nb);
</span></span><span style=display:flex><span>      bin <span style=color:#666>=</span> bin_at (av, idx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> ((victim <span style=color:#666>=</span> last (bin)) <span style=color:#666>!=</span> bin)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          bck <span style=color:#666>=</span> victim<span style=color:#666>-&gt;</span>bk;
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (bck<span style=color:#666>-&gt;</span>fd <span style=color:#666>!=</span> victim))
</span></span><span style=display:flex><span>	    malloc_printerr (<span style=color:#4070a0>&#34;malloc(): smallbin double linked list corrupted&#34;</span>);
</span></span><span style=display:flex><span>          set_inuse_bit_at_offset (victim, nb);
</span></span><span style=display:flex><span>          bin<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> bck;
</span></span><span style=display:flex><span>          bck<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> bin;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (av <span style=color:#666>!=</span> <span style=color:#666>&amp;</span>main_arena)
</span></span><span style=display:flex><span>	    set_non_main_arena (victim);
</span></span><span style=display:flex><span>          check_malloced_chunk (av, victim, nb);
</span></span></code></pre></div><p>这里的处理也比较简单，如果有 bestfit，也就是链表头不指向自己，取出头节点，检查链表完整性，即 <code>victim->bk->fd == victim</code>，合法则给 chunk 的后一个 chunk 的 prev_inuse 位置 1，然后解链。</p><hr><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#if USE_TCACHE
</span></span></span><span style=display:flex><span><span style=color:#007020></span>	  <span style=color:#60a0b0;font-style:italic>/* While we&#39;re here, if we see other chunks of the same size,
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	     stash them in the tcache.  */</span>
</span></span><span style=display:flex><span>	  size_t tc_idx <span style=color:#666>=</span> csize2tidx (nb);
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> (tcache <span style=color:#666>&amp;&amp;</span> tc_idx <span style=color:#666>&lt;</span> mp_.tcache_bins)
</span></span><span style=display:flex><span>	    {
</span></span><span style=display:flex><span>	      mchunkptr tc_victim;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	      <span style=color:#60a0b0;font-style:italic>/* While bin not empty and tcache not full, copy chunks over.  */</span>
</span></span><span style=display:flex><span>	      <span style=color:#007020;font-weight:700>while</span> (tcache<span style=color:#666>-&gt;</span>counts[tc_idx] <span style=color:#666>&lt;</span> mp_.tcache_count
</span></span><span style=display:flex><span>		     <span style=color:#666>&amp;&amp;</span> (tc_victim <span style=color:#666>=</span> last (bin)) <span style=color:#666>!=</span> bin)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>		  <span style=color:#007020;font-weight:700>if</span> (tc_victim <span style=color:#666>!=</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>		    {
</span></span><span style=display:flex><span>		      bck <span style=color:#666>=</span> tc_victim<span style=color:#666>-&gt;</span>bk;
</span></span><span style=display:flex><span>		      set_inuse_bit_at_offset (tc_victim, nb);
</span></span><span style=display:flex><span>		      <span style=color:#007020;font-weight:700>if</span> (av <span style=color:#666>!=</span> <span style=color:#666>&amp;</span>main_arena)
</span></span><span style=display:flex><span>			set_non_main_arena (tc_victim);
</span></span><span style=display:flex><span>		      bin<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> bck;
</span></span><span style=display:flex><span>		      bck<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> bin;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		      tcache_put (tc_victim, tc_idx);
</span></span><span style=display:flex><span>	            }
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span></code></pre></div><p>类似于 fastbin，smallbin 也有类似的 stash 机制，从 smallbin 中一个个取出，同时一个个放到 tcache 中，直到 smallbin 空或 tcache 满，注意这里没有对链表的完整性进行检查，通过进行恰当的伪造，可以实现地址分配或者类似于 unsorted bin attack 的效果，也就是 <strong>Tcache stash unlink attack</strong> 系列攻击。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#666>*</span>p <span style=color:#666>=</span> chunk2mem (victim);
</span></span><span style=display:flex><span>          alloc_perturb (p, bytes);
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>return</span> p;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>完成 stash 后，返回 chunk，没什么可说的。</p><hr><h3 id=malloc_consolidate>malloc_consolidate</h3><p>到了这里说明前面的 chunk 中都不存在 bestfit，为了避免内存碎片过多的情况，会使用 malloc_consolidate 取出并所有的 fastbin，并对每一个 fastbin chunk，尝试进行前后向合并。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     If this is a large request, consolidate fastbins before continuing.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     While it might look excessive to kill all fastbins before
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     even seeing if there is space available, this avoids
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     fragmentation problems normally associated with fastbins.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     Also, in practice, programs tend to have runs of either small or
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     large requests, but less often mixtures, so consolidation is not
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     invoked all that often in most programs. And the programs that
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     it is called frequently in otherwise tend to fragment.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      idx <span style=color:#666>=</span> largebin_index (nb);
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (atomic_load_relaxed (<span style=color:#666>&amp;</span>av<span style=color:#666>-&gt;</span>have_fastchunks))
</span></span><span style=display:flex><span>        malloc_consolidate (av);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>注意这里的 else，只有在申请是 large request 的时候才会调用！</strong></p><p>进入函数后，首先定义了并初始化了一些变量</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>void</span> <span style=color:#06287e>malloc_consolidate</span>(mstate av)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  mfastbinptr<span style=color:#666>*</span>    fb;                 <span style=color:#60a0b0;font-style:italic>/* current fastbin being consolidated */</span>
</span></span><span style=display:flex><span>  mfastbinptr<span style=color:#666>*</span>    maxfb;              <span style=color:#60a0b0;font-style:italic>/* last fastbin (for loop control) */</span>
</span></span><span style=display:flex><span>  mchunkptr       p;                  <span style=color:#60a0b0;font-style:italic>/* current chunk being consolidated */</span>
</span></span><span style=display:flex><span>  mchunkptr       nextp;              <span style=color:#60a0b0;font-style:italic>/* next chunk to consolidate */</span>
</span></span><span style=display:flex><span>  mchunkptr       unsorted_bin;       <span style=color:#60a0b0;font-style:italic>/* bin header */</span>
</span></span><span style=display:flex><span>  mchunkptr       first_unsorted;     <span style=color:#60a0b0;font-style:italic>/* chunk to link to */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/* These have same use as in free() */</span>
</span></span><span style=display:flex><span>  mchunkptr       nextchunk;
</span></span><span style=display:flex><span>  INTERNAL_SIZE_T size;
</span></span><span style=display:flex><span>  INTERNAL_SIZE_T nextsize;
</span></span><span style=display:flex><span>  INTERNAL_SIZE_T prevsize;
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span>             nextinuse;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  atomic_store_relaxed (<span style=color:#666>&amp;</span>av<span style=color:#666>-&gt;</span>have_fastchunks, <span style=color:#007020>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  unsorted_bin <span style=color:#666>=</span> unsorted_chunks(av);
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>    Remove each chunk from fast bin and consolidate it, placing it
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>    then in unsorted bin. Among other reasons for doing this,
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>    placing in unsorted bin avoids needing to calculate actual bins
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>    until malloc is sure that chunks aren&#39;t immediately going to be
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>    reused anyway.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>  */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  maxfb <span style=color:#666>=</span> <span style=color:#666>&amp;</span>fastbin (av, NFASTBINS <span style=color:#666>-</span> <span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  fb <span style=color:#666>=</span> <span style=color:#666>&amp;</span>fastbin (av, <span style=color:#40a070>0</span>);
</span></span></code></pre></div><p>正式进入流程，虽然比较长，但是还是比较好理解的</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>do</span> {
</span></span><span style=display:flex><span>    p <span style=color:#666>=</span> atomic_exchange_acq (fb, <span style=color:#007020>NULL</span>);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (p <span style=color:#666>!=</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>do</span> {
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (misaligned_chunk (p)))
</span></span><span style=display:flex><span>	    malloc_printerr (<span style=color:#4070a0>&#34;malloc_consolidate(): &#34;</span>
</span></span><span style=display:flex><span>			     <span style=color:#4070a0>&#34;unaligned fastbin chunk detected&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	  <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> idx <span style=color:#666>=</span> fastbin_index (chunksize (p));
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> ((<span style=color:#666>&amp;</span>fastbin (av, idx)) <span style=color:#666>!=</span> fb)
</span></span><span style=display:flex><span>	    malloc_printerr (<span style=color:#4070a0>&#34;malloc_consolidate(): invalid chunk size&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	check_inuse_chunk(av, p);
</span></span><span style=display:flex><span>	nextp <span style=color:#666>=</span> REVEAL_PTR (p<span style=color:#666>-&gt;</span>fd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* Slightly streamlined version of consolidation code in free() */</span>
</span></span><span style=display:flex><span>	size <span style=color:#666>=</span> chunksize (p);
</span></span><span style=display:flex><span>	nextchunk <span style=color:#666>=</span> chunk_at_offset(p, size);
</span></span><span style=display:flex><span>	nextsize <span style=color:#666>=</span> chunksize(nextchunk);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>prev_inuse(p)) {
</span></span><span style=display:flex><span>	  prevsize <span style=color:#666>=</span> prev_size (p);
</span></span><span style=display:flex><span>	  size <span style=color:#666>+=</span> prevsize;
</span></span><span style=display:flex><span>	  p <span style=color:#666>=</span> chunk_at_offset(p, <span style=color:#666>-</span>((<span style=color:#902000>long</span>) prevsize));
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (chunksize(p) <span style=color:#666>!=</span> prevsize))
</span></span><span style=display:flex><span>	    malloc_printerr (<span style=color:#4070a0>&#34;corrupted size vs. prev_size in fastbins&#34;</span>);
</span></span><span style=display:flex><span>	  unlink_chunk (av, p);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (nextchunk <span style=color:#666>!=</span> av<span style=color:#666>-&gt;</span>top) {
</span></span><span style=display:flex><span>	  nextinuse <span style=color:#666>=</span> inuse_bit_at_offset(nextchunk, nextsize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>nextinuse) {
</span></span><span style=display:flex><span>	    size <span style=color:#666>+=</span> nextsize;
</span></span><span style=display:flex><span>	    unlink_chunk (av, nextchunk);
</span></span><span style=display:flex><span>	  } <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>	    <span style=color:#06287e>clear_inuse_bit_at_offset</span>(nextchunk, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	  first_unsorted <span style=color:#666>=</span> unsorted_bin<span style=color:#666>-&gt;</span>fd;
</span></span><span style=display:flex><span>	  unsorted_bin<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> p;
</span></span><span style=display:flex><span>	  first_unsorted<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> p;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>in_smallbin_range (size)) {
</span></span><span style=display:flex><span>	    p<span style=color:#666>-&gt;</span>fd_nextsize <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	    p<span style=color:#666>-&gt;</span>bk_nextsize <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	  set_head(p, size <span style=color:#666>|</span> PREV_INUSE);
</span></span><span style=display:flex><span>	  p<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> unsorted_bin;
</span></span><span style=display:flex><span>	  p<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> first_unsorted;
</span></span><span style=display:flex><span>	  set_foot(p, size);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>else</span> {
</span></span><span style=display:flex><span>	  size <span style=color:#666>+=</span> nextsize;
</span></span><span style=display:flex><span>	  set_head(p, size <span style=color:#666>|</span> PREV_INUSE);
</span></span><span style=display:flex><span>	  av<span style=color:#666>-&gt;</span>top <span style=color:#666>=</span> p;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      } <span style=color:#007020;font-weight:700>while</span> ( (p <span style=color:#666>=</span> nextp) <span style=color:#666>!=</span> <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  } <span style=color:#007020;font-weight:700>while</span> (fb<span style=color:#666>++</span> <span style=color:#666>!=</span> maxfb);
</span></span></code></pre></div><p>最外层循环的结束条件是 <code>while (fb++ != maxfb);</code>，也就是内层每一轮循环完成对一个隔离链表的解链和合并操作。</p><p>对于每一个隔离链表，首先取出头节点并对分配区中对应的指针置空，注意这里的 p 初始化后，指向要被操作的 fastbin，之后会进行多次更新，实际上指向的是<em>合并完成的 chunk</em>。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* Store NEWVALUE in *MEM and return the old value.  */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#ifndef atomic_exchange_acq
</span></span></span><span style=display:flex><span><span style=color:#007020># define atomic_exchange_acq(mem, newvalue) \
</span></span></span><span style=display:flex><span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020></span>p <span style=color:#666>=</span> atomic_exchange_acq (fb, <span style=color:#007020>NULL</span>);
</span></span></code></pre></div><p>如果 p 不为 NULL，也就是该链表中有 chunk，那么需要对该链表进行操作，使用了一个 do..while 循环对链表进行遍历，每一次遍历首先进行当前 chunk 进行合法性检查，检查了 chunk 是否对齐和 size 字段的合法性，实现如下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (p <span style=color:#666>!=</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>do</span> {
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (misaligned_chunk (p)))
</span></span><span style=display:flex><span>	    malloc_printerr (<span style=color:#4070a0>&#34;malloc_consolidate(): &#34;</span>
</span></span><span style=display:flex><span>			     <span style=color:#4070a0>&#34;unaligned fastbin chunk detected&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	  <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> idx <span style=color:#666>=</span> fastbin_index (chunksize (p));
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> ((<span style=color:#666>&amp;</span>fastbin (av, idx)) <span style=color:#666>!=</span> fb)
</span></span><span style=display:flex><span>	    malloc_printerr (<span style=color:#4070a0>&#34;malloc_consolidate(): invalid chunk size&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p><em>注意这里用两个花括号将合法性检查扩了起来。</em></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>check_inuse_chunk(av, p); <span style=color:#60a0b0;font-style:italic>// debug
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	nextp <span style=color:#666>=</span> REVEAL_PTR (p<span style=color:#666>-&gt;</span>fd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* Slightly streamlined version of consolidation code in free() */</span>
</span></span><span style=display:flex><span>	size <span style=color:#666>=</span> chunksize (p);
</span></span><span style=display:flex><span>	nextchunk <span style=color:#666>=</span> chunk_at_offset(p, size);
</span></span><span style=display:flex><span>	nextsize <span style=color:#666>=</span> chunksize(nextchunk);
</span></span></code></pre></div><p>通过合法性检查后，首先初始化一些局部变量，nextp 是循环控制变量，这里提前置为 fastbin 中的下一个 chunk，size 被初始化为当前 chunk 的大小，之后会更新，维护合并完的 chunk 的大小。</p><p>首先考虑前向合并</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>prev_inuse(p)) {
</span></span><span style=display:flex><span>	  prevsize <span style=color:#666>=</span> prev_size (p);
</span></span><span style=display:flex><span>	  size <span style=color:#666>+=</span> prevsize;
</span></span><span style=display:flex><span>	  p <span style=color:#666>=</span> chunk_at_offset(p, <span style=color:#666>-</span>((<span style=color:#902000>long</span>) prevsize));
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (chunksize(p) <span style=color:#666>!=</span> prevsize))
</span></span><span style=display:flex><span>	    malloc_printerr (<span style=color:#4070a0>&#34;corrupted size vs. prev_size in fastbins&#34;</span>);
</span></span><span style=display:flex><span>	  unlink_chunk (av, p);
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>如果前一个 chunk 不被使用，则可以前向合并，更新 size 和 p，将前一个 chunk unlink。</p><p>然后进行后向合并，如果后一个 chunk 是 top_chunk，那么直接和 top_chunk 合并，如果不是，首先检查后一个 chunk 是否在使用中，若不在使用，则进行后向合并并插入 unsorted bin 中（插到链表头和第一个节点中间），如果在使用，则修改其 prev_inuse 位。具体实现如下。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (nextchunk <span style=color:#666>!=</span> av<span style=color:#666>-&gt;</span>top) {
</span></span><span style=display:flex><span>	  nextinuse <span style=color:#666>=</span> inuse_bit_at_offset(nextchunk, nextsize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>nextinuse) {
</span></span><span style=display:flex><span>	    size <span style=color:#666>+=</span> nextsize;
</span></span><span style=display:flex><span>	    unlink_chunk (av, nextchunk);
</span></span><span style=display:flex><span>	  } <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>	    <span style=color:#06287e>clear_inuse_bit_at_offset</span>(nextchunk, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	  first_unsorted <span style=color:#666>=</span> unsorted_bin<span style=color:#666>-&gt;</span>fd;
</span></span><span style=display:flex><span>	  unsorted_bin<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> p;
</span></span><span style=display:flex><span>	  first_unsorted<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> p;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>in_smallbin_range (size)) {
</span></span><span style=display:flex><span>	    p<span style=color:#666>-&gt;</span>fd_nextsize <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	    p<span style=color:#666>-&gt;</span>bk_nextsize <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	  set_head(p, size <span style=color:#666>|</span> PREV_INUSE);
</span></span><span style=display:flex><span>	  p<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> unsorted_bin;
</span></span><span style=display:flex><span>	  p<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> first_unsorted;
</span></span><span style=display:flex><span>	  set_foot(p, size);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>else</span> {
</span></span><span style=display:flex><span>	  size <span style=color:#666>+=</span> nextsize;
</span></span><span style=display:flex><span>	  set_head(p, size <span style=color:#666>|</span> PREV_INUSE);
</span></span><span style=display:flex><span>	  av<span style=color:#666>-&gt;</span>top <span style=color:#666>=</span> p;
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>完成前后向合并后对该 fastbin 的操作就结束了，对 fastbin 中的每一个 chunk 都做同样的操作后函数流程结束。</p><hr><h3 id=遍历和处理-unsorted-bin>遍历和处理 unsorted bin</h3><p>完成 malloc_consolidate 之后，内部碎片已在一定程度上受到了整理，并且存入了 unsorted bin，就可以尝试从 unsorted bin 中进行分配了。</p><p>粗略的说，该流程会遍历每一个 unsorted bin chunk，对于每一个 chunk 的处理只有三种情况</p><ol><li>unsorted bin 的大小<strong>大于</strong>申请的大小且满足一些严苛的条件时，切割后返回给用户，结束流程</li><li>unsorted bin 的大小<strong>等于</strong>申请的大小</li><li>unsorted bin 的大小<strong>小于</strong>申请的大小，将该 chunk 从 unsorted bin 中取出放入对应的 bin 中</li></ol><p><em>每个 chunk 都会被取出，所以 while 循环可以每一次都取链表的尾部。</em></p><h4 id=遍历开头的合法性检查>遍历开头的合法性检查</h4><p>对 unsorted bin 的遍历是反向的，结束条件为链表中仅有一个节点。需要注意在 2.29 之后，在对每一个 unsorted bin 处理前都加入了一些合法性检查，主要是 chunk 的大小、是否和下一个 chunk 邻接和对 fd 指针的检查（这导致不少 unlink 攻击方法变得困难许多）</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     Process recently freed or remaindered chunks, taking one only if
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     it is exact fit, or, if this a small request, the chunk is remainder from
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     the most recent non-exact fit.  Place other traversed chunks in
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     bins.  Note that this step is the only place in any routine where
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     chunks are placed in bins.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     The outer loop here is needed because we might not realize until
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     near the end of malloc that we should have consolidated, so must
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     do so and retry. This happens at most once, and only when we would
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     otherwise need to expand memory to service a &#34;small&#34; request.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020>#if USE_TCACHE
</span></span></span><span style=display:flex><span><span style=color:#007020></span>  INTERNAL_SIZE_T tcache_nb <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  size_t tc_idx <span style=color:#666>=</span> csize2tidx (nb);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (tcache <span style=color:#666>&amp;&amp;</span> tc_idx <span style=color:#666>&lt;</span> mp_.tcache_bins)
</span></span><span style=display:flex><span>    tcache_nb <span style=color:#666>=</span> nb;
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> return_cached <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  tcache_unsorted_count <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>for</span> (;; )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#902000>int</span> iters <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>while</span> ((victim <span style=color:#666>=</span> unsorted_chunks (av)<span style=color:#666>-&gt;</span>bk) <span style=color:#666>!=</span> unsorted_chunks (av))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          bck <span style=color:#666>=</span> victim<span style=color:#666>-&gt;</span>bk;
</span></span><span style=display:flex><span>          size <span style=color:#666>=</span> chunksize (victim);
</span></span><span style=display:flex><span>          mchunkptr next <span style=color:#666>=</span> chunk_at_offset (victim, size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (size <span style=color:#666>&lt;=</span> CHUNK_HDR_SZ)
</span></span><span style=display:flex><span>              <span style=color:#666>||</span> __glibc_unlikely (size <span style=color:#666>&gt;</span> av<span style=color:#666>-&gt;</span>system_mem))
</span></span><span style=display:flex><span>            malloc_printerr (<span style=color:#4070a0>&#34;malloc(): invalid size (unsorted)&#34;</span>);
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (chunksize_nomask (next) <span style=color:#666>&lt;</span> CHUNK_HDR_SZ)
</span></span><span style=display:flex><span>              <span style=color:#666>||</span> __glibc_unlikely (chunksize_nomask (next) <span style=color:#666>&gt;</span> av<span style=color:#666>-&gt;</span>system_mem))
</span></span><span style=display:flex><span>            malloc_printerr (<span style=color:#4070a0>&#34;malloc(): invalid next size (unsorted)&#34;</span>);
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely ((prev_size (next) <span style=color:#666>&amp;</span> <span style=color:#666>~</span>(SIZE_BITS)) <span style=color:#666>!=</span> size))
</span></span><span style=display:flex><span>            malloc_printerr (<span style=color:#4070a0>&#34;malloc(): mismatching next-&gt;prev_size (unsorted)&#34;</span>);
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (bck<span style=color:#666>-&gt;</span>fd <span style=color:#666>!=</span> victim)
</span></span><span style=display:flex><span>              <span style=color:#666>||</span> __glibc_unlikely (victim<span style=color:#666>-&gt;</span>fd <span style=color:#666>!=</span> unsorted_chunks (av)))
</span></span><span style=display:flex><span>            malloc_printerr (<span style=color:#4070a0>&#34;malloc(): unsorted double linked list corrupted&#34;</span>);
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (prev_inuse (next)))
</span></span><span style=display:flex><span>            malloc_printerr (<span style=color:#4070a0>&#34;malloc(): invalid next-&gt;prev_inuse (unsorted)&#34;</span>);
</span></span></code></pre></div><p><em>这里在 <code>#if USE_TCACHE</code> 宏中的处理是为了后面的处理做准备的，此处按下不表</em></p><h4 id=切割分配>切割分配</h4><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>             If a small request, try to use last remainder if it is the
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>             only chunk in unsorted bin.  This helps promote locality for
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>             runs of consecutive small requests. This is the only
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>             exception to best-fit, and applies only when there is
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>             no exact fit for a small chunk.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>           */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (in_smallbin_range (nb) <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>              bck <span style=color:#666>==</span> unsorted_chunks (av) <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>              victim <span style=color:#666>==</span> av<span style=color:#666>-&gt;</span>last_remainder <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>              (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (size) <span style=color:#666>&gt;</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (nb <span style=color:#666>+</span> MINSIZE))
</span></span></code></pre></div><p>结合注释，可知这里的 if 是处理从 unsorted bin 中分配 small chunk 的情况。</p><p>仅当满足如下的条件：</p><ul><li>申请为 small request</li><li>unsorted bin 中仅有一个 chunk</li><li>unsorted bin 中仅有的 chunk 是 last remainder chunk</li><li>申请的 chunk 的大小加上 MINSIZE 要小于 unsorted bin 中仅有的 chunk 的大小</li><li>（一个隐含的条件）无法从 small bin 中分配</li></ul><p>的时候才会切割 unsorted bin 的 chunk，返回给用户。从注释中可以看出，这是分配器对 exact-fit 原则的一次例外，这种严苛的处理方式有利于提高分配器的<strong>局部性（locality）</strong>。</p><p>分配的实现方法为</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>{
</span></span><span style=display:flex><span>              <span style=color:#60a0b0;font-style:italic>/* split and reattach remainder */</span>
</span></span><span style=display:flex><span>              remainder_size <span style=color:#666>=</span> size <span style=color:#666>-</span> nb;
</span></span><span style=display:flex><span>              remainder <span style=color:#666>=</span> chunk_at_offset (victim, nb);
</span></span><span style=display:flex><span>              unsorted_chunks (av)<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> unsorted_chunks (av)<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> remainder;
</span></span><span style=display:flex><span>              av<span style=color:#666>-&gt;</span>last_remainder <span style=color:#666>=</span> remainder;
</span></span><span style=display:flex><span>              remainder<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> remainder<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> unsorted_chunks (av);
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>in_smallbin_range (remainder_size))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                  remainder<span style=color:#666>-&gt;</span>fd_nextsize <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>                  remainder<span style=color:#666>-&gt;</span>bk_nextsize <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              set_head (victim, nb <span style=color:#666>|</span> PREV_INUSE <span style=color:#666>|</span>
</span></span><span style=display:flex><span>                        (av <span style=color:#666>!=</span> <span style=color:#666>&amp;</span>main_arena <span style=color:#666>?</span> <span style=color:#002070;font-weight:700>NON_MAIN_ARENA</span> : <span style=color:#40a070>0</span>));
</span></span><span style=display:flex><span>              set_head (remainder, remainder_size <span style=color:#666>|</span> PREV_INUSE);
</span></span><span style=display:flex><span>              set_foot (remainder, remainder_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              check_malloced_chunk (av, victim, nb); <span style=color:#60a0b0;font-style:italic>// 仅 DEBUG 时启用
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>              <span style=color:#902000>void</span> <span style=color:#666>*</span>p <span style=color:#666>=</span> chunk2mem (victim);
</span></span><span style=display:flex><span>              alloc_perturb (p, bytes);
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>return</span> p;
</span></span><span style=display:flex><span>            }
</span></span></code></pre></div><p>首先更新 remainder 相关的参数，并设置 unsorted bin 指向的 chunk 为切割后的 chunk。根据切割后的 chunk 的大小决定是否初始化 large bin chunk 所需使用的指针。然后通过 set_head 和 set_foot 设置 chunk 的各字段，完成后返回给用户，结束 _int_malloc。</p><hr><p>如果不满足切割分配的严苛条件，那么该 unsorted bin 要么进入对应的 bin 中，要么满足 exact-fit 可以直接返回，无论如何都会离开 unsorted bin，所以先从 unsorted bin 中解链，注意这里对 bck->fd 做了检查（链表完整性检查），因此 unsorted bin attack 失效。</p><p><em><code>/* bck = victim->fd */</code></em></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* remove from unsorted list */</span>
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (bck<span style=color:#666>-&gt;</span>fd <span style=color:#666>!=</span> victim))
</span></span><span style=display:flex><span>            malloc_printerr (<span style=color:#4070a0>&#34;malloc(): corrupted unsorted chunks 3&#34;</span>);
</span></span><span style=display:flex><span>          unsorted_chunks (av)<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> bck;
</span></span><span style=display:flex><span>          bck<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> unsorted_chunks (av);
</span></span></code></pre></div><h4 id=exact-fit>exact-fit</h4><p>在 2.26（不包括）版本前，若当前遍历到的 unsorted bin 的大小和申请的内部大小恰好相等（exact-fit），就直接分配给用户。2.26 之后 tcache 加入后，即使是 exact-fit 也不直接返回，而是先缓存到 tcache 中（除非 tcache 已被填满）。并置 return_cached 变量为 1，该变量在进入 unsorted bin 遍历前定义。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* Take now instead of binning if exact fit */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (size <span style=color:#666>==</span> nb)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              set_inuse_bit_at_offset (victim, size);
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>if</span> (av <span style=color:#666>!=</span> <span style=color:#666>&amp;</span>main_arena)
</span></span><span style=display:flex><span>		set_non_main_arena (victim);
</span></span><span style=display:flex><span><span style=color:#007020>#if USE_TCACHE
</span></span></span><span style=display:flex><span><span style=color:#007020></span>	      <span style=color:#60a0b0;font-style:italic>/* Fill cache first, return to user only if cache fills.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		 We may return one of these chunks later.  */</span>
</span></span><span style=display:flex><span>	      <span style=color:#007020;font-weight:700>if</span> (tcache_nb
</span></span><span style=display:flex><span>		  <span style=color:#666>&amp;&amp;</span> tcache<span style=color:#666>-&gt;</span>counts[tc_idx] <span style=color:#666>&lt;</span> mp_.tcache_count)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>		  tcache_put (victim, tc_idx);
</span></span><span style=display:flex><span>		  return_cached <span style=color:#666>=</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>		  <span style=color:#007020;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	      <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020></span>              check_malloced_chunk (av, victim, nb);
</span></span><span style=display:flex><span>              <span style=color:#902000>void</span> <span style=color:#666>*</span>p <span style=color:#666>=</span> chunk2mem (victim);
</span></span><span style=display:flex><span>              alloc_perturb (p, bytes);
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>return</span> p;
</span></span><span style=display:flex><span><span style=color:#007020>#if USE_TCACHE
</span></span></span><span style=display:flex><span><span style=color:#007020></span>		}
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020></span>            }
</span></span></code></pre></div><h4 id=放入对应的-bin-中>放入对应的 bin 中</h4><h5 id=small-bin>Small Bin</h5><p>如果该 chunk 不满足前两个分支的条件，该 chunk 就会被放入对应的 bin 中。如果 chunk 属于 small bin，那么处理起来十分容易</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>          <span style=color:#60a0b0;font-style:italic>/* place chunk in bin */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (in_smallbin_range (size))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              victim_index <span style=color:#666>=</span> smallbin_index (size);
</span></span><span style=display:flex><span>              bck <span style=color:#666>=</span> bin_at (av, victim_index);
</span></span><span style=display:flex><span>              fwd <span style=color:#666>=</span> bck<span style=color:#666>-&gt;</span>fd;
</span></span><span style=display:flex><span>            }
</span></span></code></pre></div><p>首先算出目标的大小所在的 smallbin_index，然后将该 index 的表头所在地址赋值给 bck，把链表尾赋值给 fwd，在之后会把该 chunk 插入到两者之间</p><h5 id=large-bin>Large Bin</h5><p>如果属于 large bin，处理就会变得较为复杂</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>          <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              victim_index <span style=color:#666>=</span> largebin_index (size);
</span></span><span style=display:flex><span>              bck <span style=color:#666>=</span> bin_at (av, victim_index);
</span></span><span style=display:flex><span>              fwd <span style=color:#666>=</span> bck<span style=color:#666>-&gt;</span>fd;
</span></span></code></pre></div><p>一开始也和 small bin 一样，首先获得 largebin_index，然后将该 index 的表头所在地址赋值给 bck，把链表尾赋值给 fwd，也就是“插入”（这里的插入之所以打引号，是因为实际上没有插入，只是在流程结束后会通过 fwd 和 bck 来进行插入）到链表头上。但是这还没有结束，之后还需要进行对插入位置的调整。</p><hr><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>              /* maintain large bins in sorted order */
</span></span><span style=display:flex><span>              if (fwd != bck)
</span></span><span style=display:flex><span>                {
</span></span></code></pre></div><p>首先判断 fwd 和 bck 是否相等，由于 <code>fwd = bck->fd</code>，<code>bck->fd</code> 指向 bin 中的第一个 chunk，如果 fwd 和 bck 相等，说明该链表是为空的，不需要做额外处理。</p><p>如果两者不相等，说明该链表非空。由于 largebin 的每一个隔离链表中的 chunk 大小不一定相同，而且链表是有序的，插入 chunk 后也需要保证链表的有序性。之后的流程就完成了这个工作，实现如下</p><hr><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>                  <span style=color:#60a0b0;font-style:italic>/* Or with inuse bit to speed comparisons */</span>
</span></span><span style=display:flex><span>                  size <span style=color:#666>|=</span> PREV_INUSE;
</span></span><span style=display:flex><span>                  <span style=color:#60a0b0;font-style:italic>/* if smaller than smallest, bypass loop below */</span>
</span></span><span style=display:flex><span>                  assert (chunk_main_arena (bck<span style=color:#666>-&gt;</span>bk));
</span></span></code></pre></div><p>首先是预处理，先给 size 或上一个 PREV_INUSE 位，注释里说这是为了加快比较，估计是因为每个 largebin chunk 的 PREV_INUSE 位都为 1，这里提前或上后面比较的时候就不需要或了。</p><p>然后还会做一个断言，断言该链表尾的 chunk 必为主分配区 chunk。这个我倒是没看太懂，引用大佬的话就是</p><blockquote><p>因为所有在 large bin 中的 chunk 都处于空闲状态，该标志位一定是清零的。</p></blockquote><p>还不是特别理解。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>                  if ((unsigned long) (size)
</span></span><span style=display:flex><span>		      &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                      fwd = bck;
</span></span><span style=display:flex><span>                      bck = bck-&gt;bk;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                      victim-&gt;fd_nextsize = fwd-&gt;fd;
</span></span><span style=display:flex><span>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;
</span></span><span style=display:flex><span>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;
</span></span><span style=display:flex><span>                    }
</span></span></code></pre></div><p>预处理完可以正式进行处理，首先特判链表尾的 chunk 的大小是否大于当前 chunk 的大小，如果是，直接更新 fwd 和 bck，也就是准备将当前 chunk 插入到链表尾后，由此可见 largebin 中的 chunk 是从大到小排序的。这里还会更新 nextsize 的两个指针，可以看出每个 largebin 存在于两个双链表中，一个是 largebin 隔离链表，由 fd bk 指针维护；另一个是 skip 链表，由 fd_nextsize 和 bk_nextsize 维护。</p><hr><h6 id=skip-链表>skip 链表</h6><p>这里特别说一下 skip 链表存在的意义和其结构，largebin 由于大小不固定，寻找 fit 的 chunk 必然是远远慢于别的 bin 的，但是 largebin 的特性就是比较大，所以这里复用更多的空间，增加一对指针来维护 skip 链表以加快遍历速度。该链表的结构有<strong>星阑科技</strong>的大佬画了一张示意图，很形象，这里不要脸的盗过来（图中只绘出了 fd(_nextsize) 指针，bk(_nextsize) 指针就是反着指回去）</p><div style=text-align:center><img src=https://chujdk.github.io/usr/uploads/2021/05/1876628678.jpg></div><p>虽然每个隔离链表中的 chunk 都是不一样的，但是他们是有序的，所以如果存在大小相同的 chunk，一个个遍历过去是十分浪费时间的。从隔离链表中每个相同大小的 chunk的取出第一个 chunk 按照大小顺序用 fd_nextsize 和 bk_nextsize 按大小顺序链接在一起，让每一个 fd_nextsize 指针指向下一个大小的 chunk，bk_nextsize 则指向上一个大小的 chunk，这样在遍历时可以通过这两个指针跨越大小相同的 chunk，在一定程度上节省了遍历的时间。</p><hr><p>回到刚才对当前 chunk 的 fd_nextsize 和 bk_nextsize 的更新上，由于当前 chunk 的大小小于原链表表尾 chunk 的大小，所以需要设置两个指针。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>else
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                      assert (chunk_main_arena (fwd));
</span></span><span style=display:flex><span>                      while ((unsigned long) size &lt; chunksize_nomask (fwd))
</span></span><span style=display:flex><span>                      //#define chunksize_nomask(p)         ((p)-&gt;mchunk_size)
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                          fwd = fwd-&gt;fd_nextsize;
</span></span><span style=display:flex><span>			  assert (chunk_main_arena (fwd));
</span></span><span style=display:flex><span>                        }
</span></span></code></pre></div><p>如果不满足上述条件，就需要遍历整个隔离链表了，使用 fd_nextsize 进行正向遍历（从大到小），直到找第一个小于等于当前 chunk 大小的 chunk 为止。注意这里进行了多次断言，和前文所述的相同。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>if ((unsigned long) size
</span></span><span style=display:flex><span>			  == (unsigned long) chunksize_nomask (fwd))
</span></span><span style=display:flex><span>                        /* Always insert in the second position.  */
</span></span><span style=display:flex><span>                        fwd = fwd-&gt;fd;
</span></span></code></pre></div><p>退出循环后对找到的第一个满足条件的 chunk 的大小做检测，如果当前 chunk 和满足条件的 chunk 的大小相同，那么把当前 chunk “插入”到满足条件的 chunk 后，这样就不需要再更新两个 next_size 指针了。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>else
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                          victim-&gt;fd_nextsize = fwd;
</span></span><span style=display:flex><span>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;
</span></span><span style=display:flex><span>                          // 以下的检测是在 2.30（包括）后加入的
</span></span><span style=display:flex><span>                          if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))
</span></span><span style=display:flex><span>                            malloc_printerr (&#34;malloc(): largebin double linked list corrupted (nextsize)&#34;);
</span></span><span style=display:flex><span>                          fwd-&gt;bk_nextsize = victim;
</span></span><span style=display:flex><span>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;
</span></span><span style=display:flex><span>                        }
</span></span></code></pre></div><p>否则由于当前 chunk 的大小大于满足条件的 chunk，所以把当前 chunk 插到该 chunk 之前，并更新二者的 nextsize 指针。这里做了链表完整性检测。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>bck <span style=color:#666>=</span> fwd<span style=color:#666>-&gt;</span>bk;
</span></span><span style=display:flex><span>                      <span style=color:#007020;font-weight:700>if</span> (bck<span style=color:#666>-&gt;</span>fd <span style=color:#666>!=</span> fwd)
</span></span><span style=display:flex><span>                        malloc_printerr (<span style=color:#4070a0>&#34;malloc(): largebin double linked list corrupted (bk)&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span></code></pre></div><p>最后更新 bck 并做链表完整性检测。结束 <code>if (fwd != bck)</code> 也就是隔离链表中有 chunk 的情况的处理流程。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>                victim<span style=color:#666>-&gt;</span>fd_nextsize <span style=color:#666>=</span> victim<span style=color:#666>-&gt;</span>bk_nextsize <span style=color:#666>=</span> victim;
</span></span><span style=display:flex><span>            }
</span></span></code></pre></div><p>如果隔离链表中没有 chunk，也有必要设置两个 nextsize 指针，这样才能在之后向该链表中插入 chunk 时不出错。</p><hr><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>//#define mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>          mark_bin (av, victim_index);
</span></span><span style=display:flex><span>          victim<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> bck;
</span></span><span style=display:flex><span>          victim<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> fwd;
</span></span><span style=display:flex><span>          fwd<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> victim;
</span></span><span style=display:flex><span>          bck<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> victim;
</span></span></code></pre></div><p>这一段代码是在</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* place chunk in bin */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (in_smallbin_range (size))
</span></span><span style=display:flex><span>	    ...
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>	    ...
</span></span></code></pre></div><p>流程结束时进行的，这里真正将当前 chunk 插入到了 largebin 中，并将 large bin 所对应的 binmap 的相应 bit 置位。</p><p>到这里就正式结束了放入对应 bin 中的操作。</p><h4 id=一轮操作结束的收尾>一轮操作结束的收尾</h4><p>前面的一同操作只处理了一个 unsorted bin 哦，处理完一个后需要做一些收尾</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#if USE_TCACHE
</span></span></span><span style=display:flex><span><span style=color:#007020></span>      <span style=color:#60a0b0;font-style:italic>/* If we&#39;ve processed as many chunks as we&#39;re allowed while
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 filling the cache, return one of the cached ones.  */</span>
</span></span><span style=display:flex><span>      <span style=color:#666>++</span>tcache_unsorted_count;
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (return_cached
</span></span><span style=display:flex><span>	  <span style=color:#666>&amp;&amp;</span> mp_.tcache_unsorted_limit <span style=color:#666>&gt;</span> <span style=color:#40a070>0</span>
</span></span><span style=display:flex><span>	  <span style=color:#666>&amp;&amp;</span> tcache_unsorted_count <span style=color:#666>&gt;</span> mp_.tcache_unsorted_limit)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>tcache_get</span> (tc_idx);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span></code></pre></div><p>这里是为了防止由于向 tcache 中 stash chunk 导致明明有的 exact-fit 被雪藏于 tache 中，当 stash 进的 tcache_unsorted_count > mp_.tcache_unsorted_limit 时且有 exact-fit 被 stash 进 tcache 中时，会直接调用 tcache_get 从 tcache 中返回。（通过调试，在笔者的机器上，这里的 mp_.tcache_unsorted_limit 值为 0，即默认是不会设置 cache 的上限的。）</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#define MAX_ITERS       10000
</span></span></span><span style=display:flex><span><span style=color:#007020></span>          <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>++</span>iters <span style=color:#666>&gt;=</span> MAX_ITERS)
</span></span><span style=display:flex><span>            <span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>这里的 iters 是在进入遍历操作前定义的，记录了 unsorted bin 处理的总轮数，当总轮数过大即大于 10000 轮时直接结束对 unsorted bin 的遍历，避免长时间处理影响速度。</p><p>之后就会循环下去做下一轮操作直到满足退出条件。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#if USE_TCACHE
</span></span></span><span style=display:flex><span><span style=color:#007020></span>      <span style=color:#60a0b0;font-style:italic>/* If all the small chunks we found ended up cached, return one now.  */</span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (return_cached)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>tcache_get</span> (tc_idx);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span></code></pre></div><p>如果结束 unsorted bin 遍历时有在 tcache 中 cache 过chunk，那就直接返回 cache 的 chunk。</p><h3 id=largebin>largebin</h3><p>如果执行到这里说明 unsorted bin 中的空闲 chunk 已经进入了对应的 bin 中了，并且没有合适的可以返回给用户的 chunk。如果申请是 large request，就可以尝试从 largebin 中分配了。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>       <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         If a large request, scan through the chunks of current bin in
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         sorted order to find smallest that fits.  Use the skip list for this.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>       */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>in_smallbin_range (nb))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          bin <span style=color:#666>=</span> bin_at (av, idx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#60a0b0;font-style:italic>/* skip scan if empty or largest chunk is too small */</span>
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> ((victim <span style=color:#666>=</span> first (bin)) <span style=color:#666>!=</span> bin
</span></span><span style=display:flex><span>	      <span style=color:#666>&amp;&amp;</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) chunksize_nomask (victim)
</span></span><span style=display:flex><span>	        <span style=color:#666>&gt;=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (nb))
</span></span><span style=display:flex><span>            {
</span></span></code></pre></div><p>如果申请的大小在 largebin 的范围中，查询该大小所对应链表，如果该链表为空或链表中第一个（也就是最大的一个）chunk 的大小小于申请的大小，说明无法从 largebin 中分配。否则对链表进行遍历，尝试从链表中找到合适的 chunk 分配</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>              victim <span style=color:#666>=</span> victim<span style=color:#666>-&gt;</span>bk_nextsize;
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>while</span> (((<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (size <span style=color:#666>=</span> chunksize (victim)) <span style=color:#666>&lt;</span>
</span></span><span style=display:flex><span>                      (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (nb)))
</span></span><span style=display:flex><span>                victim <span style=color:#666>=</span> victim<span style=color:#666>-&gt;</span>bk_nextsize;
</span></span></code></pre></div><p>遍历为反向遍历，即从小到大遍历，直到找到第一个大于等于申请的 chunk 的大小的 chunk 为止。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>              <span style=color:#60a0b0;font-style:italic>/* Avoid removing the first entry for a size so that the skip
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>                 list does not have to be rerouted.  */</span>
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>if</span> (victim <span style=color:#666>!=</span> last (bin)
</span></span><span style=display:flex><span>		  <span style=color:#666>&amp;&amp;</span> chunksize_nomask (victim)
</span></span><span style=display:flex><span>		    <span style=color:#666>==</span> chunksize_nomask (victim<span style=color:#666>-&gt;</span>fd))
</span></span><span style=display:flex><span>                victim <span style=color:#666>=</span> victim<span style=color:#666>-&gt;</span>fd;
</span></span></code></pre></div><h4 id=best-fit-分配>best-fit 分配</h4><p>找到最合适的 chunk 后，该 chunk 之后的一个 chunk 的大小是否和该 chunk 相等，如果相等，就把候选的将返回的 chunk 设置为该 chunk 的下一个 chunk，这样可以避免重新设置 skip 链表。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>              remainder_size <span style=color:#666>=</span> size <span style=color:#666>-</span> nb;
</span></span><span style=display:flex><span>              unlink_chunk (av, victim);
</span></span></code></pre></div><p>然后记录切割后的 chunk 余留下的 chunk 的大小（注意这时还没有切割），并把当前的候选 chunk 从链表中 unlink。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>              <span style=color:#60a0b0;font-style:italic>/* Exhaust */</span>
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>if</span> (remainder_size <span style=color:#666>&lt;</span> MINSIZE)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                  set_inuse_bit_at_offset (victim, size);
</span></span><span style=display:flex><span>                  <span style=color:#007020;font-weight:700>if</span> (av <span style=color:#666>!=</span> <span style=color:#666>&amp;</span>main_arena)
</span></span><span style=display:flex><span>		    set_non_main_arena (victim);
</span></span><span style=display:flex><span>                }
</span></span></code></pre></div><p>然后根据余留的 chunk 的大小分类处理，如果余留的 chunk 大小小于 MINSIZE，那么就浪费掉这段空间，不进行切割，在将下一个 chunk 的 prev_inuse 位置 1 并根据当前的分配区设置好 chunk 的 non_main_arena 位后就可以准备一起返回给用户了。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>              <span style=color:#60a0b0;font-style:italic>/* Split */</span>
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                  remainder <span style=color:#666>=</span> chunk_at_offset (victim, nb);
</span></span><span style=display:flex><span>                  <span style=color:#60a0b0;font-style:italic>/* We cannot assume the unsorted list is empty and therefore
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>                     have to perform a complete insert here.  */</span>
</span></span><span style=display:flex><span>                  bck <span style=color:#666>=</span> unsorted_chunks (av);
</span></span><span style=display:flex><span>                  fwd <span style=color:#666>=</span> bck<span style=color:#666>-&gt;</span>fd;
</span></span><span style=display:flex><span>		  <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (fwd<span style=color:#666>-&gt;</span>bk <span style=color:#666>!=</span> bck))
</span></span><span style=display:flex><span>		    malloc_printerr (<span style=color:#4070a0>&#34;malloc(): corrupted unsorted chunks&#34;</span>);
</span></span><span style=display:flex><span>                  remainder<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> bck;
</span></span><span style=display:flex><span>                  remainder<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> fwd;
</span></span><span style=display:flex><span>                  bck<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> remainder;
</span></span><span style=display:flex><span>                  fwd<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> remainder;
</span></span><span style=display:flex><span>                  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>in_smallbin_range (remainder_size))
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                      remainder<span style=color:#666>-&gt;</span>fd_nextsize <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>                      remainder<span style=color:#666>-&gt;</span>bk_nextsize <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                  set_head (victim, nb <span style=color:#666>|</span> PREV_INUSE <span style=color:#666>|</span>
</span></span><span style=display:flex><span>                            (av <span style=color:#666>!=</span> <span style=color:#666>&amp;</span>main_arena <span style=color:#666>?</span> <span style=color:#002070;font-weight:700>NON_MAIN_ARENA</span> : <span style=color:#40a070>0</span>));
</span></span><span style=display:flex><span>                  set_head (remainder, remainder_size <span style=color:#666>|</span> PREV_INUSE);
</span></span><span style=display:flex><span>                  set_foot (remainder, remainder_size);
</span></span><span style=display:flex><span>                }
</span></span></code></pre></div><p>如果切割后的 chunk 的大小可以自成一个 chunk，那么就在切割后分配，注意这是我们第二次碰到 ptmalloc 的非 exact-fit 分配。由于此时 unsorted bin 可能是非空的，所以需要做一次完全的插入，插入到 unsorted bin 的链表头上。同时如果剩下的 chunk 仍然是 largebin chunk，那么就需要将 skip 链表相关的指针置 NULL。然后通过 set_head 和 set_foot 进行切割。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>              check_malloced_chunk (av, victim, nb);
</span></span><span style=display:flex><span>              <span style=color:#902000>void</span> <span style=color:#666>*</span>p <span style=color:#666>=</span> chunk2mem (victim);
</span></span><span style=display:flex><span>              alloc_perturb (p, bytes);
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>return</span> p;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>执行到这里，就是从 largebin list 中得到了 chunk，返回给用户，结束流程。</p><hr><h3 id=基于-binmap-的再一次扫描>基于 binmap 的再一次扫描</h3><p>如果之前的分配都失败了，即 exact-fit（smallbin）和 best-fit（largebin）的隔离链表都无法提供 chunk，分配器并不会死心，它仍然会尝试从对应的 size 更大的隔离链表中找最优的 chunk 来分配。注意这里说的最优不是</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>      <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         Search for a chunk by scanning bins, starting with next largest
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         bin. This search is strictly by best-fit; i.e., the smallest
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         (with ties going to approximately the least recently used) chunk
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         that fits is selected.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         The bitmap avoids needing to check that most blocks are nonempty.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         The particular case of skipping all bins during warm-up phases
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         when no chunks have been returned yet is faster than it might look.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>       */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#666>++</span>idx;
</span></span><span style=display:flex><span>      bin <span style=color:#666>=</span> bin_at (av, idx);
</span></span><span style=display:flex><span>      block <span style=color:#666>=</span> idx2block (idx);
</span></span><span style=display:flex><span>      map <span style=color:#666>=</span> av<span style=color:#666>-&gt;</span>binmap[block];
</span></span><span style=display:flex><span>      bit <span style=color:#666>=</span> idx2bit (idx);
</span></span></code></pre></div><p>首先增加 idx，然后获取 idx 对应的链表表头，并获取 idx 对应的 binmap 的 block 的下标和 bit 所处的位置，同时将整个 block 赋值给 map。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>      <span style=color:#007020;font-weight:700>for</span> (;; )
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#60a0b0;font-style:italic>/* Skip rest of block if there are no more set bits in this block.  */</span>
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (bit <span style=color:#666>&gt;</span> map <span style=color:#666>||</span> bit <span style=color:#666>==</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>do</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>++</span>block <span style=color:#666>&gt;=</span> BINMAPSIZE) <span style=color:#60a0b0;font-style:italic>/* out of bins */</span>
</span></span><span style=display:flex><span>                    <span style=color:#007020;font-weight:700>goto</span> use_top;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>while</span> ((map <span style=color:#666>=</span> av<span style=color:#666>-&gt;</span>binmap[block]) <span style=color:#666>==</span> <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              bin <span style=color:#666>=</span> bin_at (av, (block <span style=color:#666>&lt;&lt;</span> BINMAPSHIFT));
</span></span><span style=display:flex><span>              bit <span style=color:#666>=</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>            }
</span></span></code></pre></div><p>然后进行处理，如果 <code>bit > map || bit == 0</code>，说明整个 block 中都没有大于申请的大小 bin 中有 chunk。这个时候尝试从下一个 block 中寻找 bin，这里使用 while 循环找到第一个不为 0 的 block，如果找到了这个 block 中必然有可以分配的隔离链表不为空，这个时候结束循环准备进行切割分配；如果扫完了所有的 block 都没有可以分配的链表，直接 goto 到 <code>use_top</code> 上去，准备使用 top_chunk 分配（这里可以看出 goto 也不是永远不能用的，有些时候还是有使用的意义的——如此处的跳出多重循环）。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>          <span style=color:#60a0b0;font-style:italic>/* Advance to bin with set bit. There must be one. */</span>
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>while</span> ((bit <span style=color:#666>&amp;</span> map) <span style=color:#666>==</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              bin <span style=color:#666>=</span> next_bin (bin);
</span></span><span style=display:flex><span>              bit <span style=color:#666>&lt;&lt;=</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>              assert (bit <span style=color:#666>!=</span> <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>            }
</span></span></code></pre></div><p>执行到这里说明有一个链表中有 best-fit，这里通过循环找到一个不为空的、best-fit 的链表，这里有一个断言，代表 bit 不可能溢出，即一定能找到一个 best-fit 的链表。当 <code>(bit & map) == 1</code> 时退出循环，表示找到了需要的链表。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>          <span style=color:#60a0b0;font-style:italic>/* Inspect the bin. It is likely to be non-empty */</span>
</span></span><span style=display:flex><span>          victim <span style=color:#666>=</span> last (bin);
</span></span></code></pre></div><p>将链表中的最后一个 chunk（链表中最小的 chunk）作为候选 chunk。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>          <span style=color:#60a0b0;font-style:italic>/*  If a false alarm (empty bin), clear the bit. */</span>
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (victim <span style=color:#666>==</span> bin)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              av<span style=color:#666>-&gt;</span>binmap[block] <span style=color:#666>=</span> map <span style=color:#666>&amp;=</span> <span style=color:#666>~</span>bit; <span style=color:#60a0b0;font-style:italic>/* Write through */</span>
</span></span><span style=display:flex><span>              bin <span style=color:#666>=</span> next_bin (bin);
</span></span><span style=display:flex><span>              bit <span style=color:#666>&lt;&lt;=</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>            }
</span></span></code></pre></div><p>然后检测找到的链表是否真的不是空的。由于 binmap 的更新不是立刻的，所以可能会出现 binmap 不准确的情况，这时就需要更新 binmap，即将对应的 bit 更新，获取当前 bin 的下一个 bin，并将 bit 移到高一位，即乘二。</p><p>如果链表的却非空，那么就可以进行 best-fit 分配，这里的实现和之前 largebin 中的 best-fit 分配是一致的。如下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>          <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              size <span style=color:#666>=</span> chunksize (victim);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#60a0b0;font-style:italic>/*  We know the first chunk in this bin is big enough to use. */</span>
</span></span><span style=display:flex><span>              assert ((<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (size) <span style=color:#666>&gt;=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (nb));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              remainder_size <span style=color:#666>=</span> size <span style=color:#666>-</span> nb;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#60a0b0;font-style:italic>/* unlink */</span>
</span></span><span style=display:flex><span>              unlink_chunk (av, victim);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#60a0b0;font-style:italic>/* Exhaust */</span>
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>if</span> (remainder_size <span style=color:#666>&lt;</span> MINSIZE)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                  set_inuse_bit_at_offset (victim, size);
</span></span><span style=display:flex><span>                  <span style=color:#007020;font-weight:700>if</span> (av <span style=color:#666>!=</span> <span style=color:#666>&amp;</span>main_arena)
</span></span><span style=display:flex><span>		    set_non_main_arena (victim);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#60a0b0;font-style:italic>/* Split */</span>
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                  remainder <span style=color:#666>=</span> chunk_at_offset (victim, nb);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                  <span style=color:#60a0b0;font-style:italic>/* We cannot assume the unsorted list is empty and therefore
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>                     have to perform a complete insert here.  */</span>
</span></span><span style=display:flex><span>                  bck <span style=color:#666>=</span> unsorted_chunks (av);
</span></span><span style=display:flex><span>                  fwd <span style=color:#666>=</span> bck<span style=color:#666>-&gt;</span>fd;
</span></span><span style=display:flex><span>		  <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (fwd<span style=color:#666>-&gt;</span>bk <span style=color:#666>!=</span> bck))
</span></span><span style=display:flex><span>		    malloc_printerr (<span style=color:#4070a0>&#34;malloc(): corrupted unsorted chunks 2&#34;</span>);
</span></span><span style=display:flex><span>                  remainder<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> bck;
</span></span><span style=display:flex><span>                  remainder<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> fwd;
</span></span><span style=display:flex><span>                  bck<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> remainder;
</span></span><span style=display:flex><span>                  fwd<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> remainder;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                  <span style=color:#60a0b0;font-style:italic>/* advertise as last remainder */</span>
</span></span><span style=display:flex><span>                  <span style=color:#007020;font-weight:700>if</span> (in_smallbin_range (nb))
</span></span><span style=display:flex><span>                    av<span style=color:#666>-&gt;</span>last_remainder <span style=color:#666>=</span> remainder;
</span></span><span style=display:flex><span>                  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>in_smallbin_range (remainder_size))
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                      remainder<span style=color:#666>-&gt;</span>fd_nextsize <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>                      remainder<span style=color:#666>-&gt;</span>bk_nextsize <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                  set_head (victim, nb <span style=color:#666>|</span> PREV_INUSE <span style=color:#666>|</span>
</span></span><span style=display:flex><span>                            (av <span style=color:#666>!=</span> <span style=color:#666>&amp;</span>main_arena <span style=color:#666>?</span> <span style=color:#002070;font-weight:700>NON_MAIN_ARENA</span> : <span style=color:#40a070>0</span>));
</span></span><span style=display:flex><span>                  set_head (remainder, remainder_size <span style=color:#666>|</span> PREV_INUSE);
</span></span><span style=display:flex><span>                  set_foot (remainder, remainder_size);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>              check_malloced_chunk (av, victim, nb);
</span></span><span style=display:flex><span>              <span style=color:#902000>void</span> <span style=color:#666>*</span>p <span style=color:#666>=</span> chunk2mem (victim);
</span></span><span style=display:flex><span>              alloc_perturb (p, bytes);
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>return</span> p;
</span></span><span style=display:flex><span>            }
</span></span></code></pre></div><p>这里就不再赘述了。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>        }
</span></span></code></pre></div><p>binmap 处理的外层套了一个 <code>for (;; )</code> 的大循环，这是为了处理 false alarm 即 binmap 出错的而设置的，出错后将 bit 左移，重新进行一次搜索分配，直到完成分配或者 goto 到 use_top 上。这里会对 binmap 进行一定的纠错。</p><h3 id=use_top>use_top</h3><p>终于到了使用 top_chunk 分配了，这也代表 _int_malloc 的尾声。当各个隔离链表中都无法提供合适的 chunk，或者申请的空间非常大，就会尝试从 top_chunk 中切割分配。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#002070;font-weight:700>use_top</span>:
</span></span><span style=display:flex><span>      <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         If large enough, split off the chunk bordering the end of memory
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         (held in av-&gt;top). Note that this is in accord with the best-fit
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         search rule.  In effect, av-&gt;top is treated as larger (and thus
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         less well fitting) than any other available chunk since it can
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         be extended to be as large as necessary (up to system
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         limitations).
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         We require that av-&gt;top always exists (i.e., has size &gt;=
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         MINSIZE) after initialization, so if it would otherwise be
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         exhausted by current request, it is replenished. (The main
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         reason for ensuring it exists is that we may need MINSIZE space
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         to put in fenceposts in sysmalloc.)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>       */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      victim <span style=color:#666>=</span> av<span style=color:#666>-&gt;</span>top;
</span></span><span style=display:flex><span>      size <span style=color:#666>=</span> chunksize (victim);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (size <span style=color:#666>&gt;</span> av<span style=color:#666>-&gt;</span>system_mem))
</span></span><span style=display:flex><span>        malloc_printerr (<span style=color:#4070a0>&#34;malloc(): corrupted top size&#34;</span>);
</span></span></code></pre></div><p>首先把当前分配区的 top_chunk 的地址赋值给 victim，设之为候选 chunk。记录 top_chunk 的大小，并检测其合法性，及 top_chunk 的大小不得超过 <code>av->system_mem</code>（经过调试，在我的电脑上这个值是 0x21000），该检测的存在使 house of force 攻击在 libc 2.29 之后失效。</p><h4 id=切割分配-1>切割分配</h4><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> ((<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (size) <span style=color:#666>&gt;=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (nb <span style=color:#666>+</span> MINSIZE))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          remainder_size <span style=color:#666>=</span> size <span style=color:#666>-</span> nb;
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// /* Treat space at ptr + offset as a chunk */
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// #define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>          remainder <span style=color:#666>=</span> chunk_at_offset (victim, nb);
</span></span><span style=display:flex><span>          av<span style=color:#666>-&gt;</span>top <span style=color:#666>=</span> remainder;
</span></span><span style=display:flex><span>          set_head (victim, nb <span style=color:#666>|</span> PREV_INUSE <span style=color:#666>|</span>
</span></span><span style=display:flex><span>                    (av <span style=color:#666>!=</span> <span style=color:#666>&amp;</span>main_arena <span style=color:#666>?</span> <span style=color:#002070;font-weight:700>NON_MAIN_ARENA</span> : <span style=color:#40a070>0</span>));
</span></span><span style=display:flex><span>          set_head (remainder, remainder_size <span style=color:#666>|</span> PREV_INUSE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          check_malloced_chunk (av, victim, nb);
</span></span><span style=display:flex><span>          <span style=color:#902000>void</span> <span style=color:#666>*</span>p <span style=color:#666>=</span> chunk2mem (victim);
</span></span><span style=display:flex><span>          alloc_perturb (p, bytes);
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>return</span> p;
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>如果 top_chunk 在被切割后仍然可以存留大于 MINSIZE 的大小，那么就进行切割分配。保留的不小于 MINSIZE 大小的空间是做 fencepost 的。分配的流程比较简单，把新的 top_chunk 设置为 remainder 然后设置将要返回的 chunk 和新的 top_chunk 的 size 字段。由于 top_chunk 的尾部仍然做 fencepost，所以这里不需要 set_foot。然后就可以返回给用户了。</p><p><em>关于 fencepost：这似乎是用在 sub_heap 上的一个栅栏，用于各个分配区的区分，主分配区的 fencepost 段上都为 0。具体笔者也不是很了解</em></p><h4 id=第二次-malloc_consolidate>第二次 malloc_consolidate</h4><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>      <span style=color:#60a0b0;font-style:italic>/* When we are using atomic ops to free fast chunks we can get
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         here for all block sizes.  */</span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>else</span> <span style=color:#06287e>if</span> (atomic_load_relaxed (<span style=color:#666>&amp;</span>av<span style=color:#666>-&gt;</span>have_fastchunks))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          malloc_consolidate (av);
</span></span><span style=display:flex><span>          <span style=color:#60a0b0;font-style:italic>/* restore original bin index */</span>
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (in_smallbin_range (nb))
</span></span><span style=display:flex><span>            idx <span style=color:#666>=</span> smallbin_index (nb);
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>            idx <span style=color:#666>=</span> largebin_index (nb);
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>然后在这里会再进行一次 malloc_consolidate。如果是 large request，虽然之前清理过了一次 fastbin，但由于 free fastbin 是不需要加锁的，所以在之前的处理过程中仍然可能会有别的线程 free fastbin 导致 fastbin 中又出现 chunk；如果是 small request，之前没有做过 malloc_consolidate，这里 fastbin 中很可能有非 exact-fit 的 chunk。</p><p>当分配区中有 fastchunks 时，调用 malloc_consolidate，取出所有的 fastchunk，更新 idx 后结束这个 if。还记得套在 unsorted bin 遍历前的大循环嘛</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     Process recently freed or remaindered chunks, taking one only if
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     it is exact fit, or, if this a small request, the chunk is remainder from
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     the most recent non-exact fit.  Place other traversed chunks in
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     bins.  Note that this step is the only place in any routine where
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     chunks are placed in bins.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     The outer loop here is needed because we might not realize until
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     near the end of malloc that we should have consolidated, so must
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     do so and retry. This happens at most once, and only when we would
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     otherwise need to expand memory to service a &#34;small&#34; request.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020>#if USE_TCACHE
</span></span></span><span style=display:flex><span><span style=color:#007020></span>  INTERNAL_SIZE_T tcache_nb <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  size_t tc_idx <span style=color:#666>=</span> csize2tidx (nb);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (tcache <span style=color:#666>&amp;&amp;</span> tc_idx <span style=color:#666>&lt;</span> mp_.tcache_bins)
</span></span><span style=display:flex><span>    tcache_nb <span style=color:#666>=</span> nb;
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> return_cached <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  tcache_unsorted_count <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>for</span> (;; )
</span></span><span style=display:flex><span>    {
</span></span></code></pre></div><p>结束这个 if 后就会触发这个循环，回到之前对 unsorted bin 的遍历上，正如注释所说，再一次 malloc_consolidate 后，unsorted bin 中又会增加 chunk，说不定这些 chunk 就可以满足 request 了，说不定就可以不用调用 sysmalloc 分配了（sysmalloc 需要进行系统调用来分配空间，会慢许多）。</p><p><em>其实在老版本中这里有区分是否开启 ATOMIC_FASTBINS 优化并做了不同处理，新版本把两者和到了一起</em></p><h4 id=sysmalloc>sysmalloc</h4><p>执行到这里了，那是真的没办法了，必须使用 sysmalloc 来分配了。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>      <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         Otherwise, relay to handle system-dependent cases
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>       */</span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#902000>void</span> <span style=color:#666>*</span>p <span style=color:#666>=</span> sysmalloc (nb, av);
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (p <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>            alloc_perturb (p, bytes);
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>return</span> p;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用 sysmalloc 申请成功后，返回给用户，_int_malloc 正式结束。</p><p>至此，malloc 分析结束。</p><h1 id=free>free</h1><p>free 的代码要比 malloc 短一点。</p><h2 id=__libc_free>__libc_free</h2><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>void</span>
</span></span><span style=display:flex><span><span style=color:#06287e>__libc_free</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>mem)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  mstate ar_ptr;
</span></span><span style=display:flex><span>  mchunkptr p;                          <span style=color:#60a0b0;font-style:italic>/* chunk corresponding to mem */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#902000>void</span> (<span style=color:#666>*</span>hook) (<span style=color:#902000>void</span> <span style=color:#666>*</span>, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>void</span> <span style=color:#666>*</span>)
</span></span><span style=display:flex><span>    <span style=color:#666>=</span> atomic_forced_read (__free_hook);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (__builtin_expect (hook <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>, <span style=color:#40a070>0</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      (<span style=color:#666>*</span>hook)(mem, RETURN_ADDRESS (<span style=color:#40a070>0</span>));
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (mem <span style=color:#666>==</span> <span style=color:#40a070>0</span>)                              <span style=color:#60a0b0;font-style:italic>/* free(0) has no effect */</span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020>#ifdef USE_MTAG
</span></span></span><span style=display:flex><span><span style=color:#007020></span>  <span style=color:#60a0b0;font-style:italic>/* Quickly check that the freed pointer matches the tag for the memory.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     This gives a useful double-free detection.  */</span>
</span></span><span style=display:flex><span>  <span style=color:#666>*</span>(<span style=color:#007020;font-weight:700>volatile</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>)mem;
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> err <span style=color:#666>=</span> errno;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  p <span style=color:#666>=</span> mem2chunk (mem);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/* Mark the chunk as belonging to the library again.  */</span>
</span></span><span style=display:flex><span>  (<span style=color:#902000>void</span>)TAG_REGION (chunk2rawmem (p), CHUNK_AVAILABLE_SIZE (p) <span style=color:#666>-</span> CHUNK_HDR_SZ);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (chunk_is_mmapped (p))                       <span style=color:#60a0b0;font-style:italic>/* release mmapped memory. */</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#60a0b0;font-style:italic>/* See if the dynamic brk/mmap threshold needs adjusting.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 Dumped fake mmapped chunks do not affect the threshold.  */</span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>mp_.no_dyn_threshold
</span></span><span style=display:flex><span>          <span style=color:#666>&amp;&amp;</span> chunksize_nomask (p) <span style=color:#666>&gt;</span> mp_.mmap_threshold
</span></span><span style=display:flex><span>          <span style=color:#666>&amp;&amp;</span> chunksize_nomask (p) <span style=color:#666>&lt;=</span> DEFAULT_MMAP_THRESHOLD_MAX
</span></span><span style=display:flex><span>	  <span style=color:#666>&amp;&amp;</span> <span style=color:#666>!</span>DUMPED_MAIN_ARENA_CHUNK (p))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          mp_.mmap_threshold <span style=color:#666>=</span> chunksize (p);
</span></span><span style=display:flex><span>          mp_.trim_threshold <span style=color:#666>=</span> <span style=color:#40a070>2</span> <span style=color:#666>*</span> mp_.mmap_threshold;
</span></span><span style=display:flex><span>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span style=color:#40a070>2</span>,
</span></span><span style=display:flex><span>                      mp_.mmap_threshold, mp_.trim_threshold);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      munmap_chunk (p);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      MAYBE_INIT_TCACHE ();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      ar_ptr <span style=color:#666>=</span> arena_for_chunk (p);
</span></span><span style=display:flex><span>      _int_free (ar_ptr, p, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  __set_errno (err);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>libc_hidden_def (__libc_free)
</span></span></code></pre></div><p>类似于 malloc，glibc 也把 __libc_free 作为 free 的别名，我们在调用 free 的时候实际会调用 __libc_free。</p><p>我们分段来看</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>void</span>
</span></span><span style=display:flex><span><span style=color:#06287e>__libc_free</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>mem)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  mstate ar_ptr;
</span></span><span style=display:flex><span>  mchunkptr p;                          <span style=color:#60a0b0;font-style:italic>/* chunk corresponding to mem */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#902000>void</span> (<span style=color:#666>*</span>hook) (<span style=color:#902000>void</span> <span style=color:#666>*</span>, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>void</span> <span style=color:#666>*</span>)
</span></span><span style=display:flex><span>    <span style=color:#666>=</span> atomic_forced_read (__free_hook);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (__builtin_expect (hook <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>, <span style=color:#40a070>0</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      (<span style=color:#666>*</span>hook)(mem, RETURN_ADDRESS (<span style=color:#40a070>0</span>));
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (mem <span style=color:#666>==</span> <span style=color:#40a070>0</span>)                              <span style=color:#60a0b0;font-style:italic>/* free(0) has no effect */</span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span>;
</span></span></code></pre></div><p>最开始先定义 ar_ptr 和 p 两变量，前者在未来指向当前分配区的 mstate，后者则在未来指向传入的 mem 对应的内部 chunk 地址。</p><p>程序一开始做两个特判</p><ol><li>先用原子操作把 __free_hook 中的值读出来并判断值是否为 NULL，若不为 NULL 直接执行 __free_hook 指向的函数。__free_hook 不为零主要有两种情况，一是处理线程新建时的操作，另一种是使用用户提供的 free 函数。</li><li>判断被 free 的指针是否为 NULL，如果是直接返回。</li></ol><p>两者都通过后继续之后的流程。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#ifdef USE_MTAG
</span></span></span><span style=display:flex><span><span style=color:#007020></span>  <span style=color:#60a0b0;font-style:italic>/* Quickly check that the freed pointer matches the tag for the memory.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     This gives a useful double-free detection.  */</span>
</span></span><span style=display:flex><span>  <span style=color:#666>*</span>(<span style=color:#007020;font-weight:700>volatile</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>)mem;
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span></code></pre></div><p>然后是 2.33 新增加的对 double-free 的检测，MTAG 这个东西，和下面的 TAG_REGION 是一套的，这个还不是很了解，以后再说。</p><p>然后是一些初试化</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#902000>int</span> err <span style=color:#666>=</span> errno;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  p <span style=color:#666>=</span> mem2chunk (mem);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/* Mark the chunk as belonging to the library again.  */</span>
</span></span><span style=display:flex><span>  (<span style=color:#902000>void</span>)TAG_REGION (chunk2rawmem (p), CHUNK_AVAILABLE_SIZE (p) <span style=color:#666>-</span> CHUNK_HDR_SZ);
</span></span></code></pre></div><p>这里的 TAG_REGION 也是在 2.33 才加入的，是对 chunk 的染色操作（tagging,sometimes know as coloring），具体干啥的我也不太清楚，暂且放过。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (chunk_is_mmapped (p))                       <span style=color:#60a0b0;font-style:italic>/* release mmapped memory. */</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#60a0b0;font-style:italic>/* See if the dynamic brk/mmap threshold needs adjusting.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 Dumped fake mmapped chunks do not affect the threshold.  */</span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>mp_.no_dyn_threshold
</span></span><span style=display:flex><span>          <span style=color:#666>&amp;&amp;</span> chunksize_nomask (p) <span style=color:#666>&gt;</span> mp_.mmap_threshold
</span></span><span style=display:flex><span>          <span style=color:#666>&amp;&amp;</span> chunksize_nomask (p) <span style=color:#666>&lt;=</span> DEFAULT_MMAP_THRESHOLD_MAX
</span></span><span style=display:flex><span>	  <span style=color:#666>&amp;&amp;</span> <span style=color:#666>!</span>DUMPED_MAIN_ARENA_CHUNK (p))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          mp_.mmap_threshold <span style=color:#666>=</span> chunksize (p);
</span></span><span style=display:flex><span>          mp_.trim_threshold <span style=color:#666>=</span> <span style=color:#40a070>2</span> <span style=color:#666>*</span> mp_.mmap_threshold;
</span></span><span style=display:flex><span>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span style=color:#40a070>2</span>,
</span></span><span style=display:flex><span>                      mp_.mmap_threshold, mp_.trim_threshold);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      munmap_chunk (p);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>然后是对 chunk 为 mmapped 的情况时的处理，由于我还没有研究过 sys_malloc，所以这里也暂时跳过。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      MAYBE_INIT_TCACHE ();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      ar_ptr <span style=color:#666>=</span> arena_for_chunk (p);
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>//#define heap_for_ptr(ptr) \
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>//  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>//#define arena_for_chunk(ptr) \
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>//  (chunk_main_arena (ptr) ? &amp;main_arena : heap_for_ptr (ptr)-&gt;ar_ptr)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>      _int_free (ar_ptr, p, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>__set_errno (err);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>libc_hidden_def (__libc_free)
</span></span></code></pre></div><p>然后是对 tcache 进行可能需要的初试化，即执行 <code>MAYBE_INIT_TCACHE ()</code>，这个在分析 malloc 是已经分析过了，这里不多说，总的就是分配了 tcache_perthread_struct 结构体然后清零。然后获取 chunk 所处的分配区，存储于 ar_ptr 中，调用 <code>_int_free()</code> 来进行 free 操作。</p><p>可见 __libc_free 仅处理了 mmaped 的内存，其余的都交给 _int_free 了。</p><h2 id=_int_free>_int_free</h2><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>void</span>
</span></span><span style=display:flex><span><span style=color:#06287e>_int_free</span> (mstate av, mchunkptr p, <span style=color:#902000>int</span> have_lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  INTERNAL_SIZE_T size;        <span style=color:#60a0b0;font-style:italic>/* its size */</span>
</span></span><span style=display:flex><span>  mfastbinptr <span style=color:#666>*</span>fb;             <span style=color:#60a0b0;font-style:italic>/* associated fastbin */</span>
</span></span><span style=display:flex><span>  mchunkptr nextchunk;         <span style=color:#60a0b0;font-style:italic>/* next contiguous chunk */</span>
</span></span><span style=display:flex><span>  INTERNAL_SIZE_T nextsize;    <span style=color:#60a0b0;font-style:italic>/* its size */</span>
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> nextinuse;               <span style=color:#60a0b0;font-style:italic>/* true if nextchunk is used */</span>
</span></span><span style=display:flex><span>  INTERNAL_SIZE_T prevsize;    <span style=color:#60a0b0;font-style:italic>/* size of previous contiguous chunk */</span>
</span></span><span style=display:flex><span>  mchunkptr bck;               <span style=color:#60a0b0;font-style:italic>/* misc temp for linking */</span>
</span></span><span style=display:flex><span>  mchunkptr fwd;               <span style=color:#60a0b0;font-style:italic>/* misc temp for linking */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  size <span style=color:#666>=</span> chunksize (p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/* Little security check which won&#39;t hurt performance: the
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     allocator never wrapps around at the end of the address space.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     Therefore we can exclude some size values which might appear
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     here by accident or by &#34;design&#34; from some intruder.  */</span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (__builtin_expect ((uintptr_t) p <span style=color:#666>&gt;</span> (uintptr_t) <span style=color:#666>-</span>size, <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>      <span style=color:#666>||</span> __builtin_expect (misaligned_chunk (p), <span style=color:#40a070>0</span>))
</span></span><span style=display:flex><span>    malloc_printerr (<span style=color:#4070a0>&#34;free(): invalid pointer&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/* We know that each chunk is at least MINSIZE bytes in size or a
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     multiple of MALLOC_ALIGNMENT.  */</span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (size <span style=color:#666>&lt;</span> MINSIZE <span style=color:#666>||</span> <span style=color:#666>!</span>aligned_OK (size)))
</span></span><span style=display:flex><span>    malloc_printerr (<span style=color:#4070a0>&#34;free(): invalid size&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  check_inuse_chunk(av, p); <span style=color:#60a0b0;font-style:italic>// debug
</span></span></span></code></pre></div><p>进入函数首先对应了一些变量供之后的操作使用，然后进行两个轻量级的检测，都是检测 size 字段的合法性</p><h3 id=free-to-tcache>free to tcache</h3><p>然后进入 tcache 分支，首先取得当前 chunk 所对应的 tc_idx，然后仅在 tcache 非空且当前 chunk 的大小在 tcache 范围内才会进入处理（显然的）</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#if USE_TCACHE
</span></span></span><span style=display:flex><span><span style=color:#007020></span>  {
</span></span><span style=display:flex><span>    size_t tc_idx <span style=color:#666>=</span> csize2tidx (size);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (tcache <span style=color:#666>!=</span> <span style=color:#007020>NULL</span> <span style=color:#666>&amp;&amp;</span> tc_idx <span style=color:#666>&lt;</span> mp_.tcache_bins)
</span></span><span style=display:flex><span>      {
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* Check to see if it&#39;s already in the tcache.  */</span>
</span></span><span style=display:flex><span>	tcache_entry <span style=color:#666>*</span>e <span style=color:#666>=</span> (tcache_entry <span style=color:#666>*</span>) chunk2mem (p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* This test succeeds on double free.  However, we don&#39;t 100%
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	   trust it (it also matches random payload data at a 1 in
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	   2^&lt;size_t&gt; chance), so verify it&#39;s not an unlikely
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	   coincidence before aborting.  */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (e<span style=color:#666>-&gt;</span>key <span style=color:#666>==</span> tcache))
</span></span><span style=display:flex><span>	  {
</span></span><span style=display:flex><span>	    tcache_entry <span style=color:#666>*</span>tmp;
</span></span><span style=display:flex><span>	    size_t cnt <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	    LIBC_PROBE (memory_tcache_double_free, <span style=color:#40a070>2</span>, e, tc_idx);
</span></span><span style=display:flex><span>	    <span style=color:#007020;font-weight:700>for</span> (tmp <span style=color:#666>=</span> tcache<span style=color:#666>-&gt;</span>entries[tc_idx];
</span></span><span style=display:flex><span>		 tmp;
</span></span><span style=display:flex><span>		 tmp <span style=color:#666>=</span> REVEAL_PTR (tmp<span style=color:#666>-&gt;</span>next), <span style=color:#666>++</span>cnt)
</span></span><span style=display:flex><span>	      {
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (cnt <span style=color:#666>&gt;=</span> mp_.tcache_count)
</span></span><span style=display:flex><span>		  malloc_printerr (<span style=color:#4070a0>&#34;free(): too many chunks detected in tcache&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (<span style=color:#666>!</span>aligned_OK (tmp)))
</span></span><span style=display:flex><span>		  malloc_printerr (<span style=color:#4070a0>&#34;free(): unaligned chunk detected in tcache 2&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (tmp <span style=color:#666>==</span> e)
</span></span><span style=display:flex><span>		  malloc_printerr (<span style=color:#4070a0>&#34;free(): double free detected in tcache 2&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#60a0b0;font-style:italic>/* If we get here, it was a coincidence.  We&#39;ve wasted a
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		   few cycles, but don&#39;t abort.  */</span>
</span></span><span style=display:flex><span>	      }
</span></span><span style=display:flex><span>	  }
</span></span></code></pre></div><p>然后是 glibc 在 libc-2.27 之后加入的 tcache double free 的检测，首先取得当前 chunk 在 tcache 下的地址（即指向 payload），然后查看该 chunk 的 key 字段（即普通 chunk 的 bk 字段）是否和 tcache 的地址相同，如果相同，基本上可以认为是 double free 了，因为在 tcache_put（把 chunk 放到 tcache 中）中会把 tcache_chunk 的 key 字段写上 tcache 的地址，而 tcache_get（把 chunk 从 tcache 中取出）的时候会把这个字段置 NULL，也就是说一个 tcache_chunk 被 free 掉后 key <strong>才会</strong>指向 tcache。</p><p>但是由于用户数据有概率恰好和 tcache 的地址相等，所以这里不直接报错，而是遍历一遍 tcache->entries[tc_idx] 链表，如果在遍历过程中发现遍历的次数超过了 tcache 的上限、有 chunk 没有对齐或的确在 链表中找到这个 chunk，就会报对应的错误。</p><p>如果通过以上检测，就通过 tcache_put 来把 chunk 放入 tcache 中。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (tcache<span style=color:#666>-&gt;</span>counts[tc_idx] <span style=color:#666>&lt;</span> mp_.tcache_count)
</span></span><span style=display:flex><span>	  {
</span></span><span style=display:flex><span>	    tcache_put (p, tc_idx);
</span></span><span style=display:flex><span>	    <span style=color:#007020;font-weight:700>return</span>;
</span></span><span style=display:flex><span>	  }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span></code></pre></div><h4 id=tcache_put>tcache_put</h4><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> __always_inline <span style=color:#902000>void</span>
</span></span><span style=display:flex><span><span style=color:#06287e>tcache_put</span> (mchunkptr chunk, size_t tc_idx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  tcache_entry <span style=color:#666>*</span>e <span style=color:#666>=</span> (tcache_entry <span style=color:#666>*</span>) chunk2mem (chunk);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/* Mark this chunk as &#34;in the tcache&#34; so the test in _int_free will
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     detect a double free.  */</span>
</span></span><span style=display:flex><span>  e<span style=color:#666>-&gt;</span>key <span style=color:#666>=</span> tcache;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  e<span style=color:#666>-&gt;</span>next <span style=color:#666>=</span> PROTECT_PTR (<span style=color:#666>&amp;</span>e<span style=color:#666>-&gt;</span>next, tcache<span style=color:#666>-&gt;</span>entries[tc_idx]);
</span></span><span style=display:flex><span>  tcache<span style=color:#666>-&gt;</span>entries[tc_idx] <span style=color:#666>=</span> e;
</span></span><span style=display:flex><span>  <span style=color:#666>++</span>(tcache<span style=color:#666>-&gt;</span>counts[tc_idx]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里的实现还是比较好理解的，可以注意到这里把 chunk 的 key 字段置为了 tcache 的地址。</p><p><strong>注意！在 free 到 tcache 的整个过程都没有对下一个 chunk 的 prev_inuse 位进行修改，而是默认该位一定是 1。特别的，也没有对该位进行检测，这为一些 off-by-one 攻击提供了便利</strong></p><h3 id=free-to-fastbin>free to fastbin</h3><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> ((<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>)(size) <span style=color:#666>&lt;=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>)(get_max_fast ())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020>#if TRIM_FASTBINS
</span></span></span><span style=display:flex><span><span style=color:#007020></span>      <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	If TRIM_FASTBINS set, don&#39;t place chunks
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	bordering top into fastbins
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>      */</span>
</span></span><span style=display:flex><span>      <span style=color:#666>&amp;&amp;</span> (chunk_at_offset(p, size) <span style=color:#666>!=</span> av<span style=color:#666>-&gt;</span>top)
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020></span>      ) {
</span></span></code></pre></div><p>如果 chunk 的 size 属于 fastbin 的范围，并且无法 free 到 tcache 中，就尝试把它 free 到 fastbin 里面。如果开启了 TRIM_FASTBINS 选项，还会判断 chunk 是否和 top_chunk 相邻，只有不相邻才会 free 到 fastbin 中，不过该选项默认关闭，也就是 free fastbin chunk 默认情况下不会和 top_chunk 合并。此流程如下</p><h4 id=合法性检查>合法性检查</h4><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))
</span></span><span style=display:flex><span>			  <span style=color:#666>&lt;=</span> CHUNK_HDR_SZ, <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#666>||</span> __builtin_expect (chunksize (chunk_at_offset (p, size))
</span></span><span style=display:flex><span>			     <span style=color:#666>&gt;=</span> av<span style=color:#666>-&gt;</span>system_mem, <span style=color:#40a070>0</span>))
</span></span></code></pre></div><p>首先进行两个合法性检查</p><ul><li>检查下一个 chunk 的大小是否小于等于 CHUNK_HDR_SZ（即 2 * SIZE_SZ）。小于表示下一个 chunk 的大小不合法，等于表示下一个 chunk 的 prev_inuse 位为 0，有 double free。</li><li>检查下一个 chunk 是否过大，av->system_mem 代表现在已分配的内存，如果下一个 chunk 的大小大于这个，不用说，肯定不合法。</li></ul><p>如果上两个检查未通过，则进行第二次检测</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>	<span style=color:#902000>bool</span> fail <span style=color:#666>=</span> <span style=color:#007020>true</span>;
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* We might not have a lock at this point and concurrent modifications
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	   of system_mem might result in a false positive.  Redo the test after
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	   getting the lock.  */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>have_lock)
</span></span><span style=display:flex><span>	  {
</span></span><span style=display:flex><span>	    __libc_lock_lock (av<span style=color:#666>-&gt;</span>mutex);
</span></span><span style=display:flex><span>	    fail <span style=color:#666>=</span> (chunksize_nomask (chunk_at_offset (p, size)) <span style=color:#666>&lt;=</span> CHUNK_HDR_SZ
</span></span><span style=display:flex><span>		    <span style=color:#666>||</span> chunksize (chunk_at_offset (p, size)) <span style=color:#666>&gt;=</span> av<span style=color:#666>-&gt;</span>system_mem);
</span></span><span style=display:flex><span>	    __libc_lock_unlock (av<span style=color:#666>-&gt;</span>mutex);
</span></span><span style=display:flex><span>	  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (fail)
</span></span><span style=display:flex><span>	  malloc_printerr (<span style=color:#4070a0>&#34;free(): invalid next size (fast)&#34;</span>);
</span></span><span style=display:flex><span>      }
</span></span></code></pre></div><p>have_lock 为传入的形参，传入时值为 0，那么这里会再做一次同上的合法性检查，不通过则直接报错，重复进行的原因是在并行的情况下别的线程也会对分配区进行操作，这里在加锁后再进行检测保证了正确性，检测完后解锁。通过此处的检测流程后，准备进行之后的入链。</p><h4 id=入链>入链</h4><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span>    free_perturb (chunk2mem(p), size <span style=color:#666>-</span> CHUNK_HDR_SZ);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    atomic_store_relaxed (<span style=color:#666>&amp;</span>av<span style=color:#666>-&gt;</span>have_fastchunks, <span style=color:#007020>true</span>);
</span></span><span style=display:flex><span>    <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> idx <span style=color:#666>=</span> fastbin_index(size);
</span></span><span style=display:flex><span>    fb <span style=color:#666>=</span> <span style=color:#666>&amp;</span>fastbin (av, idx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span>
</span></span><span style=display:flex><span>    mchunkptr old <span style=color:#666>=</span> <span style=color:#666>*</span>fb, old2;
</span></span></code></pre></div><p>然后进行 free_perturb，根据 perturb_byte 的值进行 memset，不过由于该变量一般情况下值都为零，所以该语句一般情况下不会起效。</p><p>然后通过原子操作设置 av->have_fastchunks 为真，表示 fastbin 中有 chunk。然后取得 chunk 的大小对应的 fastbin 链表头，并定义变量 old，old2，初始化 old 指向链表的第一个元素。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (SINGLE_THREAD_P)
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* Check that the top of the bin is not the record we are going to
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	   add (i.e., double free).  */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (__builtin_expect (old <span style=color:#666>==</span> p, <span style=color:#40a070>0</span>))
</span></span><span style=display:flex><span>	  malloc_printerr (<span style=color:#4070a0>&#34;double free or corruption (fasttop)&#34;</span>);
</span></span><span style=display:flex><span>	p<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> PROTECT_PTR (<span style=color:#666>&amp;</span>p<span style=color:#666>-&gt;</span>fd, old);
</span></span><span style=display:flex><span>	<span style=color:#666>*</span>fb <span style=color:#666>=</span> p;
</span></span><span style=display:flex><span>      }
</span></span></code></pre></div><p>然后判断线程情况，在单线程情况下，直接把被 free 的 chunk 插入到链表的头上。这里进行了较松散的 double free 检测，即链表头指向的 chunk 是否和被 free 的 chunk 为同一个 chunk。通过交叉 free 的方法仍然可以实现 double free。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>do</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	  <span style=color:#60a0b0;font-style:italic>/* Check that the top of the bin is not the record we are going to
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	     add (i.e., double free).  */</span>
</span></span><span style=display:flex><span>	  <span style=color:#007020;font-weight:700>if</span> (__builtin_expect (old <span style=color:#666>==</span> p, <span style=color:#40a070>0</span>))
</span></span><span style=display:flex><span>	    malloc_printerr (<span style=color:#4070a0>&#34;double free or corruption (fasttop)&#34;</span>);
</span></span><span style=display:flex><span>	  old2 <span style=color:#666>=</span> old;
</span></span><span style=display:flex><span>	  p<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> PROTECT_PTR (<span style=color:#666>&amp;</span>p<span style=color:#666>-&gt;</span>fd, old);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>while</span> ((old <span style=color:#666>=</span> catomic_compare_and_exchange_val_rel (fb, p, old2))
</span></span><span style=display:flex><span>	     <span style=color:#666>!=</span> old2);
</span></span></code></pre></div><p>在多线程情况下就需要通过原子操作来插入了，也就是哪个 catomic 开头的宏，当然其实它和宏 <code>catomic_compare_and_exchange_val_acq</code> 是一个东西，glibc 的解释为（之前 malloc 中也碰到过，原样复制过来）</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* Atomically store NEWVAL in *MEM if *MEM is equal to OLDVAL.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   Return the old *MEM value.  */</span>
</span></span></code></pre></div><p>可见该宏通过原子变量来避免多线程情况下的赋值错误，而做的事情和单线程下也无区别，就是 <code>*fb = REVEAL_PTR (victim->fd);</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* Check that size of fastbin chunk at the top is the same as
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>       size of the chunk that we are adding.  We can dereference OLD
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>       only if we have the lock, otherwise it might have already been
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>       allocated again.  */</span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (have_lock <span style=color:#666>&amp;&amp;</span> old <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>
</span></span><span style=display:flex><span>	<span style=color:#666>&amp;&amp;</span> __builtin_expect (fastbin_index (chunksize (old)) <span style=color:#666>!=</span> idx, <span style=color:#40a070>0</span>))
</span></span><span style=display:flex><span>      malloc_printerr (<span style=color:#4070a0>&#34;invalid fastbin entry (free)&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>完成入链后会最后再做一次合法性检查，检查原先出于链表头的 chunk（也就是现在 fastbin 中第二个 chunk）的 size 是否属于当前链表。</p><h3 id=free-to-unsorted-bin>free to unsorted bin</h3><p>若 chunk 无法进入上面的俩个 bin 中，则将 chunk 置入 unsorted bin 这个各 bin 的缓冲区中。这里为了减少内存碎片，还会进行合并等操作。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>    Consolidate other non-mmapped chunks as they arrive.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>  */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>else</span> <span style=color:#06287e>if</span> (<span style=color:#666>!</span>chunk_is_mmapped(p)) {
</span></span></code></pre></div><p>首先判断 chunk 是否为 mmap 分配的，若是直接 unmap 即可，若否进入之后的流程</p><h4 id=初始化和合法性检查>初始化和合法性检查</h4><p>在这里会初始化一些变量，并进行许多合法性检查</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* If we&#39;re single-threaded, don&#39;t lock the arena.  */</span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (SINGLE_THREAD_P)
</span></span><span style=display:flex><span>      have_lock <span style=color:#666>=</span> <span style=color:#007020>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>have_lock)
</span></span><span style=display:flex><span>      __libc_lock_lock (av<span style=color:#666>-&gt;</span>mutex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    nextchunk <span style=color:#666>=</span> chunk_at_offset(p, size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* Lightweight tests: check whether the block is already the
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>       top block.  */</span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (p <span style=color:#666>==</span> av<span style=color:#666>-&gt;</span>top))
</span></span><span style=display:flex><span>      malloc_printerr (<span style=color:#4070a0>&#34;double free or corruption (top)&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* Or whether the next chunk is beyond the boundaries of the arena.  */</span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (__builtin_expect (contiguous (av)
</span></span><span style=display:flex><span>			  <span style=color:#666>&amp;&amp;</span> (<span style=color:#902000>char</span> <span style=color:#666>*</span>) nextchunk
</span></span><span style=display:flex><span>			  <span style=color:#666>&gt;=</span> ((<span style=color:#902000>char</span> <span style=color:#666>*</span>) av<span style=color:#666>-&gt;</span>top <span style=color:#666>+</span> chunksize(av<span style=color:#666>-&gt;</span>top)), <span style=color:#40a070>0</span>))
</span></span><span style=display:flex><span>	malloc_printerr (<span style=color:#4070a0>&#34;double free or corruption (out)&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* Or whether the block is actually not marked used.  */</span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (<span style=color:#666>!</span>prev_inuse(nextchunk)))
</span></span><span style=display:flex><span>      malloc_printerr (<span style=color:#4070a0>&#34;double free or corruption (!prev)&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    nextsize <span style=color:#666>=</span> chunksize(nextchunk);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (__builtin_expect (chunksize_nomask (nextchunk) <span style=color:#666>&lt;=</span> CHUNK_HDR_SZ, <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#666>||</span> __builtin_expect (nextsize <span style=color:#666>&gt;=</span> av<span style=color:#666>-&gt;</span>system_mem, <span style=color:#40a070>0</span>))
</span></span><span style=display:flex><span>      malloc_printerr (<span style=color:#4070a0>&#34;free(): invalid next size (normal)&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    free_perturb (chunk2mem(p), size <span style=color:#666>-</span> CHUNK_HDR_SZ);
</span></span></code></pre></div><p>首先根据线程情况考虑是否需要加锁，并获得下一个 chunk 的地址，存于变量 nextchunk 中。</p><p>然后进行许多合法性检查</p><ul><li>检查被 free 的 chunk 是否是 top_chunk，top_chunk 不可能被 free，若为 top_chunk，进行报错</li><li>判断 nextchunk 的地址是否大于 top_chunk，若分配区模式为“是否分配连续的虚拟地址”，则 nextchunk 的地址不可能大于 top_chunk，此时进行报错</li><li>检查 nextchunk 的 prev_inuse 位，若本 chunk 本来就是 free 状态，代表是 double free，进行报错</li><li>获取下一个 chunk 的大小存于 nextsize 中，进行类似于 fastbin 中的 chunk 大小检查。</li></ul><h4 id=前后向合并>前后向合并</h4><p>通过合法性检查后首先尝试进行向低地址合并</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* consolidate backward */</span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>prev_inuse(p)) {
</span></span><span style=display:flex><span>      prevsize <span style=color:#666>=</span> prev_size (p);
</span></span><span style=display:flex><span>      size <span style=color:#666>+=</span> prevsize;
</span></span><span style=display:flex><span>      p <span style=color:#666>=</span> chunk_at_offset(p, <span style=color:#666>-</span>((<span style=color:#902000>long</span>) prevsize));
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (chunksize(p) <span style=color:#666>!=</span> prevsize))
</span></span><span style=display:flex><span>        malloc_printerr (<span style=color:#4070a0>&#34;corrupted size vs. prev_size while consolidating&#34;</span>);
</span></span><span style=display:flex><span>      unlink_chunk (av, p);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>对 size，prev_size 等字段值的设置会在向高地址合并时统一进行，这里只做了解链和大小的更新。</p><p>在 libc-2.29 及更高版本中，这里和 unlink_chunk 函数中都加入了对前后 chunk 在地址上是否相连的检测，使 unlink 攻击方式变得困难许多，有一种通过 large chunk 绕过的方法，比较典型的是 <strong>Balsn_CTF_2019-PlainText</strong> 一题，<a href=https://chujdk.github.io/WP/1290.html>WP</a></p><p>然后尝试向高地址合并，这里要判断下一个 chunk 是不是 top_chunk，若不是则尝试合并</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (nextchunk <span style=color:#666>!=</span> av<span style=color:#666>-&gt;</span>top) {
</span></span><span style=display:flex><span>      <span style=color:#60a0b0;font-style:italic>/* get and clear inuse bit */</span>
</span></span><span style=display:flex><span>      nextinuse <span style=color:#666>=</span> inuse_bit_at_offset(nextchunk, nextsize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#60a0b0;font-style:italic>/* consolidate forward */</span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>nextinuse) {
</span></span><span style=display:flex><span>	unlink_chunk (av, nextchunk);
</span></span><span style=display:flex><span>	size <span style=color:#666>+=</span> nextsize;
</span></span><span style=display:flex><span>      } <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>clear_inuse_bit_at_offset</span>(nextchunk, <span style=color:#40a070>0</span>);
</span></span></code></pre></div><p>然后将处理好的 chunk 放入 unsorted bin 中</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>      <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	Place the chunk in unsorted chunk list. Chunks are
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	not placed into regular bins until after they have
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	been given one chance to be used in malloc.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>      */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      bck <span style=color:#666>=</span> unsorted_chunks(av);
</span></span><span style=display:flex><span>      fwd <span style=color:#666>=</span> bck<span style=color:#666>-&gt;</span>fd;
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (__glibc_unlikely (fwd<span style=color:#666>-&gt;</span>bk <span style=color:#666>!=</span> bck))
</span></span><span style=display:flex><span>	malloc_printerr (<span style=color:#4070a0>&#34;free(): corrupted unsorted chunks&#34;</span>);
</span></span><span style=display:flex><span>      p<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> fwd;
</span></span><span style=display:flex><span>      p<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> bck;
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>in_smallbin_range(size))
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	  p<span style=color:#666>-&gt;</span>fd_nextsize <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	  p<span style=color:#666>-&gt;</span>bk_nextsize <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>      bck<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> p;
</span></span><span style=display:flex><span>      fwd<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> p;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      set_head(p, size <span style=color:#666>|</span> PREV_INUSE);
</span></span><span style=display:flex><span>      set_foot(p, size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      check_free_chunk(av, p);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>入链的操作中对 unsorted bin 的链表进行了完整性检查，检查链表中第一个 chunk 的 bk 是否指向链表头。然后将合并好的 chunk 插到 unsorted bin 的头部，可见 unsorted bin 链表为先进后出结构（malloc 的时候是从尾部开始遍历的），平均了每个 chunk 被访问的机会。</p><p>如果下一个 chunk 为 top_chunk，则将当前 chunk 和 top_chunk 合并形成新的 top_chunk。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>      If the chunk borders the current high end of memory,
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>      consolidate into top
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>    */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>else</span> {
</span></span><span style=display:flex><span>      size <span style=color:#666>+=</span> nextsize;
</span></span><span style=display:flex><span>      set_head(p, size <span style=color:#666>|</span> PREV_INUSE);
</span></span><span style=display:flex><span>      av<span style=color:#666>-&gt;</span>top <span style=color:#666>=</span> p;
</span></span><span style=display:flex><span>      check_chunk(av, p);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h4 id=取出-fastbin>取出 fastbin</h4><p>如果合并完成的 chunk 的 size 大于 <code>FASTBIN_CONSOLIDATION_THRESHOLD</code>，默认为 65536（64KB），并且 fastbin 中存在 chunk，调用 malloc_consolidate 将 fastbin 取出</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>      If freeing a large space, consolidate possibly-surrounding
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>      chunks. Then, if the total unused topmost memory exceeds trim
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>      threshold, ask malloc_trim to reduce top.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>      Unless max_fast is 0, we don&#39;t know if there are fastbins
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>      bordering top, so we cannot tell for sure whether threshold
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>      has been reached unless fastbins are consolidated.  But we
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>      don&#39;t want to consolidate on each free.  As a compromise,
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>      is reached.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>    */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> ((<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>)(size) <span style=color:#666>&gt;=</span> FASTBIN_CONSOLIDATION_THRESHOLD) {
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (atomic_load_relaxed (<span style=color:#666>&amp;</span>av<span style=color:#666>-&gt;</span>have_fastchunks))
</span></span><span style=display:flex><span>	malloc_consolidate(av);
</span></span></code></pre></div><h4 id=收缩-top_chunk>收缩 top_chunk</h4><p>之后的处理，根据分配区的不同</p><ul><li>对主分配区如果 top_chunk 的大小大于 trim_threshold（堆的收缩阀值），调用 systrim 直接收缩 top_chunk 的大小</li><li>对非主分配区直接调用（always try） heap_trim 收缩 sub_heap。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (av <span style=color:#666>==</span> <span style=color:#666>&amp;</span>main_arena) {
</span></span><span style=display:flex><span><span style=color:#007020>#ifndef MORECORE_CANNOT_TRIM
</span></span></span><span style=display:flex><span><span style=color:#007020></span>	<span style=color:#007020;font-weight:700>if</span> ((<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>)(chunksize(av<span style=color:#666>-&gt;</span>top)) <span style=color:#666>&gt;=</span>
</span></span><span style=display:flex><span>	    (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>)(mp_.trim_threshold))
</span></span><span style=display:flex><span>	  systrim(mp_.top_pad, av);
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020></span>      } <span style=color:#007020;font-weight:700>else</span> {
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* Always try heap_trim(), even if the top chunk is not
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	   large, because the corresponding heap might go away.  */</span>
</span></span><span style=display:flex><span>	heap_info <span style=color:#666>*</span>heap <span style=color:#666>=</span> heap_for_ptr(top(av));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	assert(heap<span style=color:#666>-&gt;</span>ar_ptr <span style=color:#666>==</span> av);
</span></span><span style=display:flex><span>	heap_trim(heap, mp_.top_pad);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>have_lock)
</span></span><span style=display:flex><span>      __libc_lock_unlock (av<span style=color:#666>-&gt;</span>mutex);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>完事后根据分配区的锁情况释放锁。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>    If the chunk was allocated via mmap, release via munmap().
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>  */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>else</span> {
</span></span><span style=display:flex><span>    munmap_chunk (p);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>代码的最后是之前提到的对 mmap 分配的堆块的处理，通过调用 munmap_chunk 来释放。到这里 _int_free 就结束了。</p><h3 id=总结>总结</h3><p>关于 _int_free 的形参 have_lock，从 __libc_free 进入的时候，是直接置成零的，所以直接 free 的话，在置入 chunk 的时候，是不会对分配区加锁的（并不代表整个 _int_free 都不会加锁）。所以之前在 _int_malloc 中可以看到在结尾时，即便调用过了一次 malloc_consolidate，仍然会再调用一次，就是因为未加锁，fastbin 仍然可能在 malloc 的途中被其他线程加入 chunk。这个 have_lock 也不会总为零的，因为还有别的函数也会调用只，所以许多判断不是多余的。</p><p>类似的，对于 chunk 是否为 mmaped 的判断也不多余，因为别的函数调用时不一定会分开来处理。</p><p>至此 free 分析结束。</p><h1 id=参考>参考</h1><blockquote><p><a href=https://zhuanlan.zhihu.com/p/136983333>Heap Exploit v2.31 | 最新堆利用技巧，速速查收</a></p><p><a href=https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf>glibc内存管理ptmalloc源代码分析</a></p><p><a href=https://code.woboq.org/userspace/glibc/malloc/>woboq</a></p><p><a href=https://elixir.bootlin.com/glibc/latest/source>bootlin</a></p><p><a href=https://ctf-wiki.org/>ctf-wiki</a></p></blockquote></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/curious>Curious</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/chujdk rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=mailto:chujj31@gmail.com rel=me title=Mail><i data-feather=mail></i></a>
<a class=border></a><a class=soc href=https://chujdk.github.io/index.xml rel=me title=Rss><i data-feather=rss></i></a>
<a class=border></a></div><div class=footer-info>2024 © chuj | Based on <a href=https://github.com/athul/archie>Archie</a> | Built with <a href=https://gohugo.io>Hugo</a> | <a href=#>Goto Top</a></div></footer><script>feather.replace()</script></div></body></html>