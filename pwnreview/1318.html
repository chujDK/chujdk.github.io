<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Kernel PWN 环境搭建 - blog of chuj</title><link rel=icon type=image/png href=https://chujdk.github.io/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="一直对 kernel pwn 挺感兴趣的，再加上 libc 那里也没什么新东西可学了，简单题没什么做的意义，难题也不会做，所以准备开始学习 kernel pwn。不过可能最近也没办法太深入的学习，总之先把环境搭起来再说。"><meta property="og:image" content><meta property="og:url" content="https://chujdk.github.io/pwnreview/1318.html"><meta property="og:site_name" content="blog of chuj"><meta property="og:title" content="Kernel PWN 环境搭建"><meta property="og:description" content="一直对 kernel pwn 挺感兴趣的，再加上 libc 那里也没什么新东西可学了，简单题没什么做的意义，难题也不会做，所以准备开始学习 kernel pwn。不过可能最近也没办法太深入的学习，总之先把环境搭起来再说。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-17T21:45:00+00:00"><meta property="article:modified_time" content="2021-06-17T21:45:00+00:00"><meta property="article:tag" content="Kernel-Pwn"><meta property="article:tag" content="Environment"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kernel PWN 环境搭建"><meta name=twitter:description content="一直对 kernel pwn 挺感兴趣的，再加上 libc 那里也没什么新东西可学了，简单题没什么做的意义，难题也不会做，所以准备开始学习 kernel pwn。不过可能最近也没办法太深入的学习，总之先把环境搭起来再说。"><script src=https://chujdk.github.io/js/feather.min.js></script><link href=https://chujdk.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://chujdk.github.io/css/main.d24d3471089d3a4f095edc4a6857e25a9f1c6dd3e7d17026141ccad319438873.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://chujdk.github.io/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://chujdk.github.io/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about.html>About</a>
<a href=/tags>Tags</a></nav></header><main><article><div class=title><h1 class=title>Kernel PWN 环境搭建</h1><div class=meta>Posted on Jun 17, 2021</div></div><section class=body><p>一直对 kernel pwn 挺感兴趣的，再加上 libc 那里也没什么新东西可学了，简单题没什么做的意义，难题也不会做，所以准备开始学习 kernel pwn。不过可能最近也没办法太深入的学习，总之先把环境搭起来再说。</p><p>首先说一下这里的环境到底指的是什么，我们希望能够有一个沙盒环境，可以做到</p><ul><li>启动速度快。kernel pwn 的过程中很容易造成 kernel panic，如果每次启动要几十秒，体验肯定是很差的</li><li>可以用 gdb 之类的调试器调试。脑调是很痛苦的</li><li>可复用。每次启动环境的时候初始状态都应该相同，即便上一次把内核搞炸了下一次重启应该也可以解决全部问题</li></ul><p>满足上述要求的解决方案就是 qemu + gdb 的调试方法。</p><p>以一台全新的 Ubuntu 20.04 LTS Desktop 虚拟机为例，虚拟机的安装使用 VMware 快速安装模式安装。</p><p>首先运行一个 kernel 的环境需要有一个 kernel 的镜像，镜像的获取手段有</p><ul><li>手动编译一个内核出来</li><li>直接从软件源里面下</li><li>直接用本机的镜像</li></ul><h3 id=从软件源下载>从软件源下载</h3><p>首先搜索镜像，下面这句话会把源里有的所有镜像都显示出来，可以配合 grep 来查找特定版本的镜像</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt search linux-image
</span></span></code></pre></div><p>找出镜像后就可以下载，这里以 linux-image-5.8.0-23-generic 为例</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt download linux-image-5.8.0-23-generic
</span></span></code></pre></div><p>下载下来后解压，在文件夹 <code>data/boot/</code> 中的以 vmlinux 开头的即为镜像文件</p><h3 id=使用本机镜像>使用本机镜像</h3><p>在 <code>/boot</code> 文件夹中即可找到</p><h3 id=内核镜像编译>内核镜像编译</h3><p>使用前两种方法比较快速，但是往往没有符号，为了调试方便，还是需要手动编译。</p><p>首先安装一些依赖</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc libelf-dev flex bison
</span></span></code></pre></div><p>然后下载 kernel 源码，在<a href=https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/>官网</a>可以下载，我下载的是 5.8 版本（版本应该可以随便选，我选择和系统版本一致）。</p><p>解压后先进行编译设置</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>make menuconfig
</span></span></code></pre></div><p>进入内核编译设置，进入 kernel hacking 子目录，检查一下 debug 相关的选项有没有打开（其实默认都是打开的，进去看看确定一下就可以了）。</p><p>然后编译安装</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>make bzImage -j<span style=color:#007020;font-weight:700>$(</span>nproc<span style=color:#007020;font-weight:700>)</span>
</span></span></code></pre></div><p><code>-j$(nproc)</code> 是使用所有的核心编译，可以加快编译速度。</p><p>编译的过程中可能会碰到报错 <code>*** No rule to make target 'debian/canonical-certs.pem', needed by 'certs/x509_certificate_list'. Stop.</code>，对于该错误只要注释掉编译目录下的 .config 中的<code>CONFIG_SYSTEM_TRUSTED_KEYS="debian/certs/benh@debian.org.cert.pem"</code> 一行即可。</p><p>我两次编译安装过程中都只碰到了这一个问题，如果出现别的问题通过搜索引擎应该也都可以解决。</p><p>编译出来的 bzImage 是不带符号的压缩映像，如果想要源码级调试，需要编译 vmlinux，也就是</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>make vmlinux -j<span style=color:#007020;font-weight:700>$(</span>nproc<span style=color:#007020;font-weight:700>)</span>
</span></span></code></pre></div><p>vmlinux 就是带符号的。</p><h3 id=qemu-安装>qemu 安装</h3><p>qemu 可以模拟各个架构，基本是唯一的选择了。图省事的话可以直接用包管理器安装</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt install git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev
</span></span><span style=display:flex><span>sudo apt install qemu-user
</span></span></code></pre></div><p>安装好后敲下 qemu 之后按 tab 有大量回显就算安装好了（可能需要重启终端）。</p><p>但是就我在调 ARM 过程中使用包管理安装的 qemu 时不怎么美好的经历，也建议自己手动编译安装一个最新版，可以参考<a href=https://chujdk.github.io/pwnreview/1353.html>这篇文章</a>。</p><h3 id=busybox-安装>busybox 安装</h3><p>busybox 提供了一个 Linux 虚拟环境需要的大量程序，如 ls，cat 等。</p><p>首先到 <a href=https://busybox.net/downloads/>官网</a> 中下载，下下来之后解压，进行配置</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>make menuconfig
</span></span></code></pre></div><p>注意勾选 Settings &mdash;> Build static binary file (no shared lib)，避免之后还要配置 lib。</p><p>然后</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>make -j<span style=color:#007020;font-weight:700>$(</span>nproc<span style=color:#007020;font-weight:700>)</span>
</span></span><span style=display:flex><span>make install
</span></span></code></pre></div><p>既可，默认是安装在当前目录下的 _install 文件夹中的，把这个文件夹移到你想移的位置即可，为了方便，我直接放在了准备运行 qemu 的目录下。</p><p>然后进入 _install 文件夹中，先建立一些必要的文件夹</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir sys
</span></span><span style=display:flex><span>mkdir proc
</span></span></code></pre></div><p>然后写一下 init 脚本</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#007020>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#007020></span>mount -t proc none /proc
</span></span><span style=display:flex><span>mount -t sysfs none /sys
</span></span><span style=display:flex><span><span style=color:#007020>exec</span> 0&lt;/dev/console
</span></span><span style=display:flex><span><span style=color:#007020>exec</span> 1&gt;/dev/console
</span></span><span style=display:flex><span><span style=color:#007020>exec</span> 2&gt;/dev/console
</span></span><span style=display:flex><span><span style=color:#007020>echo</span> -e <span style=color:#4070a0>&#34;{==DBG==} Boot took </span><span style=color:#007020;font-weight:700>$(</span>cut -d<span style=color:#4070a0>&#39; &#39;</span> -f1 /proc/uptime<span style=color:#007020;font-weight:700>)</span><span style=color:#4070a0> seconds&#34;</span>
</span></span><span style=display:flex><span>setsid /bin/cttyhack setuidgid <span style=color:#40a070>1000</span> /bin/sh <span style=color:#60a0b0;font-style:italic>#normal user</span>
</span></span><span style=display:flex><span>umount /proc
</span></span><span style=display:flex><span>umount /sys
</span></span><span style=display:flex><span>poweroff -d <span style=color:#40a070>0</span>  -f
</span></span></code></pre></div><p>给予可执行权限</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>chmod +x ./init
</span></span></code></pre></div><p>然后把这里的文件都打包</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>find . | cpio -o --format<span style=color:#666>=</span>newc &gt; ../rootfs.cpio
</span></span></code></pre></div><p>到上层文件夹中就会有 rootfs.cpio 文件了，然后把 bzImage 也放到这里，就可以启动 qemu 了。由于参数较多，所以写成一个 shell 脚本来启动</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>qemu-system-x86_64 <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -m 128M <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -kernel bzImage <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -initrd rootfs.cpio <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -append <span style=color:#4070a0>&#39;root=/dev/ram console=ttyS0 oops=panic panic=1&#39;</span> <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -monitor /dev/null <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -cpu kvm64,+smep <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -smp <span style=color:#bb60d5>cores</span><span style=color:#666>=</span>1,threads<span style=color:#666>=</span><span style=color:#40a070>1</span> <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -netdev user,id<span style=color:#666>=</span>t0, -device e1000,netdev<span style=color:#666>=</span>t0,id<span style=color:#666>=</span>nic0 <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -nographic
</span></span></code></pre></div><p>执行脚本后就会调用 qemu 来启动虚拟机</p><div style=text-align:center><img src=https://chujdk.github.io/usr/uploads/2021/06/269383429.png></div><p>这里会报错，我也不知道是什么原因，但是好像没什么影响，所以暂且不管了。</p><p>可见，有 boot.sh bzImage rootfs.cpio 即可启动一个虚拟内核环境，所以大多数的题目都会给出这几个文件。</p><p>对于 rootfs.cpio 的解压可以通过</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cpio -idmv &lt; rootfs.cpio
</span></span></code></pre></div><p>这会把 rootfs.cpio 中的文件都解压到当前目录中。</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/kernel-pwn>kernel-pwn</a></li><li><a href=/tags/environment>environment</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/chujdk rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=mailto:chujj31@gmail.com rel=me title=Mail><i data-feather=mail></i></a>
<a class=border></a><a class=soc href=https://chujdk.github.io/index.xml rel=me title=Rss><i data-feather=rss></i></a>
<a class=border></a></div><div class=footer-info>2025 © chuj | Based on <a href=https://github.com/athul/archie>Archie</a> | Built with <a href=https://gohugo.io>Hugo</a> | <a href=#>Goto Top</a></div></footer><script>feather.replace()</script></div></body></html>