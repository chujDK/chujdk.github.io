<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>pwn 指定程序运行时使用的 libc - blog of chuj</title><link rel=icon type=image/png href=https://chujdk.github.io/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="文章是一月份的时候写的了，那个时候比较稚嫩，当时并没有很好的解决这个问题，也没有写清楚，现在重写一下。
使用 patchelf 替换
假如我们有靶机的 libc，那么通过 patchelf 就可以将二进制使用的 libc 硬改写成靶机的 libc。"><meta property="og:image" content><meta property="og:url" content="https://chujdk.github.io/pwnreview/941.html"><meta property="og:site_name" content="blog of chuj"><meta property="og:title" content="pwn 指定程序运行时使用的 libc"><meta property="og:description" content="文章是一月份的时候写的了，那个时候比较稚嫩，当时并没有很好的解决这个问题，也没有写清楚，现在重写一下。
使用 patchelf 替换 假如我们有靶机的 libc，那么通过 patchelf 就可以将二进制使用的 libc 硬改写成靶机的 libc。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-04T15:29:00+00:00"><meta property="article:modified_time" content="2021-06-04T15:29:00+00:00"><meta property="article:tag" content="Waste of Time"><meta name=twitter:card content="summary"><meta name=twitter:title content="pwn 指定程序运行时使用的 libc"><meta name=twitter:description content="文章是一月份的时候写的了，那个时候比较稚嫩，当时并没有很好的解决这个问题，也没有写清楚，现在重写一下。
使用 patchelf 替换 假如我们有靶机的 libc，那么通过 patchelf 就可以将二进制使用的 libc 硬改写成靶机的 libc。"><script src=https://chujdk.github.io/js/feather.min.js></script><link href=https://chujdk.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://chujdk.github.io/css/main.d24d3471089d3a4f095edc4a6857e25a9f1c6dd3e7d17026141ccad319438873.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://chujdk.github.io/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://chujdk.github.io/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>pwn 指定程序运行时使用的 libc</h1><div class=meta>Posted on Jun 4, 2021</div></div><section class=body><p>文章是一月份的时候写的了，那个时候比较稚嫩，当时并没有很好的解决这个问题，也没有写清楚，现在重写一下。</p><h3 id=使用-patchelf-替换>使用 patchelf 替换</h3><p>假如我们有靶机的 libc，那么通过 patchelf 就可以将二进制使用的 libc 硬改写成靶机的 libc。</p><h4 id=获取-patchelf>获取 patchelf</h4><p>一般来说，想要解决这个问题的师傅的环境肯定都是搭好的了，patchelf 肯定是已经装好了的，但是应该都是通过包管理器装的，版本估计都不是最新的</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>patchelf --version
</span></span></code></pre></div><p>输入以上指令可以检测，写此文章的时候最新版本为 <code>0.12.20200827.8d3a16e</code>，老版本会有各种各样的问题，最好还是安装最新版本。</p><p>首先到 github 上找到最新版本（<a href=https://github.com/NixOS/patchelf/releases>链接</a>），下载并解压。进入目录，配置编译安装。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>./configure --prefix<span style=color:#666>=</span>/usr/
</span></span><span style=display:flex><span>make -j<span style=color:#007020;font-weight:700>$(</span>nproc<span style=color:#007020;font-weight:700>)</span>
</span></span><span style=display:flex><span>sudo make install
</span></span></code></pre></div><p>就安装好了</p><h4 id=替换-libc-和-ld>替换 libc 和 ld</h4><p>其实就是两条指令的事情，但是这里写的详细一些。</p><p>首先通过 ldd 指令可以获得一个二进制文件的依赖库，如下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ldd pwn_binary 
</span></span><span style=display:flex><span>        linux-vdso.so.1 <span style=color:#666>(</span>0x00007fff609fc000<span style=color:#666>)</span>
</span></span><span style=display:flex><span>        libc.so.6 <span style=color:#666>=</span>&gt; /lib/x86_64-linux-gnu/libc.so.6 <span style=color:#666>(</span>0x00007f1a9a2b1000<span style=color:#666>)</span>
</span></span><span style=display:flex><span>        /lib64/ld-linux-x86-64.so.2 <span style=color:#666>(</span>0x00007f1a9a8a4000<span style=color:#666>)</span>
</span></span></code></pre></div><p>这些其实就是写死在 binary 中的信息，patchelf 可以帮我们替换这些东西。</p><p>要替换 ld，可以通过 <code>patchelf --set-interpreter /path/to/ld.so /path/to/binary</code></p><p>比如用一个自己编译的 ld 替换虚拟机的 ld，只要执行</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>patchelf --set-interpreter /glibc/2.27/amd64/lib/ld-2.27.so ./pwn_binary
</span></span></code></pre></div><p>使用 ldd 指令查看一下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ldd pwn_binary
</span></span><span style=display:flex><span>        linux-vdso.so.1 <span style=color:#666>(</span>0x00007ffd08dc2000<span style=color:#666>)</span>
</span></span><span style=display:flex><span>        libc.so.6 <span style=color:#666>=</span>&gt; /lib/x86_64-linux-gnu/libc.so.6 <span style=color:#666>(</span>0x00007fd343247000<span style=color:#666>)</span>
</span></span><span style=display:flex><span>        /glibc/2.27/amd64/lib/ld-2.27.so <span style=color:#666>=</span>&gt; /lib64/ld-linux-x86-64.so.2 <span style=color:#666>(</span>0x00007fd34383b000<span style=color:#666>)</span>
</span></span></code></pre></div><p>发现替换成功了。如果要替换 libc，就需要使用</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>patchelf --replace-needed originlibc newlibc /path/to/binary
</span></span></code></pre></div><p>这里做的是一个 replace，把原来的依赖文件替换为新的依赖文件，以现在这个 <code>pwn_binary</code> 为例，就是</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>patchelf --replace-needed libc.so.6 /glibc/2.27/amd64/lib/libc.so.6 ./pwn_binary
</span></span></code></pre></div><p>ldd 一下就可以发现替换成功了</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ldd pwn_binary
</span></span><span style=display:flex><span>        linux-vdso.so.1 <span style=color:#666>(</span>0x00007ffc5cf66000<span style=color:#666>)</span>
</span></span><span style=display:flex><span>        /glibc/2.27/amd64/lib/libc.so.6 <span style=color:#666>(</span>0x00007fb021cce000<span style=color:#666>)</span>
</span></span><span style=display:flex><span>        /glibc/2.27/amd64/lib/ld-2.27.so <span style=color:#666>=</span>&gt; /lib64/ld-linux-x86-64.so.2 <span style=color:#666>(</span>0x00007fb022286000<span style=color:#666>)</span>
</span></span></code></pre></div><p>如果要替换回到系统使用的 libc，或者是别的 libc，以替换到 2.23 的 libc 为例，这个时候就要这样写</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>patchelf --replace-needed /glibc/2.27/amd64/lib/libc.so.6 /glibc/2.23/amd64/lib/libc.so.6 ./pwn_binary
</span></span></code></pre></div><p>对于依赖多个动态库的 elf 文件，也可以用同样的指令进行替换。</p><p>这里要注意的是，ld 和 libc 的版本相差不能太大，不然运行时就会出现错误。</p><p>然后就是新的问题：一般情况下可能最多给个 libc，不提供 ld，手上也没有相似版本的 ld，又或者是提供的 libc 没有符号，gdb 看不了堆布局很难受。怎么办？请往下看。</p><h3 id=获取libc版本>获取libc版本</h3><p>首先需要知道靶机的 libc 版本，用 strings 指令比如 <code>strings libc.so.6 | grep "ubuntu"</code>，简单快捷。</p><p>然后有两种方法，一是下载对应版本的 ld 和 libc，二是自己手动编译一个。</p><h4 id=下载>下载</h4><p>已经有师傅做好了整理，可以提供自动化的下载，比如 <a href=https://github.com/matrix1001/glibc-all-in-one>glibc-all-in-one</a>，但是这个当然不是完整的，有些版本可能需要自己去谷歌然后下载。但是其实版本只要相近就可以了，不是一定要完全一样。特别说一下 <a href=https://github.com/matrix1001/glibc-all-in-one>glibc-all-in-one</a> 下载下来的 libc 是有符号的，很棒</p><h4 id=编译libc以-223-为例>编译libc——以 2.23 为例</h4><p>提前说一下，<a href=https://github.com/matrix1001/glibc-all-in-one>glibc-all-in-one</a> 也提供了自动化编译脚本，但是在我的电脑上有时候会编译出错，所以有时候可能还是需要自己编译，这里以编译 2.23 版本作为例子。</p><h5 id=准备工作>准备工作</h5><p>我的虚拟机为 Ubuntu 18.04。编译旧版本的 libc，最好用旧版本的 gcc，所以我们考虑安装一下，好消息是不同版本的 gcc 是可以共存的。</p><p>首先添加旧版本的镜像源。使用 <code>sudo vim /etc/apt/sources.list</code>添加</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>deb http://mirrors.aliyun.com/ubuntu/ xenial main
</span></span><span style=display:flex><span>deb http://mirrors.aliyun.com/ubuntu/ xenial universe
</span></span></code></pre></div><p>然后 <code>sudo apt-get update</code>更新源。</p><p>安装旧版本的gcc</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt-get install gcc-4.8
</span></span><span style=display:flex><span>sudo apt-get install gcc-4.8-multilib
</span></span><span style=display:flex><span>sudo apt-get install g++-4.8
</span></span><span style=display:flex><span>sudo apt-get install g++-4.8-multilib
</span></span><span style=display:flex><span>sudo apt-get install gcc-5
</span></span><span style=display:flex><span>sudo apt-get install gcc-5-multilib
</span></span><span style=display:flex><span>sudo apt-get install g++-5
</span></span><span style=display:flex><span>sudo apt-get install g++-5-multilib
</span></span></code></pre></div><p>添加到维护程序版本的 <code>update-alternatives</code>中</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 <span style=color:#40a070>40</span> --slave /usr/bin/g++ g++ /usr/bin/g++-4.8
</span></span><span style=display:flex><span>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 <span style=color:#40a070>50</span> --slave /usr/bin/g++ g++ /usr/bin/g++-5
</span></span><span style=display:flex><span>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 <span style=color:#40a070>70</span> --slave /usr/bin/g++ g++ /usr/bin/g++-7
</span></span></code></pre></div><p>通过 <code>sudo update-alternatives --config gcc</code>就可以切换版本了</p><p>编译2.23版本的libc时我们选择gcc-4.8</p><h5 id=编译安装>编译安装</h5><p>首先下载2.23版本的源码</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wget https://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.gz
</span></span></code></pre></div><p>然后解压</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tar -zxvf glibc-2.23.tar.gz
</span></span><span style=display:flex><span><span style=color:#007020>cd</span> glibc-2.23
</span></span></code></pre></div><p>建立目录并完成设置</p><h6 id=64位>64位</h6><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir build64
</span></span><span style=display:flex><span><span style=color:#007020>cd</span> build64
</span></span><span style=display:flex><span>sudo <span style=color:#bb60d5>CFLAGS</span><span style=color:#666>=</span><span style=color:#4070a0>&#34;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error&#34;</span> <span style=color:#bb60d5>CXXFLAGS</span><span style=color:#666>=</span><span style=color:#4070a0>&#34;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error&#34;</span> ../configure --prefix<span style=color:#666>=</span>path_to_install
</span></span><span style=display:flex><span>sudo make -j<span style=color:#007020;font-weight:700>$(</span>nproc<span style=color:#007020;font-weight:700>)</span>
</span></span><span style=display:flex><span>sudo make install
</span></span></code></pre></div><h6 id=32位>32位</h6><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir build32
</span></span><span style=display:flex><span><span style=color:#007020>cd</span> build32
</span></span><span style=display:flex><span>sudo ../configure --prefix<span style=color:#666>=</span>/path/to/install --host<span style=color:#666>=</span>i686-linux-gnu<span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span><span style=color:#bb60d5>CC</span><span style=color:#666>=</span><span style=color:#4070a0>&#34;gcc -m32&#34;</span> <span style=color:#bb60d5>CXX</span><span style=color:#666>=</span><span style=color:#4070a0>&#34;g++ -m32&#34;</span> <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span><span style=color:#bb60d5>CFLAGS</span><span style=color:#666>=</span><span style=color:#4070a0>&#34;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error&#34;</span> <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span><span style=color:#bb60d5>CXXFLAGS</span><span style=color:#666>=</span><span style=color:#4070a0>&#34;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error&#34;</span>
</span></span><span style=display:flex><span>sudo make -j<span style=color:#007020;font-weight:700>$(</span>nproc<span style=color:#007020;font-weight:700>)</span>
</span></span><span style=display:flex><span>sudo make install
</span></span></code></pre></div><p>这里 make 后面的 -j$(nproc) 是指定多线程编译，如果你的电脑 CPU 线程比较多，那就可以大幅加速编译过程。</p><p>make 的时候很可能会出现如下错误</p><div style=text-align:center><img src=https://chujdk.github.io/usr/uploads/2021/01/3877627060.png></div><p>解决办法就是在这三个变量后面加 <code>__attribute__ ((nocommon))</code>。他们在/glibc-2.23/misc/regexp.c中（不出意外是从第33行开始的）。</p><div style=text-align:center><img src=https://chujdk.github.io/usr/uploads/2021/01/3370886825.png></div><p>改成这样就可以了。然后应该就可以<code>sudo make</code>和<code>sudo make install</code>了（据说还可能有别的问题，但是我没有碰到）。</p><p>至此编译安装的过程就结束了，编译出的ld和libc在安装目录下的lib文件夹里面。我这里是叫<code>ld-linux.so.2</code>和<code>libc.so.6</code>。可以考虑cp到elf文件所在的目录下。</p><p><em>最近在编译 2.34 版本的 glibc 时碰到了大量的 -Werror 问题，在较高版本 gcc 中可以用 <code>-w</code> 来忽略所有的警告，不再把警告当作错误。类似的参数低版本似乎是 <code>-Wno-error</code></em></p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/waste-of-time>waste of time</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/chujdk rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=mailto:chujj31@gmail.com rel=me title=Mail><i data-feather=mail></i></a>
<a class=border></a><a class=soc href=https://chujdk.github.io/index.xml rel=me title=Rss><i data-feather=rss></i></a>
<a class=border></a></div><div class=footer-info>2024 © chuj | Based on <a href=https://github.com/athul/archie>Archie</a> | Built with <a href=https://gohugo.io>Hugo</a> | <a href=#>Goto Top</a></div></footer><script>feather.replace()</script></div></body></html>