<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>ptmalloc 之 sysmalloc 分析 - blog of chuj</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="最近这段时间是考试周，所以 kernel pwn 的学习我暂时放了下来，先做一点体力活，一直不了解 ptmalloc 怎么通过系统调用增加内存池大小的，这里分析一下。、 我们知道，"><meta property="og:image" content><meta property="og:title" content="ptmalloc 之 sysmalloc 分析"><meta property="og:description" content="最近这段时间是考试周，所以 kernel pwn 的学习我暂时放了下来，先做一点体力活，一直不了解 ptmalloc 怎么通过系统调用增加内存池大小的，这里分析一下。、 我们知道，"><meta property="og:type" content="article"><meta property="og:url" content="https://chujdk.github.io/pwnreview/1418.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-22T18:07:00+00:00"><meta property="article:modified_time" content="2021-06-22T18:07:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="ptmalloc 之 sysmalloc 分析"><meta name=twitter:description content="最近这段时间是考试周，所以 kernel pwn 的学习我暂时放了下来，先做一点体力活，一直不了解 ptmalloc 怎么通过系统调用增加内存池大小的，这里分析一下。、 我们知道，"><script src=https://chujdk.github.io/js/feather.min.js></script>
<link href=https://chujdk.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://chujdk.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://chujdk.github.io/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://chujdk.github.io/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>ptmalloc 之 sysmalloc 分析</h1><div class=meta>Posted on Jun 22, 2021</div></div><section class=body><p>最近这段时间是考试周，所以 kernel pwn 的学习我暂时放了下来，先做一点体力活，一直不了解 ptmalloc 怎么通过系统调用增加内存池大小的，这里分析一下。、</p><p>我们知道，malloc 在以 top_chunk 无法满足申请为主的一些情况下会通过 sysmalloc 申请。</p><p>函数头定义了一些变量，其意义都有注释</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>void</span> <span style=color:#666>*</span>
</span></span><span style=display:flex><span><span style=color:#06287e>sysmalloc</span> (INTERNAL_SIZE_T nb, mstate av)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  mchunkptr old_top;              <span style=color:#60a0b0;font-style:italic>/* incoming value of av-&gt;top */</span>
</span></span><span style=display:flex><span>  INTERNAL_SIZE_T old_size;       <span style=color:#60a0b0;font-style:italic>/* its size */</span>
</span></span><span style=display:flex><span>  <span style=color:#902000>char</span> <span style=color:#666>*</span>old_end;                  <span style=color:#60a0b0;font-style:italic>/* its end address */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#902000>long</span> size;                      <span style=color:#60a0b0;font-style:italic>/* arg to first MORECORE or mmap call */</span>
</span></span><span style=display:flex><span>  <span style=color:#902000>char</span> <span style=color:#666>*</span>brk;                      <span style=color:#60a0b0;font-style:italic>/* return value from MORECORE */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#902000>long</span> correction;                <span style=color:#60a0b0;font-style:italic>/* arg to 2nd MORECORE call */</span>
</span></span><span style=display:flex><span>  <span style=color:#902000>char</span> <span style=color:#666>*</span>snd_brk;                  <span style=color:#60a0b0;font-style:italic>/* 2nd return val */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  INTERNAL_SIZE_T front_misalign; <span style=color:#60a0b0;font-style:italic>/* unusable bytes at front of new space */</span>
</span></span><span style=display:flex><span>  INTERNAL_SIZE_T end_misalign;   <span style=color:#60a0b0;font-style:italic>/* partial page left at end of new space */</span>
</span></span><span style=display:flex><span>  <span style=color:#902000>char</span> <span style=color:#666>*</span>aligned_brk;              <span style=color:#60a0b0;font-style:italic>/* aligned offset into brk */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  mchunkptr p;                    <span style=color:#60a0b0;font-style:italic>/* the allocated/returned chunk */</span>
</span></span><span style=display:flex><span>  mchunkptr remainder;            <span style=color:#60a0b0;font-style:italic>/* remainder from allocation */</span>
</span></span><span style=display:flex><span>  <span style=color:#902000>unsigned</span> <span style=color:#902000>long</span> remainder_size;   <span style=color:#60a0b0;font-style:italic>/* its size */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  size_t pagesize <span style=color:#666>=</span> GLRO (dl_pagesize);
</span></span><span style=display:flex><span>  <span style=color:#902000>bool</span> tried_mmap <span style=color:#666>=</span> <span style=color:#007020>false</span>;
</span></span></code></pre></div><h3 id=尝试-mmap-分配>尝试 MMAP 分配</h3><p>MMAP 分配主要处理新的分配区的 av 的内存分配和大内存（默认为大于等于 128KB）的分配。</p><p>在满足</p><ul><li>申请的大小 nb（normalized byte）大于等于 mmap_threshold</li><li>当前已经通过 mmap 分配的内存块数小于 n_mmaps_max</li></ul><p>的情况下会首先尝试直接通过 mmap 来分配内存。这里的 mmap_threshold 是会根据申请进行一定的改变的，具体的改变流程之后会分析到，其默认的初始值为 128KB。n_mmaps_max 的默认值为 65536。</p><p>另外，特别的，如果当前的分配区指针 av 为 NULL，也就是当前分配区未初始化时也会直接尝试 mmap。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     If have mmap, and the request size meets the mmap threshold, and
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     the system supports mmap, and there are few enough currently
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     allocated mmapped regions, try to directly map this request
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     rather than expanding top.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (av <span style=color:#666>==</span> <span style=color:#007020>NULL</span>
</span></span><span style=display:flex><span>      <span style=color:#666>||</span> ((<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (nb) <span style=color:#666>&gt;=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (mp_.mmap_threshold)
</span></span><span style=display:flex><span>	  <span style=color:#666>&amp;&amp;</span> (mp_.n_mmaps <span style=color:#666>&lt;</span> mp_.n_mmaps_max)))
</span></span><span style=display:flex><span>    {
</span></span></code></pre></div><p>由于 mmap 需要页对齐，所以这里需要重新计算 size</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>      <span style=color:#902000>char</span> <span style=color:#666>*</span>mm;           <span style=color:#60a0b0;font-style:italic>/* return value from mmap call*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#002070;font-weight:700>try_mmap</span>:
</span></span><span style=display:flex><span>      <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         Round up size to nearest page.  For mmapped chunks, the overhead
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         is one SIZE_SZ unit larger than for normal chunks, because there
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         is no following chunk whose prev_size field could be used.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         See the front_misalign handling below, for glibc there is no
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         need for further alignments unless we have have high alignment.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>       */</span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (MALLOC_ALIGNMENT <span style=color:#666>==</span> CHUNK_HDR_SZ)
</span></span><span style=display:flex><span>        size <span style=color:#666>=</span> ALIGN_UP (nb <span style=color:#666>+</span> SIZE_SZ, pagesize);
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>        size <span style=color:#666>=</span> ALIGN_UP (nb <span style=color:#666>+</span> SIZE_SZ <span style=color:#666>+</span> MALLOC_ALIGN_MASK, pagesize);
</span></span></code></pre></div><p>这里的 ALIGN_UP 宏的定义为，做的就是与 pagesize 对齐</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* Align a value by rounding up to closest size.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   e.g. Using size of 4096, we get this behavior:
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	{4095, 4096, 4097} = {4096, 4096, 8192}.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>  Note: The size argument has side effects (expanded multiple times).  */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#define ALIGN_UP(base, size)	ALIGN_DOWN ((base) + (size) - 1, (size))
</span></span></span></code></pre></div><p>由于 nb 的计算是考虑了下个 chunk 的空间复用的，所以这里在计算时需要把复用的这一个字长也加上去。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>      tried_mmap <span style=color:#666>=</span> <span style=color:#007020>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#60a0b0;font-style:italic>/* Don&#39;t try if size wraps around 0 */</span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> ((<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (size) <span style=color:#666>&gt;</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (nb))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          mm <span style=color:#666>=</span> (<span style=color:#902000>char</span> <span style=color:#666>*</span>) (MMAP (<span style=color:#40a070>0</span>, size,
</span></span><span style=display:flex><span>			       MTAG_MMAP_FLAGS <span style=color:#666>|</span> PROT_READ <span style=color:#666>|</span> PROT_WRITE, <span style=color:#40a070>0</span>));
</span></span></code></pre></div><p>然后检测 size 是否大于 nb，如果 size 比 nb 要小，就说明 nb 过大导致了溢出，此时不进行 mmap 分配，否则调用 MMAP 进行分配，给予内存断可读写的属性。（这里的 MTAG_MMAP_FLAGS 默认为 0，也就是无影响）。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (mm <span style=color:#666>!=</span> MAP_FAILED)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>                 The offset to the start of the mmapped region is stored
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>                 in the prev_size field of the chunk. This allows us to adjust
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>                 returned start address to meet alignment requirements here
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>                 and in memalign(), and still be able to compute proper
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>                 address argument for later munmap in free() and realloc().
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>               */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>if</span> (MALLOC_ALIGNMENT <span style=color:#666>==</span> CHUNK_HDR_SZ)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                  <span style=color:#60a0b0;font-style:italic>/* For glibc, chunk2rawmem increases the address by
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>                     CHUNK_HDR_SZ and MALLOC_ALIGN_MASK is
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>                     CHUNK_HDR_SZ-1.  Each mmap&#39;ed area is page
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>                     aligned and therefore definitely
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>                     MALLOC_ALIGN_MASK-aligned.  */</span>
</span></span><span style=display:flex><span>                  assert (((INTERNAL_SIZE_T) chunk2rawmem (mm) <span style=color:#666>&amp;</span> MALLOC_ALIGN_MASK) <span style=color:#666>==</span> <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>                  front_misalign <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>                front_misalign <span style=color:#666>=</span> (INTERNAL_SIZE_T) chunk2rawmem (mm) <span style=color:#666>&amp;</span> MALLOC_ALIGN_MASK;
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>if</span> (front_misalign <span style=color:#666>&gt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                  correction <span style=color:#666>=</span> MALLOC_ALIGNMENT <span style=color:#666>-</span> front_misalign;
</span></span><span style=display:flex><span>                  p <span style=color:#666>=</span> (mchunkptr) (mm <span style=color:#666>+</span> correction);
</span></span><span style=display:flex><span>		  set_prev_size (p, correction);
</span></span><span style=display:flex><span>                  set_head (p, (size <span style=color:#666>-</span> correction) <span style=color:#666>|</span> IS_MMAPPED);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                  p <span style=color:#666>=</span> (mchunkptr) mm;
</span></span><span style=display:flex><span>		  set_prev_size (p, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>                  set_head (p, size <span style=color:#666>|</span> IS_MMAPPED);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#60a0b0;font-style:italic>/* update statistics */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#902000>int</span> <span style=color:#007020;font-weight:700>new</span> <span style=color:#666>=</span> atomic_exchange_and_add (<span style=color:#666>&amp;</span>mp_.n_mmaps, <span style=color:#40a070>1</span>) <span style=color:#666>+</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>              atomic_max (<span style=color:#666>&amp;</span>mp_.max_n_mmaps, <span style=color:#007020;font-weight:700>new</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#902000>unsigned</span> <span style=color:#902000>long</span> sum;
</span></span><span style=display:flex><span>              sum <span style=color:#666>=</span> atomic_exchange_and_add (<span style=color:#666>&amp;</span>mp_.mmapped_mem, size) <span style=color:#666>+</span> size;
</span></span><span style=display:flex><span>              atomic_max (<span style=color:#666>&amp;</span>mp_.max_mmapped_mem, sum);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              check_chunk (av, p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>chunk2mem</span> (p);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>MMAP 在分配失败是会返回 -1，这里首先判断 MMAP 是否失败，如果失败，结束 MMAP 分配尝试。如果成功，则进行 chunk 地址修正（在 libc 2.26 之后 32 位程序的对齐也变成了 0x10 对齐，在这里就需要进行修正），然后设置此 chunk 的 prev_size 字段和 size 字段，设置 IS_MMAPPED 位为 1。</p><p>然后更新 mp_ 中的两个参数，也就是 max_n_mmaps 和 max_mmaped_mem，前者维护 mmap 的 chunk 的个数的最大值（n_mmaps_max 记录的是上限，max_n_mmaps 记录的则是整个执行流程中 mmap 的 chunk 的个数的最大值）；后者维护所有 mmap 的 chunk 的大小的最大值。</p><p>MMAP 失败后会对 av 进行检测，如果调用此 sysmalloc 的目的为为新的分配区分配内存，那么结束流程并返回 0 代表分配失败。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/* There are no usable arenas and mmap also failed.  */</span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (av <span style=color:#666>==</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span></code></pre></div><h3 id=扩展-top-chunk>扩展 Top Chunk</h3><p>如果不满足 MMAP 的条件或是 MMAP 失败，就会尝试扩展 top chunk，首先会通过局部变量记录下旧的 top chunk 的信息，然后检测 top chunk 的合法性。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/* Record incoming configuration of top */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  old_top <span style=color:#666>=</span> av<span style=color:#666>-&gt;</span>top;
</span></span><span style=display:flex><span>  old_size <span style=color:#666>=</span> chunksize (old_top);
</span></span><span style=display:flex><span>  old_end <span style=color:#666>=</span> (<span style=color:#902000>char</span> <span style=color:#666>*</span>) (chunk_at_offset (old_top, old_size));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  brk <span style=color:#666>=</span> snd_brk <span style=color:#666>=</span> (<span style=color:#902000>char</span> <span style=color:#666>*</span>) (MORECORE_FAILURE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     If not the first time through, we require old_size to be
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     at least MINSIZE and to have prev_inuse set.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert ((old_top <span style=color:#666>==</span> initial_top (av) <span style=color:#666>&amp;&amp;</span> old_size <span style=color:#666>==</span> <span style=color:#40a070>0</span>) <span style=color:#666>||</span>
</span></span><span style=display:flex><span>          ((<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (old_size) <span style=color:#666>&gt;=</span> MINSIZE <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>           prev_inuse (old_top) <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>           ((<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) old_end <span style=color:#666>&amp;</span> (pagesize <span style=color:#666>-</span> <span style=color:#40a070>1</span>)) <span style=color:#666>==</span> <span style=color:#40a070>0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/* Precondition: not enough current space to satisfy nb request */</span>
</span></span><span style=display:flex><span>  assert ((<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (old_size) <span style=color:#666>&lt;</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) (nb <span style=color:#666>+</span> MINSIZE));
</span></span></code></pre></div><p>可以看出第一个断言的检查分两种情况</p><ol><li>top chunk 未初始化，这个时候满足旧的 top chunk 是第一个 unsorted bin 并且其大小为 0 即可</li><li>top chunk 已初始化，此时需要满足<ol><li>旧 top chunk 的大小大于 MINSIZE</li><li>旧 top chunk 的 prev_inuse 位为 1</li><li>旧 top chunk 页对齐</li></ol></li></ol><p>第二个断言检查旧 top chunk 是否的确无法满足申请。</p><h4 id=非主分配区>非主分配区</h4><p>对于非主分配区而言，会使用 grow_heap 这个函数来对当前分配区的可读可写内存段进行扩张。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (av <span style=color:#666>!=</span> <span style=color:#666>&amp;</span>main_arena)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      heap_info <span style=color:#666>*</span>old_heap, <span style=color:#666>*</span>heap;
</span></span><span style=display:flex><span>      size_t old_heap_size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#60a0b0;font-style:italic>/* First try to extend the current heap. */</span>
</span></span><span style=display:flex><span>      old_heap <span style=color:#666>=</span> heap_for_ptr (old_top);
</span></span><span style=display:flex><span>      old_heap_size <span style=color:#666>=</span> old_heap<span style=color:#666>-&gt;</span>size;
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> ((<span style=color:#902000>long</span>) (MINSIZE <span style=color:#666>+</span> nb <span style=color:#666>-</span> old_size) <span style=color:#666>&gt;</span> <span style=color:#40a070>0</span>
</span></span><span style=display:flex><span>          <span style=color:#666>&amp;&amp;</span> grow_heap (old_heap, MINSIZE <span style=color:#666>+</span> nb <span style=color:#666>-</span> old_size) <span style=color:#666>==</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          av<span style=color:#666>-&gt;</span>system_mem <span style=color:#666>+=</span> old_heap<span style=color:#666>-&gt;</span>size <span style=color:#666>-</span> old_heap_size;
</span></span><span style=display:flex><span>          set_head (old_top, (((<span style=color:#902000>char</span> <span style=color:#666>*</span>) old_heap <span style=color:#666>+</span> old_heap<span style=color:#666>-&gt;</span>size) <span style=color:#666>-</span> (<span style=color:#902000>char</span> <span style=color:#666>*</span>) old_top)
</span></span><span style=display:flex><span>                    <span style=color:#666>|</span> PREV_INUSE);
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>grow_heap 函数的定义为</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>int</span>
</span></span><span style=display:flex><span><span style=color:#06287e>grow_heap</span> (heap_info <span style=color:#666>*</span>h, <span style=color:#902000>long</span> diff)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  size_t pagesize <span style=color:#666>=</span> GLRO (dl_pagesize);
</span></span><span style=display:flex><span>  <span style=color:#902000>long</span> new_size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  diff <span style=color:#666>=</span> ALIGN_UP (diff, pagesize);
</span></span><span style=display:flex><span>  new_size <span style=color:#666>=</span> (<span style=color:#902000>long</span>) h<span style=color:#666>-&gt;</span>size <span style=color:#666>+</span> diff;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> ((<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) new_size <span style=color:#666>&gt;</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) HEAP_MAX_SIZE)
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> ((<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) new_size <span style=color:#666>&gt;</span> h<span style=color:#666>-&gt;</span>mprotect_size)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (__mprotect ((<span style=color:#902000>char</span> <span style=color:#666>*</span>) h <span style=color:#666>+</span> h<span style=color:#666>-&gt;</span>mprotect_size,
</span></span><span style=display:flex><span>                      (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) new_size <span style=color:#666>-</span> h<span style=color:#666>-&gt;</span>mprotect_size,
</span></span><span style=display:flex><span>                      MTAG_MMAP_FLAGS <span style=color:#666>|</span> PROT_READ <span style=color:#666>|</span> PROT_WRITE) <span style=color:#666>!=</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span><span style=color:#40a070>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      h<span style=color:#666>-&gt;</span>mprotect_size <span style=color:#666>=</span> new_size;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  h<span style=color:#666>-&gt;</span>size <span style=color:#666>=</span> new_size;
</span></span><span style=display:flex><span>  LIBC_PROBE (memory_heap_more, <span style=color:#40a070>2</span>, h, h<span style=color:#666>-&gt;</span>size);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可见其主要是通过 __mprotect 来进行扩张，扩张时也是页对齐的。</p><p>如果扩张成功，更新分配区 av 的 system_mem 并更新此 top chunk 的 size 字段。</p><p>如果通过 grow_heap 扩张失败，就会尝试通过 new_heap 函数来申请一个新的堆</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>      <span style=color:#007020;font-weight:700>else</span> <span style=color:#06287e>if</span> ((heap <span style=color:#666>=</span> new_heap (nb <span style=color:#666>+</span> (MINSIZE <span style=color:#666>+</span> <span style=color:#007020;font-weight:700>sizeof</span> (<span style=color:#666>*</span>heap)), mp_.top_pad)))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#60a0b0;font-style:italic>/* Use a newly allocated heap.  */</span>
</span></span><span style=display:flex><span>          heap<span style=color:#666>-&gt;</span>ar_ptr <span style=color:#666>=</span> av;
</span></span><span style=display:flex><span>          heap<span style=color:#666>-&gt;</span>prev <span style=color:#666>=</span> old_heap;
</span></span><span style=display:flex><span>          av<span style=color:#666>-&gt;</span>system_mem <span style=color:#666>+=</span> heap<span style=color:#666>-&gt;</span>size;
</span></span><span style=display:flex><span>          <span style=color:#60a0b0;font-style:italic>/* Set up the new top.  */</span>
</span></span><span style=display:flex><span>          top (av) <span style=color:#666>=</span> chunk_at_offset (heap, <span style=color:#007020;font-weight:700>sizeof</span> (<span style=color:#666>*</span>heap));
</span></span><span style=display:flex><span>          set_head (top (av), (heap<span style=color:#666>-&gt;</span>size <span style=color:#666>-</span> <span style=color:#007020;font-weight:700>sizeof</span> (<span style=color:#666>*</span>heap)) <span style=color:#666>|</span> PREV_INUSE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#60a0b0;font-style:italic>/* Setup fencepost and free the old top chunk with a multiple of
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>             MALLOC_ALIGNMENT in size. */</span>
</span></span><span style=display:flex><span>          <span style=color:#60a0b0;font-style:italic>/* The fencepost takes at least MINSIZE bytes, because it might
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>             become the top chunk again later.  Note that a footer is set
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>             up, too, although the chunk is marked in use. */</span>
</span></span><span style=display:flex><span>          old_size <span style=color:#666>=</span> (old_size <span style=color:#666>-</span> MINSIZE) <span style=color:#666>&amp;</span> <span style=color:#666>~</span>MALLOC_ALIGN_MASK;
</span></span><span style=display:flex><span>          set_head (chunk_at_offset (old_top, old_size <span style=color:#666>+</span> CHUNK_HDR_SZ),
</span></span><span style=display:flex><span>		    <span style=color:#40a070>0</span> <span style=color:#666>|</span> PREV_INUSE);
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>if</span> (old_size <span style=color:#666>&gt;=</span> MINSIZE)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              set_head (chunk_at_offset (old_top, old_size),
</span></span><span style=display:flex><span>			CHUNK_HDR_SZ <span style=color:#666>|</span> PREV_INUSE);
</span></span><span style=display:flex><span>              set_foot (chunk_at_offset (old_top, old_size), CHUNK_HDR_SZ);
</span></span><span style=display:flex><span>              set_head (old_top, old_size <span style=color:#666>|</span> PREV_INUSE <span style=color:#666>|</span> NON_MAIN_ARENA);
</span></span><span style=display:flex><span>              _int_free (av, old_top, <span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              set_head (old_top, (old_size <span style=color:#666>+</span> CHUNK_HDR_SZ) <span style=color:#666>|</span> PREV_INUSE);
</span></span><span style=display:flex><span>              set_foot (old_top, (old_size <span style=color:#666>+</span> CHUNK_HDR_SZ));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>若通过 new_heap 申请成功，更新分配区 av 的信息，并把新的 sub_heap 链入此分配区的 sub_heap 链表中，并设置新旧 top chunk 的 fencepost。</p><p>如果通过 new_heap 操作申请失败，并且之前没有进行过 mmap 的尝试，会尝试使用 mmap 进行一次分配。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>      <span style=color:#007020;font-weight:700>else</span> <span style=color:#06287e>if</span> (<span style=color:#666>!</span>tried_mmap)
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* We can at least try to use to mmap memory.  */</span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>goto</span> try_mmap;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=主分配区>主分配区</h3><p>如果当前分配区为主分配区，执行如下流程进行分配，首先计算 size 的大小，size 也为页对齐，这里的 top_pad 的默认值为 0x20000。然后还要根据主分配区是否连续对 size 进行修正。由于主分配区常常通过 sbrk 实现内存的分配，而 sbrk 可以返回连续的虚拟地址，这个时候主分配区就是连续的。如果连续则可复用旧的 top_chunk，所以需要剪掉旧的 top_chunk size。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#007020;font-weight:700>else</span>     <span style=color:#60a0b0;font-style:italic>/* av == main_arena */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    { <span style=color:#60a0b0;font-style:italic>/* Request enough space for nb + pad + overhead */</span>
</span></span><span style=display:flex><span>      size <span style=color:#666>=</span> nb <span style=color:#666>+</span> mp_.top_pad <span style=color:#666>+</span> MINSIZE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         If contiguous, we can subtract out existing space that we hope to
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         combine with new space. We add it back later only if
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         we don&#39;t actually get contiguous space.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>       */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (contiguous (av))
</span></span><span style=display:flex><span>        size <span style=color:#666>-=</span> old_size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         Round to a multiple of page size.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         If MORECORE is not contiguous, this ensures that we only call it
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         with whole-page arguments.  And if MORECORE is contiguous and
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         this is not first time through, this preserves page-alignment of
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>         previous calls. Otherwise, we correct to page-align below.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>       */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      size <span style=color:#666>=</span> ALIGN_UP (size, pagesize);
</span></span></code></pre></div></section><div class=post-tags></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/jchu95495236 rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a></div><div class=footer-info>2023 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>