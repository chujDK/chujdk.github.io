<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>COOL 语义分析器实现 - blog of chuj</title><link rel=icon type=image/png href=https://chujdk.github.io/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="COOL 的语义分析主要对作用域和类型做了检测，这是两个必要的检测。未定义或重复定义的变量会对代码生成造成影响；类型不匹配也会造成各种未定义行为。
作用域
语义分析中需要对每个标识符（变量、函数）做检测，主要需要检查是否有未定义的标识符和重复定义的标识符。以 COOL 为例，通过维护一个符号表即可实现检测。这个检测过程可能需要对 AST 进行多次遍历，因为在 COOL 中，全局变量可以在声明前引用，所以至少需要先遍历一次并记录所有的全局变量，这样在第二次遍历时就可以正确判断变量是否有定义。"><meta property="og:image" content><meta property="og:url" content="https://chujdk.github.io/dev/1548.html"><meta property="og:site_name" content="blog of chuj"><meta property="og:title" content="COOL 语义分析器实现"><meta property="og:description" content="COOL 的语义分析主要对作用域和类型做了检测，这是两个必要的检测。未定义或重复定义的变量会对代码生成造成影响；类型不匹配也会造成各种未定义行为。
作用域 语义分析中需要对每个标识符（变量、函数）做检测，主要需要检查是否有未定义的标识符和重复定义的标识符。以 COOL 为例，通过维护一个符号表即可实现检测。这个检测过程可能需要对 AST 进行多次遍历，因为在 COOL 中，全局变量可以在声明前引用，所以至少需要先遍历一次并记录所有的全局变量，这样在第二次遍历时就可以正确判断变量是否有定义。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-06T01:20:00+00:00"><meta property="article:modified_time" content="2021-09-06T01:20:00+00:00"><meta property="article:tag" content="Compilers"><meta name=twitter:card content="summary"><meta name=twitter:title content="COOL 语义分析器实现"><meta name=twitter:description content="COOL 的语义分析主要对作用域和类型做了检测，这是两个必要的检测。未定义或重复定义的变量会对代码生成造成影响；类型不匹配也会造成各种未定义行为。
作用域 语义分析中需要对每个标识符（变量、函数）做检测，主要需要检查是否有未定义的标识符和重复定义的标识符。以 COOL 为例，通过维护一个符号表即可实现检测。这个检测过程可能需要对 AST 进行多次遍历，因为在 COOL 中，全局变量可以在声明前引用，所以至少需要先遍历一次并记录所有的全局变量，这样在第二次遍历时就可以正确判断变量是否有定义。"><script src=https://chujdk.github.io/js/feather.min.js></script><link href=https://chujdk.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://chujdk.github.io/css/main.6dc922b4122291f1967a53b3e802e564596ed5068a8571e4221c9ead17563c3a.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://chujdk.github.io/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://chujdk.github.io/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>COOL 语义分析器实现</h1><div class=meta>Posted on Sep 6, 2021</div></div><section class=body><p>COOL 的语义分析主要对作用域和类型做了检测，这是两个必要的检测。未定义或重复定义的变量会对代码生成造成影响；类型不匹配也会造成各种未定义行为。</p><h2 id=作用域>作用域</h2><p>语义分析中需要对每个标识符（变量、函数）做检测，主要需要检查是否有未定义的标识符和重复定义的标识符。以 COOL 为例，通过维护一个符号表即可实现检测。这个检测过程可能需要对 AST 进行多次遍历，因为在 COOL 中，全局变量可以在声明前引用，所以至少需要先遍历一次并记录所有的全局变量，这样在第二次遍历时就可以正确判断变量是否有定义。</p><p>然后需要进行第二次遍历来处理每个变量的定义情况。考虑三个操作</p><ul><li><code>search_symbol(identifier)</code>，搜索符号表，在<strong>第一次</strong>找到符号时返回</li><li><code>add_symol(identifier)</code>，向符号表中添加标识符</li><li><code>delete_symbol(identifier)</code>，从符号表中删除标识符</li></ul><p>由此已经可以判断标识符是否被定义，全局标识符已在第一次遍历时处理好了，每次遇到局部变量定义时就将该标识符加入到符号表中。碰到任何标识符时只要调用 <code>search_symbol</code> 就可以判断符号是否被定义。注意这里的第一次找到可以实现最小作用域原则，也就是对于</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#002070;font-weight:700>x</span>:Int;
</span></span><span style=display:flex><span>    ..
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>    	<span style=color:#002070;font-weight:700>x</span>:Int;
</span></span><span style=display:flex><span>        ..
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在内层语句块中引用 <code>x</code> 时，将会引用在内层定义的 <code>x</code>。当然为了保证第一次找到的标识符是内层的，需要把符号表做成后进先出。</p><p>不过仅有上面三个操作会造成嵌套定义不合法，因为对符号表的查找没有分层，会一路查到最顶层，也就是上面的代码也会被检测出错。虽然我们一般会避免嵌套定义，但是从语法上来讲这是允许的，所以我们的符号表需要支持嵌套的定义，如此就需要添加两个功能</p><ul><li><code>enter_scope()</code> 进入一个新的嵌套作用域层级</li><li><code>exit_scope()</code> 离开当前的作用域嵌套层级</li></ul><p>然后 <code>search_symbol</code> 同样的也需要改为在当前嵌套层级搜索，当该层级搜索不到时才应该向低层级搜索，这里的返回结果一个有区别，这样才能良好地判断定义的有效性，考虑这样的代码</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#002070;font-weight:700>x</span>:Int;
</span></span><span style=display:flex><span>    <span style=color:#002070;font-weight:700>x</span>:Int;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在同一作用域中重复定义了两次 <code>x</code>，这是不允许的，我们的符号表已经可以完成这个判断了：</p><p>在第一次发现 <code>x</code> 时搜索符号表，返回值告知我们当前作用域中没有 <code>x</code>，所以将它加入到符号表，然后第二次发现 <code>x</code> 时再搜索符号表，返回值告知当前作用域已经有了 <code>x</code>，由此就可以报错了。</p><p>同时这个符号表将不同嵌套层级分离，所以对于</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#002070;font-weight:700>x</span>:Int;
</span></span><span style=display:flex><span>    ..
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>    	<span style=color:#002070;font-weight:700>x</span>:Int;
</span></span><span style=display:flex><span>        ..
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样的代码，<code>search_symbol</code> 会告知我们虽然找到了 <code>x</code>，但是 <code>x</code> 不在当前作用域，所以不会报错。</p><h2 id=类型>类型</h2><p>类型检测和类型推导其实是不一样的东西，但是许多地方都把两者混淆，不过这其实没有问题，因为为了检测类型，必然要做类型推导，而类型推导也（一部分）是为了检测类型。为了形式化地描述类型规则，慕课中使用了逻辑推理规则来描述，在 cool-manual 12.2 中可以看到全部规则。</p><h2 id=实现>实现</h2><p>我对 AST 进行了四次遍历，完成类型判断和变量重复定义的检测，总结如下：</p><ol><li>pass one：构建全局符号表同，判断类是否有重复定义。</li><li>pass two：构建继承图</li><li>判断是否存在继承错误（即环状继承）</li><li>pass three：构建方法、属性表，判断是否有重复定义</li><li>pass four：进行类型推导和判断</li></ol><p>需要注意的是对于继承需要把基类的成员和方法都添加到子类的符号表中。</p><p>代码挺长的，我写的也挺烂的（越往后越觉得自己写的烂），我把他们放到了 <a href=https://github.com/chujDK/mycool-compiler/tree/main/PA4>GitHub</a> 上。</p><p>在 <code>cool-tree.h</code> 中主要添加了许多 getter 方法，便于 typing 时对表达式等的处理。<code>symtab.h</code> 是慕课提供的一个符号表类模板，我给他添加了一个构造函数</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>   <span style=color:#60a0b0;font-style:italic>// this is added by me, for my need
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>   SymbolTable<span style=color:#666>&lt;</span>SYM, DAT<span style=color:#666>&gt;</span> (<span style=color:#007020;font-weight:700>const</span> SymbolTable<span style=color:#666>&lt;</span>SYM, DAT<span style=color:#666>&gt;&amp;</span> table) { tbl <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>new</span> ScopeList((Scope <span style=color:#666>*</span>) <span style=color:#007020>NULL</span>, table.tbl); exitscope(); }
</span></span></code></pre></div><p>主要是为了继承时对符号表的处理。</p><p><code>semant.cc</code> 和 <code>semant.h</code> 就是核心代码了。</p><p>我不准备具体说实现，一方面自己写的这么烂也不好意思多指点江山，另一方面其实大体定下了识别的过程后实现就只是体力活了。</p><p>前段时间在游戏上花了许多时间，最近几天就一直在弄这个分析器，所以博客也是有一段时间没更新了。写了大概有六天吧，从一脸懵到胸有成竹再到最后完全实现，虽然挺累的，但是很有成就感，很值得。</p><p>在最后，自然还是用 <code>life.cl</code> 来测试一下啦</p><p><img src=https://chujdk.github.io/usr/uploads/2021/09/154678596.png alt=cheers！></p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/compilers>compilers</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/chujdk rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=mailto:chujj31@gmail.com rel=me title=Mail><i data-feather=mail></i></a>
<a class=border></a><a class=soc href=https://chujdk.github.io/index.xml rel=me title=Rss><i data-feather=rss></i></a>
<a class=border></a></div><div class=footer-info>2024 © chuj | Based on <a href=https://github.com/athul/archie>Archie</a> | Built with <a href=https://gohugo.io>Hugo</a> | <a href=#>Goto Top</a></div></footer><script>feather.replace()</script></div></body></html>