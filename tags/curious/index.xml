<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Curious on blog of chuj</title><link>https://chujdk.github.io/tags/curious.html</link><description>Recent content in Curious on blog of chuj</description><generator>Hugo</generator><language>zh-cn</language><managingEditor>chujj31@gmail.com (chuj)</managingEditor><webMaster>chujj31@gmail.com (chuj)</webMaster><copyright>© chuj</copyright><lastBuildDate>Tue, 03 Aug 2021 09:58:00 +0000</lastBuildDate><atom:link href="https://chujdk.github.io/tags/curious/index.xml" rel="self" type="application/rss+xml"/><item><title>glibc 2.34 malloc 的变化</title><link>https://chujdk.github.io/pwnreview/1512.html</link><pubDate>Tue, 03 Aug 2021 09:58:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1512.html</guid><description>&lt;p>昨天突然发现 glibc 2.34 发布了，虽然偶数版本似乎一般不会发布在稳定发行版中，但是还是挺好奇的，花了几分钟看了看，发现主要的变动是取消了几个 hook。&lt;/p>
&lt;p>首先看原先的 hook 定义处&lt;/p></description></item><item><title>seccomp 中的 bpf</title><link>https://chujdk.github.io/pwnreview/1495.html</link><pubDate>Sat, 24 Jul 2021 15:26:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1495.html</guid><description>&lt;p>学习这个问题的原因是想做 pwnable.tw 的 seccomp-tool 一题，此题的 elf 可以读取、模拟、加载用户输入的 bpf 代码，其中加载使用的是 prctl 系统调用，功能号为 PR_GET_SECCOMP。&lt;/p>
&lt;p>暂时还不知道怎么做，原来觉得应该是通过 bpf 来完成利用，&lt;del>总不会是 elf 某处写渣了的溢出&lt;/del>。由于我对 bpf 和 seccomp 不甚了解，所以先花了点时间了解了一下。了解了之后我感觉还真可能是 elf 本身的洞，在 emulate 功能中，也实现了一个类似于 Linux cbpf 解码器和模拟器的虚拟机，这里的代码还是有一点的，还没来的及看，说不定就是这里存在问题。&lt;/p></description></item><item><title>PWN ARM 环境配置</title><link>https://chujdk.github.io/pwnreview/1353.html</link><pubDate>Tue, 25 May 2021 22:58:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1353.html</guid><description>&lt;p>主要使用的调试方法为：qemu + gdb-multiarch，再交叉编译得到有符号的 libc。&lt;/p>
&lt;h3 id="qemu-安装">qemu 安装&lt;/h3>
&lt;p>直接通过 apt 安装并不是一个很好的选择，因为版本往往不是最新的，而且对调试的支持并不是很好（内存分析的比较一般），我选择通过手动编译安装来安装。&lt;/p></description></item><item><title>ptmalloc 的简单分析</title><link>https://chujdk.github.io/pwnreview/1300.html</link><pubDate>Sun, 23 May 2021 22:42:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1300.html</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>断断续续写了一个多月，终于写完了。写本文的主要目的是获得一个对堆的理性认知，从知其然到知其所以然。主要分析了 __libc_malloc，_int_malloc，__libc_free，_int_free，malloc_consolidate 五个比较长且核心的函数。基本覆盖了较小（即未大到需要进行 sys_malloc）的情况。当然对于较大的请求的处理也是有必要学习的，之后应该会再写一篇。总的来说本文写的比较简略，且略过了对 malloc_chunk 结构体、unlink 函数的介绍，您在看之前应该需要对 ptmalloc 的流程和基础结构已有一定了解。&lt;/p></description></item><item><title>IDA switch 在跳表结构下的修复</title><link>https://chujdk.github.io/mess/1345.html</link><pubDate>Sat, 22 May 2021 22:09:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/mess/1345.html</guid><description>&lt;p>今天协会打了一场内部 AWD，第一次参加这样的比赛，确实有不少手忙脚乱的地方，也有学到许多新知识。&lt;/p>
&lt;p>PWN 总共有两题，其中一题虚拟机类题由于有较大的 switch 结构，而 gcc 在编译超过 5 个 case 的 switch 时就会用跳表来优化，F5 之后一般会变成下面这个样子&lt;/p></description></item><item><title>pwn 白名单绕过总结</title><link>https://chujdk.github.io/pwnreview/1294.html</link><pubDate>Thu, 22 Apr 2021 15:37:10 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1294.html</guid><description>&lt;p>有些时候 pwn 题目中为了增加难度（实际是为了恶心选手），会使用类似 &lt;a href="https://en.wikipedia.org/wiki/Seccomp">seccomp&lt;/a> 的函数来禁用一部分系统调用，往往会把 execve 这种系统调用禁用掉，基本上拿 shell 是不可能了，但是我们 pwn 题是面向 flag 的，所以还是可以通过 orw（ open-read-write ）的方法来读出 flag 的。在栈上的 orw 和 普通 rop 其实没有什么特别大的区别，这里主要谈一谈堆利用中的白名单绕过。&lt;/p></description></item><item><title>unsorted bin 利用的简单总结</title><link>https://chujdk.github.io/pwnreview/1216.html</link><pubDate>Mon, 05 Apr 2021 22:10:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1216.html</guid><description>&lt;p>学习堆利用也有一段时间了，基本上就是在和 fastbin 和 unsorted bin 打交道，最近这段时间 tcache 的题也做了一些。套路居多，想想还是应该总结一下。不会写的太详细，也可能无法写全。&lt;/p></description></item><item><title>如何利用Unsorted Bin泄露Libc基地址</title><link>https://chujdk.github.io/pwnreview/1089.html</link><pubDate>Tue, 16 Feb 2021 17:20:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1089.html</guid><description>&lt;p>这其实是一个很简单很枯燥的问题，许多题中都会用到，但是我发现好像并没有文章以该方法为主角介绍该方法，也没有对其原理做出详细解释。估计是大佬们都觉得这个问题太简单了不愿意费时间来写，而回想过去，做题时总是会记得有这样一个利用方法，但是却找不到具体的利用原理。所以我就来细讲一下这个问题。&lt;/p></description></item><item><title>关于/proc目录</title><link>https://chujdk.github.io/pwnreview/1070.html</link><pubDate>Tue, 09 Feb 2021 15:29:41 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1070.html</guid><description>&lt;p>&lt;code>/proc&lt;/code> 这个目录很牛，充满了信息&lt;/p>
&lt;p>&lt;code>/proc&lt;/code> 应该说是 &lt;code>Linux&lt;/code> 一切皆文件的设计哲学的体现，其中的文件和目录本身都是虚拟的一个文件系统，提供理一些内核信息。里面的有些文件很有些用处，这里简单列举一下&lt;/p></description></item><item><title>学习 pwn 的过程中的一点心得</title><link>https://chujdk.github.io/pwnreview/%E6%88%91%E7%9A%84pwn%E5%BF%83%E5%BE%97.html</link><pubDate>Sat, 21 Nov 2020 22:01:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/%E6%88%91%E7%9A%84pwn%E5%BF%83%E5%BE%97.html</guid><description>&lt;h3 id="值得注意的东西">值得注意的东西&lt;/h3>
&lt;h4 id="与exp的动调">与exp的动调&lt;/h4>
&lt;p>在 exp 中先指定 terminal，即添加一句&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>context&lt;span style="color:#666">.&lt;/span>terminal &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#4070a0">&amp;#39;tmux&amp;#39;&lt;/span>,&lt;span style="color:#4070a0">&amp;#39;splitw&amp;#39;&lt;/span>,&lt;span style="color:#4070a0">&amp;#39;-h&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在创建进程变量后，添加&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>gdb&lt;span style="color:#666">.&lt;/span>attach(proc&lt;span style="color:#666">.&lt;/span>pidof(sh)[&lt;span style="color:#40a070">0&lt;/span>]) &lt;span style="color:#60a0b0;font-style:italic">#这里的sh是进程变量&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样调试时先打开tmux，然后就可以动态调试了&lt;/p>
&lt;h4 id="加载指定的libc">加载指定的libc：&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>io &lt;span style="color:#666">=&lt;/span> process([&lt;span style="color:#4070a0">&amp;#39;./bin&amp;#39;&lt;/span>],env&lt;span style="color:#666">=&lt;/span> {&lt;span style="color:#4070a0">&amp;#34;LD_PRELOAD&amp;#34;&lt;/span>:&lt;span style="color:#4070a0">&amp;#34;./libc-2.23.so&amp;#34;&lt;/span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="可能很有用的东西">可能很有用的东西&lt;/h4>
&lt;p>&lt;a href="https://blog.csdn.net/mrhesongze/article/details/81980397">gdb 调试二进制和符号表分开的程序&lt;/a>&lt;/p></description></item></channel></rss>