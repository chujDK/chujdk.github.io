<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kernel-Pwn on blog of chuj</title><link>https://chujdk.github.io/tags/kernel-pwn.html</link><description>Recent content in Kernel-Pwn on blog of chuj</description><generator>Hugo</generator><language>zh-cn</language><managingEditor>chujj31@gmail.com (chuj)</managingEditor><webMaster>chujj31@gmail.com (chuj)</webMaster><copyright>© chuj</copyright><lastBuildDate>Mon, 09 Jun 2025 10:03:43 +0800</lastBuildDate><atom:link href="https://chujdk.github.io/tags/kernel-pwn/index.xml" rel="self" type="application/rss+xml"/><item><title>fuse + {get,set}xattr 利用模板</title><link>https://chujdk.github.io/mess/fuse--getsetxattr-%E5%88%A9%E7%94%A8%E6%A8%A1%E6%9D%BF.html</link><pubDate>Mon, 09 Jun 2025 10:03:43 +0800</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/mess/fuse--getsetxattr-%E5%88%A9%E7%94%A8%E6%A8%A1%E6%9D%BF.html</guid><description>&lt;h2 id="起因"&gt;起因&lt;/h2&gt;
&lt;p&gt;最近由于一些原因，需要使用 fuse + getxattr 这个 gadget。关于这种方法，可以参考这两篇文章：&lt;a href="https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#setxattr-userfaultfd-FUSE-%E5%A0%86%E5%8D%A0%E4%BD%8D%E6%8A%80%E6%9C%AF"&gt;ref1&lt;/a&gt;，&lt;a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#FUSE-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"&gt;ref2&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#FUSE-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"&gt;ref2&lt;/a&gt; 里面有给出一个模板，但是遗憾的是此模板使用的是 libfuse 提供的类 VFS 接口。使用 libfuse 就需要我们能够把 libfuse 的库链接到 exp 中，许多时候这并非太大的难度，但是有些时候这样比较麻烦。&lt;/p&gt;</description></item><item><title>CVE-2022-34918</title><link>https://chujdk.github.io/wp/1663.html</link><pubDate>Thu, 09 Mar 2023 00:15:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/wp/1663.html</guid><description>&lt;h2 id="netfilter-iptables-nftables"&gt;&lt;span class="section-num"&gt;1&lt;/span&gt; netfilter/iptables/nftables&lt;/h2&gt;
&lt;p&gt;这里简述一下 netfilter 和 iptables 和 nftables 之间的关系，我对网络的了解甚少，所以在看代码的时候三者的关系给了我不少困扰。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;netfilter&lt;/code&gt; 是内核中的软件框架，用于网络操作。它提供了许多与数据包过滤，网络地址转换（NAT, Network Address Translation）和端口转发相关的操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nftables&lt;/code&gt; 是内核中的一个子系统，提供了对数据包、帧、报的过滤和分类。旨在取代 &lt;code&gt;netfilter&lt;/code&gt; 的 &lt;code&gt;iptables&lt;/code&gt; 部分。他的用户态管理工具为 &lt;code&gt;nft&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables&lt;/code&gt; 是一个用户态程序，可以让系统管理员来配置 ip 数据包的过滤规则。通过一个 &lt;code&gt;netfilter&lt;/code&gt; 模块实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上可以看出， &lt;code&gt;nft&lt;/code&gt; 和 &lt;code&gt;iptables&lt;/code&gt; 是同类型工具，用于用户的配置。 &lt;code&gt;nftables&lt;/code&gt; 和 &lt;code&gt;iptables&lt;/code&gt; 的内核模块同类型，是 &lt;code&gt;nft&lt;/code&gt; 和 &lt;code&gt;iptables&lt;/code&gt; 这样的工具的“背后的引擎”。他们都是 &lt;code&gt;netfilter&lt;/code&gt; 的子系统。而 &lt;code&gt;netfilter&lt;/code&gt; 是一个内核的网络软件框架，提供了与网络操作相关的许多接口。&lt;/p&gt;</description></item><item><title>内核堆喷学习——CVE-2021-22555</title><link>https://chujdk.github.io/pwnreview/1659.html</link><pubDate>Tue, 21 Feb 2023 21:21:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1659.html</guid><description>&lt;h2 id="总结"&gt;&lt;span class="section-num"&gt;1&lt;/span&gt; 总结&lt;/h2&gt;
&lt;p&gt;触发漏洞需要 &lt;code&gt;CPA_NET_ADMIN&lt;/code&gt; ，我们先 &lt;code&gt;unshare&lt;/code&gt; 出自己的名称空间，把权限给自己拉满&lt;/p&gt;
&lt;p&gt;漏洞出现在内核的 netfilter 子系统，是一个防火墙系统。用户层中，iptable 即使通过该子系统实现的。&lt;/p&gt;</description></item><item><title>Balsn_CTF_2019-KrazyNote-WP</title><link>https://chujdk.github.io/wp/1480.html</link><pubDate>Mon, 19 Jul 2021 20:57:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/wp/1480.html</guid><description>&lt;p&gt;这道题的利用难度其实比较低，主要的难度在逆向上。说实话，乱七八糟的反编译代码是把我绕惨了。最近这段时间碰到了不少题目都是败在逆向上，我也意识到有必要提高一下逆向水平。&lt;/p&gt;</description></item><item><title>QWB2021-notebook-WP</title><link>https://chujdk.github.io/wp/1468.html</link><pubDate>Thu, 15 Jul 2021 23:16:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/wp/1468.html</guid><description>&lt;p&gt;强网杯的时候我还一点都不会 kernel pwn，这道题看都没看。这两天尝试复现了一下，从前天下午一直弄到现在才搞出来，费了不少时间，也学到了一些东西，特别地，学习到了之前学习 userfaultfd 和 tty attack 时一些自己不知道自己不知道的知识（这里没有打错哦 ^_^）。&lt;/p&gt;</description></item><item><title>D^3CTF2019-knote-WP</title><link>https://chujdk.github.io/wp/1455.html</link><pubDate>Tue, 13 Jul 2021 17:50:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/wp/1455.html</guid><description>&lt;p&gt;本博客的第 200 篇文章，[font color=&amp;quot;#FA8072&amp;quot;] cheer! [/font]&lt;/p&gt;
&lt;p&gt;这道题是老学长 Aris 出的，借着这道题学习了一下用 userfaultfd 机制稳定条件竞争的方法。我确实还是比较菜，又是完全照着 ha1vk 师傅的文章&lt;a href="https://blog.csdn.net/seaaseesa/article/details/104650794?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.control&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.control"&gt;linux kernel pwn学习之条件竞争(二)userfaultfd&lt;/a&gt;学习的。&lt;/p&gt;</description></item><item><title>WCTF2018-klist-WP</title><link>https://chujdk.github.io/wp/1446.html</link><pubDate>Mon, 12 Jul 2021 14:45:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/wp/1446.html</guid><description>&lt;p&gt;本文参考自 ha1vk 师傅的&lt;a href="https://blog.csdn.net/seaaseesa/article/details/104649351?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162599917316780262521691%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;amp;request_id=162599917316780262521691&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-104649351.first_rank_v2_pc_rank_v29&amp;amp;utm_term=linux+kernel+pwn%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89&amp;amp;spm=1018.2226.3001.4187"&gt;linux kernel pwn学习之条件竞争(一)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;借着这道题初步学习了一下 kernel 中条件竞争的利用。本题主要是通过条件竞争造成 UAF，然后通过 pipe_buffer 造成堆喷射实现提权。&lt;/p&gt;</description></item><item><title>*CTF2019-hackme-WP</title><link>https://chujdk.github.io/wp/1433.html</link><pubDate>Thu, 08 Jul 2021 16:08:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/wp/1433.html</guid><description>&lt;p&gt;首先看一下启动参数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;qemu-system-x86_64 &lt;span style="color:#4070a0;font-weight:bold"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#4070a0;font-weight:bold"&gt;&lt;/span&gt; -m 256M &lt;span style="color:#4070a0;font-weight:bold"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#4070a0;font-weight:bold"&gt;&lt;/span&gt; -nographic &lt;span style="color:#4070a0;font-weight:bold"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#4070a0;font-weight:bold"&gt;&lt;/span&gt; -kernel bzImage &lt;span style="color:#4070a0;font-weight:bold"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#4070a0;font-weight:bold"&gt;&lt;/span&gt; -append &lt;span style="color:#4070a0"&gt;&amp;#39;console=ttyS0 loglevel=3 oops=panic panic=1 kaslr&amp;#39;&lt;/span&gt; &lt;span style="color:#4070a0;font-weight:bold"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#4070a0;font-weight:bold"&gt;&lt;/span&gt; -monitor /dev/null &lt;span style="color:#4070a0;font-weight:bold"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#4070a0;font-weight:bold"&gt;&lt;/span&gt; -initrd initramfs.cpio &lt;span style="color:#4070a0;font-weight:bold"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#4070a0;font-weight:bold"&gt;&lt;/span&gt; -smp &lt;span style="color:#bb60d5"&gt;cores&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;4,threads&lt;span style="color:#666"&gt;=&lt;/span&gt;&lt;span style="color:#40a070"&gt;2&lt;/span&gt; &lt;span style="color:#4070a0;font-weight:bold"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#4070a0;font-weight:bold"&gt;&lt;/span&gt; -cpu qemu64,smep,smap 2&amp;gt;/dev/null
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;开启了 kaslr 和 smep，smap。&lt;/p&gt;
&lt;p&gt;这道题是一个堆上溢出造成的 UAF，具体的，在 0x30002 功能，也就是 edit 功能处&lt;/p&gt;</description></item><item><title>Kernel PWN UAF 的利用和调试</title><link>https://chujdk.github.io/pwnreview/1408.html</link><pubDate>Sat, 19 Jun 2021 15:45:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1408.html</guid><description>&lt;p&gt;进行调试，必然是 gdb attach 到 qemu 上了，在启动指令中加入 &lt;code&gt;-S -gdb tcp::1234&lt;/code&gt; 即可启动一个调试口，在一个新的终端中打开 gdb，使用 targe remote :1234 即可 attach 上去。&lt;/p&gt;
&lt;p&gt;光 attach 上去肯定不够，还需要能在恰当的地方打断点，以 CISCN 2017 babydrive 这题为例（题目可以在 &lt;a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/kernel/CISCN2017-babydriver"&gt;ctf-challenge&lt;/a&gt; 上面下到）。&lt;/p&gt;</description></item><item><title>Kernel PWN 环境搭建</title><link>https://chujdk.github.io/pwnreview/1318.html</link><pubDate>Thu, 17 Jun 2021 21:45:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1318.html</guid><description>&lt;p&gt;一直对 kernel pwn 挺感兴趣的，再加上 libc 那里也没什么新东西可学了，简单题没什么做的意义，难题也不会做，所以准备开始学习 kernel pwn。不过可能最近也没办法太深入的学习，总之先把环境搭起来再说。&lt;/p&gt;</description></item></channel></rss>