<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OS on blog of chuj</title><link>https://chujdk.github.io/tags/os.html</link><description>Recent content in OS on blog of chuj</description><generator>Hugo</generator><language>zh-cn</language><managingEditor>chujj31@gmail.com (chuj)</managingEditor><webMaster>chujj31@gmail.com (chuj)</webMaster><copyright>© chuj</copyright><lastBuildDate>Fri, 18 Jun 2021 16:55:00 +0000</lastBuildDate><atom:link href="https://chujdk.github.io/tags/os/index.xml" rel="self" type="application/rss+xml"/><item><title>《操作系统真像还原》简单读后感</title><link>https://chujdk.github.io/os/1407.html</link><pubDate>Fri, 18 Jun 2021 16:55:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/os/1407.html</guid><description>&lt;p&gt;花了大概一个月的时间，看了 12 章，到 13 章硬盘分区驱动这里实在是看不下去了，遂决定不再看这本书了，对其操作系统的实现也告一段落了，就停留在系统调用这里了。这里简单总结一下这一个半月学到的东西和我（几乎）看完本书后的感受。&lt;/p&gt;</description></item><item><title>《操作系统真像还原》操作系统实现——系统调用</title><link>https://chujdk.github.io/os/1402.html</link><pubDate>Mon, 14 Jun 2021 20:46:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/os/1402.html</guid><description>&lt;p&gt;到这里，有了前面的铺垫，要说的东西不多，其实没必要单独写出来，但是系统调用毕竟还是比较重要的东西，所以这里还是单独说一下。&lt;/p&gt;
&lt;p&gt;Linux 下的系统调用占用的是 0x80 号中断，通过 eax 来选择要调用的功能，我们维护一个函数指针数组，存储各个功能的函数指针，然后用一个简单的汇编函数就可以实现调用&lt;/p&gt;</description></item><item><title>《操作系统真像还原》操作系统实现——用户进程</title><link>https://chujdk.github.io/os/1374.html</link><pubDate>Wed, 09 Jun 2021 23:35:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/os/1374.html</guid><description>&lt;p&gt;硬件生产厂商（Intel）给多进程切换提供了硬件级的解决方案，也就是使用 &lt;strong&gt;TSS&lt;/strong&gt;（&lt;strong&gt;Task-Stat Segment&lt;/strong&gt;），令人遗憾的是由于其效率较低，现代操作系统大多没有使用它来进行进程切换，但是特别的，在特权级转移时的栈切换仍然需要通过它来进行，所以虽然我们不用它来切换进程，也仍然需要设置好它。&lt;/p&gt;</description></item><item><title>《操作系统真像还原》操作系统实现——从键盘获取输入和缓冲区</title><link>https://chujdk.github.io/os/1371.html</link><pubDate>Sun, 06 Jun 2021 20:51:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/os/1371.html</guid><description>&lt;p&gt;关于键盘输入我不想写，就是一个和硬件交互的过程，这里主要还是说一下输入输出缓冲区。&lt;/p&gt;
&lt;p&gt;代码已经打好 tag，&lt;a href="https://github.com/chujDK/chuj-elephant-os/releases/tag/basic_input_output"&gt;链接&lt;/a&gt;，比较重要的就是 ioqueue。&lt;/p&gt;
&lt;p&gt;获取键盘输入后，可以直接打出到屏幕上，但是这样除了给用户看看之外没有任何的用处，如果想要让输入有效，就必然需要把输入暂存到一个地方，然后让需要从用户读取的线程读取输入，这就需要一个缓冲区来处理这个问题，&lt;em&gt;Dijkstra&lt;/em&gt; 提出了一个生产者-消费者模型，基于该模型的思想可以有效地解决这个问题。&lt;/p&gt;</description></item><item><title>《操作系统真像还原》操作系统实现——线程和锁</title><link>https://chujdk.github.io/os/1359.html</link><pubDate>Thu, 03 Jun 2021 16:19:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/os/1359.html</guid><description>&lt;p&gt;这篇文章写的比较乱且简略，要看的话建议跟着代码一起看。本文代码在&lt;a href="https://github.com/chujDK/chuj-elephant-os/tree/thread_and_lock"&gt;此处&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;线程和进程是操作系统的重要概念。&lt;/p&gt;
&lt;h3 id="线程和进程的区别"&gt;线程和进程的区别&lt;/h3&gt;
&lt;p&gt;这似乎是一个面试中常见的问题了哈哈哈，这里我可能无法给出教科书级别的解释（实际上那也未必是最好的解释），只写一下自己的理解。&lt;/p&gt;</description></item><item><title>《操作系统真像还原》操作系统实现——内存池管理</title><link>https://chujdk.github.io/os/1349.html</link><pubDate>Tue, 25 May 2021 19:42:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/os/1349.html</guid><description>&lt;p&gt;操作系统需要管理内存页的映射，即虚拟地址和物理地址的映射关系，一种简单的方法是一对一映射，管理起来也比较方便，申请的时候填写页表，释放的时候清空页表就可以了，但是这样就背离了我们引入虚拟地址的初衷。而若想使用乱序映射的映射方法，我们需要用某种数据结构来管理物理内存的使用情况。&lt;/p&gt;</description></item><item><title>《操作系统真像还原》操作系统实现——中断</title><link>https://chujdk.github.io/os/1339.html</link><pubDate>Sun, 23 May 2021 00:15:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/os/1339.html</guid><description>&lt;p&gt;中断这个东西说起来不是很难，实现起来比较麻烦，主要是和硬件有一定联系，会略显复杂。&lt;/p&gt;
&lt;h3 id="宏观视角"&gt;宏观视角&lt;/h3&gt;
&lt;p&gt;宏观地来看，一个中断的过程就是 CPU 接受中断信号，然后执行对应的处理函数。这里的中断分外部中断和内部中断两种。&lt;/p&gt;</description></item><item><title>《操作系统真像还原》操作系统实现——内核中的字符打印函数</title><link>https://chujdk.github.io/os/1336.html</link><pubDate>Thu, 20 May 2021 23:06:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/os/1336.html</guid><description>&lt;p&gt;昨天在看特权级相关的东西，看的云里雾里，没搞得很懂，考虑到短期之内不会弄得特别深，而且我们也用不上调用门，相关的较复杂的问题也应该不会碰到，所以准备暂时跳过。&lt;/p&gt;</description></item><item><title>《操作系统真像还原》操作系统实现——引导内核</title><link>https://chujdk.github.io/os/1330.html</link><pubDate>Tue, 18 May 2021 20:46:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/os/1330.html</guid><description>&lt;p&gt;到现在为止，我们已经进入了保护模式并做好了虚拟地址映射、开启了分页模式，loader 的历史使命也差不多该完成了，现在它需要来引导我们的内核并移交控制权了。&lt;/p&gt;</description></item><item><title>《操作系统真像还原》操作系统实现——进入分页模式</title><link>https://chujdk.github.io/os/1327.html</link><pubDate>Mon, 17 May 2021 09:51:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/os/1327.html</guid><description>&lt;p&gt;进入保护模式后，我们对内存的访问仍然是基于物理地址的，我们运行的程序，大多是希望自己有一段连续的地址空间的，这样方便寻址。如果使用物理地址来访问内存，就必须真的给每个进程都分配大段地连续物理内存空间，这可能造成内存碎片难以处理的问题。为了解决这个问题，可以引入&lt;strong&gt;分页模式&lt;/strong&gt;（&lt;strong&gt;Paging mode&lt;/strong&gt;），好处非常多，此处不再赘述，可以看 &lt;a href="https://zh.wikipedia.org/wiki/%E5%88%86%E9%A0%81"&gt;WIKI&lt;/a&gt;。&lt;/p&gt;</description></item><item><title>《操作系统真像还原》操作系统实现——进入保护模式</title><link>https://chujdk.github.io/os/1323.html</link><pubDate>Sat, 15 May 2021 18:26:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/os/1323.html</guid><description>&lt;p&gt;之前看完王爽老师的《汇编语言》后本来准备看一下《X86汇编语言：从实模式到保护模式》，但是那本书不是很好读，再加上自己也选择的是 PWN 这个方向，对汇编的要求没有那么高，所以就没读下去，对保护模式也只有一点粗浅的认知。本书看完了 4.3 节，虽然也不敢说有多深的理解，但是还是有学到新知识的，这里简单记录一下。&lt;/p&gt;</description></item><item><title>《操作系统真像还原》操作系统实现——MBR</title><link>https://chujdk.github.io/os/1320.html</link><pubDate>Fri, 14 May 2021 22:44:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/os/1320.html</guid><description>&lt;p&gt;最近这段时间准备学一学 OS，《现代操作系统》一书尝试了很多次都没看进去，还是先找一本轻松一点的书来看，尝试一下能不能跟着这本书写一个简单的 OS 出来。&lt;/p&gt;</description></item></channel></rss>