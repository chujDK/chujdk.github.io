<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>《操作系统真像还原》操作系统实现——用户进程 - blog of chuj</title><link rel=icon type=image/png href=https://www.cjovi.icu/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="硬件生产厂商（Intel）给多进程切换提供了硬件级的解决方案，也就是使用 TSS（Task-Stat Segment），令人遗憾的是由于其效率较"><meta property="og:image" content><meta property="og:title" content="《操作系统真像还原》操作系统实现——用户进程"><meta property="og:description" content="硬件生产厂商（Intel）给多进程切换提供了硬件级的解决方案，也就是使用 TSS（Task-Stat Segment），令人遗憾的是由于其效率较"><meta property="og:type" content="article"><meta property="og:url" content="https://www.cjovi.icu/os/1374.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-09T23:35:00+00:00"><meta property="article:modified_time" content="2021-06-09T23:35:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="《操作系统真像还原》操作系统实现——用户进程"><meta name=twitter:description content="硬件生产厂商（Intel）给多进程切换提供了硬件级的解决方案，也就是使用 TSS（Task-Stat Segment），令人遗憾的是由于其效率较"><script src=https://www.cjovi.icu/js/feather.min.js></script>
<link href=https://www.cjovi.icu/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.cjovi.icu/css/main.858703d01d3c45e6b3e5964f9788e10759b7deb2158ea92653787f83364a9899.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://www.cjovi.icu/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://www.cjovi.icu/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>《操作系统真像还原》操作系统实现——用户进程</h1><div class=meta>Posted on Jun 9, 2021</div></div><section class=body><p>硬件生产厂商（Intel）给多进程切换提供了硬件级的解决方案，也就是使用 <strong>TSS</strong>（<strong>Task-Stat Segment</strong>），令人遗憾的是由于其效率较低，现代操作系统大多没有使用它来进行进程切换，但是特别的，在特权级转移时的栈切换仍然需要通过它来进行，所以虽然我们不用它来切换进程，也仍然需要设置好它。</p><p><em>由于用不到，所以就不说如何用 TSS 来进行任务切换了</em></p><h3 id=tss-的设置>TSS 的设置</h3><p>将 TSS 抽象为结构体，结构如下（对 32 位 CPU 而言）</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>tss</span> {
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> backlink;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span><span style=color:#666>*</span> esp0;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> ss0;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span><span style=color:#666>*</span> esp1;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> ss1;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span><span style=color:#666>*</span> esp2;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> ss2;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> cr3;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> (<span style=color:#666>*</span>eip) (<span style=color:#902000>void</span>);
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> eflags;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> eax;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> ecx;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> edx;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> ebx;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> esp;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> ebp;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> esi;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> edi;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> es;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> cs;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> ss;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> ds;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> fs;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> gs;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> ldt;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> trace;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> io_base;
</span></span><span style=display:flex><span>}; 
</span></span></code></pre></div><p>可见这里保存了所有的寄存器，但是我们用不上他们，只需要设置好 esp0 和 ss0 就可以了，前者是从 3 特权级进入 0 特权级时的栈指针，后者是段选择子。由于我们的操作系统只用 RING3 和 RING0，所以 esp1 esp2 也不用管。特别的，io_base 是需要初始化的，这个是以单个端口为粒度进行端口访问权限控制的，初始化为结构体的末尾就可以了。</p><p>首先提供一个修改 esp0 的函数</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>tss</span> tss;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* 更新tss中esp0字段的值为pthread的0级线 */</span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>UpdateTssEsp</span>(<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>task_struct</span><span style=color:#666>*</span> pthread) {
</span></span><span style=display:flex><span>   tss.esp0 <span style=color:#666>=</span> (<span style=color:#902000>uint32_t</span><span style=color:#666>*</span>)((<span style=color:#902000>uint32_t</span>)pthread <span style=color:#666>+</span> PAGE_SIZE);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样进程切换优先级时就可以更新栈指针了。</p><p>然后需要在 GDT 中设置 TSS 描述符，这个也没什么特别可说的，之前我们在 loader 中设置了内核态使用的代码段和数据段描述符，不过那个是用汇编直接写进去的，这里我们用 C 写一个设置函数</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* setup gdt desc */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>void</span> <span style=color:#06287e>SetUpGDTDesc</span>(<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>gdt_desc</span><span style=color:#666>*</span> desc_ptr, size_t<span style=color:#666>*</span> desc_base_addr, size_t limit, <span style=color:#902000>uint8_t</span> attr_low, <span style=color:#902000>uint8_t</span> attr_high)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    desc_ptr<span style=color:#666>-&gt;</span>limit_low_word <span style=color:#666>=</span> limit <span style=color:#666>&amp;</span> <span style=color:#40a070>0x0000FFFF</span>;
</span></span><span style=display:flex><span>    desc_ptr<span style=color:#666>-&gt;</span>limit_high_attr_high <span style=color:#666>=</span> (((limit <span style=color:#666>&amp;</span> <span style=color:#40a070>0x000f0000</span>) <span style=color:#666>&gt;&gt;</span> <span style=color:#40a070>16</span>) <span style=color:#666>+</span> (<span style=color:#902000>uint8_t</span>)(attr_high));
</span></span><span style=display:flex><span>    desc_ptr<span style=color:#666>-&gt;</span>base_low_word <span style=color:#666>=</span> (size_t) desc_base_addr <span style=color:#666>&amp;</span> <span style=color:#40a070>0x0000FFFF</span>;
</span></span><span style=display:flex><span>    desc_ptr<span style=color:#666>-&gt;</span>base_mid_byte <span style=color:#666>=</span> (size_t) desc_base_addr <span style=color:#666>&amp;</span> <span style=color:#40a070>0x00FF0000</span>;
</span></span><span style=display:flex><span>    desc_ptr<span style=color:#666>-&gt;</span>base_high_byte <span style=color:#666>=</span> (size_t) desc_base_addr <span style=color:#666>&gt;&gt;</span> <span style=color:#40a070>24</span>;
</span></span><span style=display:flex><span>    desc_ptr<span style=color:#666>-&gt;</span>attr_low_byte <span style=color:#666>=</span> (<span style=color:#902000>uint8_t</span>)(attr_low);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后用一个初始化函数进行设置</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* create TSS, CODE, DATA desc in GDT, and reload GDT */</span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>TssInit</span>() 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    sys_putstr(<span style=color:#4070a0>&#34;tss and ltr init..&#34;</span>);
</span></span><span style=display:flex><span>    size_t tss_size <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span>(tss);
</span></span><span style=display:flex><span>    memset(<span style=color:#666>&amp;</span>tss, <span style=color:#40a070>0</span>, tss_size);
</span></span><span style=display:flex><span>    tss.ss0 <span style=color:#666>=</span> SELECTOR_K_STACK;
</span></span><span style=display:flex><span>    tss.io_base <span style=color:#666>=</span> tss_size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* gdt_base: 0x600 + 0x10, tss on the 4th, which at 0x600 + 0x10 + 0x20 */</span>
</span></span><span style=display:flex><span>    SetUpGDTDesc((<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>gdt_desc</span><span style=color:#666>*</span>) (<span style=color:#40a070>0xC0000630</span>),\
</span></span><span style=display:flex><span>    (size_t <span style=color:#666>*</span>)<span style=color:#666>&amp;</span>tss, tss_size <span style=color:#666>-</span> <span style=color:#40a070>1</span>, TSS_ATTR_LOW, GDT_ATTR_HIGH);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* code DESC, dpl = 3 */</span>
</span></span><span style=display:flex><span>    SetUpGDTDesc((<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>gdt_desc</span><span style=color:#666>*</span>) (<span style=color:#40a070>0xC0000638</span>),\
</span></span><span style=display:flex><span>    (size_t <span style=color:#666>*</span>) <span style=color:#40a070>0</span>, tss_size <span style=color:#666>-</span> <span style=color:#40a070>1</span>, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* data, stack DESC, dpl = 3 */</span>
</span></span><span style=display:flex><span>    SetUpGDTDesc((<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>gdt_desc</span><span style=color:#666>*</span>) (<span style=color:#40a070>0xC0000640</span>),\
</span></span><span style=display:flex><span>    (size_t <span style=color:#666>*</span>) <span style=color:#40a070>0</span>, tss_size <span style=color:#666>-</span> <span style=color:#40a070>1</span>, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#902000>uint64_t</span> gdt_operand <span style=color:#666>=</span> \
</span></span><span style=display:flex><span>    ((<span style=color:#40a070>8</span> <span style=color:#666>*</span> <span style=color:#40a070>7</span> <span style=color:#666>-</span> <span style=color:#40a070>1</span>) <span style=color:#666>|</span> ((<span style=color:#902000>uint64_t</span>)((<span style=color:#902000>uint32_t</span>)<span style=color:#40a070>0xC0000610</span> <span style=color:#666>&lt;&lt;</span> <span style=color:#40a070>16</span>)));
</span></span><span style=display:flex><span>    __asm__ <span style=color:#007020;font-weight:700>volatile</span> (<span style=color:#4070a0>&#34;lgdt %0&#34;</span> <span style=color:#666>:</span> <span style=color:#666>:</span> <span style=color:#4070a0>&#34;m&#34;</span> (gdt_operand));
</span></span><span style=display:flex><span>    __asm__ <span style=color:#007020;font-weight:700>volatile</span> (<span style=color:#4070a0>&#34;ltr %w0&#34;</span> <span style=color:#666>:</span> <span style=color:#666>:</span> <span style=color:#4070a0>&#34;r&#34;</span> (SELECTOR_TSS));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sys_putstr(<span style=color:#4070a0>&#34; done</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里将 TSS 段描述符设置到了 GDT[3] 上，用户态代码段（DPL 为 3）设置到了 GDT[4]，用户态数据段设置到了 GDT[5] 上。然后通过 lgdt 重新设置了 gdt 表。到这里都是已知的东西，然后的 ltr 就是设置 TSS 的指令。</p><p>ltr 将一个段选择子的值写到 TR（Task Register）中，这就是硬件层面的多进程支持所使用的关键寄存器，如果使用 TSS 进行切换，那么将 TR 修改为不同的段选择子，选择不同的 TSS 就可以实现进程切换了，但是由于效率问题以 Linux 为代表的现代操作系统都不使用 TSS 来切换，而是一直都使用同样的 TSS 来<em>欺骗</em>处理器。所以这里把写好的 TSS 段描述符的选择子 load 到 TR 里面就可以了。</p><p>完成之后 GDT 表就应该是这样的</p><div style=text-align:center><img src=https://www.cjovi.icu/usr/uploads/2021/06/3719226770.png></div><h3 id=进入-ring3>进入 RING3</h3><p>一个用户进程和之前已经实现的内核线程的区别主要有两点</p><ul><li>进程有独立页表</li><li>用户进程的特权级为 3</li></ul><p>首先解决独立页表，页表都是存储在内核内存池的，自然的，也应该由内核来为用户初始化页表，要做的就是为用户从内核内存池中申请数个页框来存放 PDE 和映射到内核空间的 PTE。申请好了之后要把内核的 PDE 值拷贝到用户的 PDE 中，实现内核资源所有进程共享。特别的，PDE 的最后一项要映射到用户的 PDE 上，这样之后才能对 PDE 进行操作。</p><p>页表初始化了之后内存管理的一系列结构也需要初始化，即虚拟地址位图。</p><p>然后解决退特权级的问题，在 X86 下，要从高特权级转移到低特权级必须使用 iret，所以我们通过中断退出函数 ExitInt 来进入特权级 3，只要提前在用户进程的内核栈中设置好几个寄存器的值，未来调度器扫到用户进程的时候就可以转到用户进程代码上了。</p><h3 id=代码>代码</h3><p>原理说起来比较简单，但是实现起来各种问题不断。这里的代码我调了快 10 个小时才调出来。tag 已打好，具体请看<a href=https://github.com/chujDK/chuj-elephant-os/releases/tag/user_process>此处</a>。</p><p>最后的执行效果大概为</p><div style=text-align:center><img src=https://www.cjovi.icu/usr/uploads/2021/06/3882133818.png></div></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/os>OS</a></li></ul></nav></div><script src=https://giscus.app/client.js data-repo=chujDK/chujdk.github.io data-repo-id=R_kgDOI__mNg data-category=Announcements data-category-id=DIC_kwDOI__mNs4CYoyP data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/chujdk rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=mailto:chujj31@gmail.com rel=me title=Mail><i data-feather=mail></i></a>
<a class=border></a></div><div class=footer-info>&nbsp2020 ~ 2023  © chuj |  Based on <a href=https://github.com/athul/archie>Archie</a> | Built with <a href=https://gohugo.io>Hugo</a> | <a href=#>Goto Top</a></div></footer><script>feather.replace()</script></div></body></html>