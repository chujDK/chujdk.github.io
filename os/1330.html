<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>《操作系统真像还原》操作系统实现——引导内核 - blog of chuj</title><link rel=icon type=image/png href=https://www.cjovi.icu/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="到现在为止，我们已经进入了保护模式并做好了虚拟地址映射、开启了分页模式，loader 的历史使命也差不多该完成了，现在它需要来引导我们的内核并"><meta property="og:image" content><meta property="og:title" content="《操作系统真像还原》操作系统实现——引导内核"><meta property="og:description" content="到现在为止，我们已经进入了保护模式并做好了虚拟地址映射、开启了分页模式，loader 的历史使命也差不多该完成了，现在它需要来引导我们的内核并"><meta property="og:type" content="article"><meta property="og:url" content="https://www.cjovi.icu/os/1330.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-18T20:46:00+00:00"><meta property="article:modified_time" content="2021-05-18T20:46:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="《操作系统真像还原》操作系统实现——引导内核"><meta name=twitter:description content="到现在为止，我们已经进入了保护模式并做好了虚拟地址映射、开启了分页模式，loader 的历史使命也差不多该完成了，现在它需要来引导我们的内核并"><script src=https://www.cjovi.icu/js/feather.min.js></script>
<link href=https://www.cjovi.icu/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.cjovi.icu/css/main.44a18422ec0066708fd200e05feb946702a7b17e5d322ff1a35ef8be5c62ad32.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://www.cjovi.icu/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://www.cjovi.icu/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>《操作系统真像还原》操作系统实现——引导内核</h1><div class=meta>Posted on May 18, 2021</div></div><section class=body><p>到现在为止，我们已经进入了保护模式并做好了虚拟地址映射、开启了分页模式，loader 的历史使命也差不多该完成了，现在它需要来引导我们的内核并移交控制权了。</p><p>内核较为复杂，全部用汇编实现显然是不现实的，类似于大多数的操作系统，我们使用 C 来完成开发。</p><h3 id=关于编译方式>关于编译方式：</h3><p>高版本的 GCC 在编译代码的时候开启了许多优化和保护，我的虚拟机为 Ubuntu 20.04，gcc 版本为 9.0，难以生成我们希望的汇编代码，解决方法为降级为 gcc 4.8，使用</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcc -c -o main.o main.c -m32 -fno-asynchronous-unwind-tables
</span></span></code></pre></div><p>进行编译，可以获得希望最低程度改动的代码（指汇编代码和预期的基本一致）。</p><h3 id=关于文件格式>关于文件格式：</h3><p>现代操作系统基本都有对该操作系统的可执行文件的格式进行约定，Linux 下常用为 <strong>ELF</strong>（<strong>Executable and Linkable Format</strong>，可执行与可链接格式），Windows 下则为 <strong>PE</strong>（<strong>Portable Executable</strong>，可移植的可执行的文件）。我们的大象操作系统当然也可以约定一个格式，比如<em>大象格式</em>。</p><p>但是大可不必这样做，说到底来，格式不过是一种约定，浪费时间在约定格式上对我们的学习并无多少帮助，另一方面，使用 ELF 也代表我们可以直接用 Linux + gcc 进行开发，节省许多格式处理上的麻烦。最后 ELF 也是一个成熟的、标准化的格式，广为接受，直接拿来用完全没毛病。</p><h3 id=内核代码生成方式>内核代码生成方式</h3><p>我们的内核代码的入口地址需要我们自己指定，由于内核未来会比较小，所以可以直接放到 1M 空间以下，和书上相同，我也放在虚拟地址 0xC0001500 上，既然这样，就不能让 gcc 直接给我们链接掉，而是需要我们自己用 ld 链接。以 main.c 做例子，就是先用 gcc 生成目标文件 main.o</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>gcc -c -o main.o main.c -m32 -fno-asynchronous-unwind-tables
</span></span></code></pre></div><p>然后用 ld 指定入口点和代码段基地址</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ld main.o -Ttext 0xc0001500 -e _start -o kernel.bin -m elf_i386
</span></span></code></pre></div><p>注意命令中的 <code>-e _start</code>，这是指定入口点符号为 _start，其实默认就是使用这个函数做入口点的。如果习惯用 main 函数做入口点函数的话（其实事实上一般来说 ELF 文件都不是真的以 main 函数作为入口点的），只要把 <code>-e _start</code> 改为 <code>-e main</code> 就可以正常链接了。得到的 kernel.bin 就是我们未来要引导的内核文件了。</p><p>然后需要写入磁盘，和书中的选择一样，我也是从 0x9 扇区（第十个扇区）开始写 200 个扇区的，也就是</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>dd if=./kernel.bin of=/path/to/hd60M.img bs=512 count=200 seek=9 conv=notrunc
</span></span></code></pre></div><h3 id=读取-elf-文件>读取 ELF 文件</h3><p>之前的几步做好了准备工作，之后就是要 loader 来做引导了，首先先把 kernel.bin 的内容都读到内存里面来，避免频繁的磁盘 I/O 操作造成性能过低。和书上一样，我也在分页模式开启前读取，虽然其实开启前后读关系都不大。</p><p>这里的读取方式可以几乎直接沿用 mbr 中对 loader 的引用方式，只要改一下进行写入操作的寄存器为 32 位寄存器就可以了，看后面的代码就可以很容易理解。主要是读到内存的什么位置比较重要，其实也不是很重要，只要不会覆盖后面的页表，且在内核展开后不会被内核覆盖就可以。多次提到，底端 1M 的内存在未来会映射到自己身上，这 1M 我们准备防止内核代码，提一下其中 0x500 ~ 0x9FBFF 是没有被其他设备映射的，我们可以随便用。顺便提一下，其中 GDT 表处在 0x610 ~ 0x810 中，后面又跟了一些重要的变量。</p><p>内核代码放在虚拟地址 0xC00001500，也就是物理地址 0x1500 处。我们沿用 Linux 的习惯，代码从低地址开始向上增长，栈从高地址开始向下增长，中间余留一定空间保证不会交汇。我们可以把 kernel.bin 放在这中间的地方，和书上一样，我也放在了 0x60000 上。</p><h3 id=导出-elf-文件中各段>导出 ELF 文件中各段</h3><p>导出的过程涉及 ELF 的结构，这个结构里面东西挺多的，我觉得没必要死记硬背，这里只要知道我们需要的一些东西就可以了，由于是 32 位系统，所以只考虑 ELF32 的格式。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#define EI_NIDENT 16
</span></span></span><span style=display:flex><span><span style=color:#007020></span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#007020;font-weight:700>struct</span> {
</span></span><span style=display:flex><span> <span style=color:#902000>unsigned</span> <span style=color:#902000>char</span> e_ident[EI_NIDENT];
</span></span><span style=display:flex><span> Elf32_Half e_type;
</span></span><span style=display:flex><span> Elf32_Half e_machine;
</span></span><span style=display:flex><span> Elf32_Word e_version;
</span></span><span style=display:flex><span> Elf32_Addr e_entry;
</span></span><span style=display:flex><span> Elf32_Off e_phoff;
</span></span><span style=display:flex><span> Elf32_Off e_shoff;
</span></span><span style=display:flex><span> Elf32_Word e_flags;
</span></span><span style=display:flex><span> Elf32_Half e_ehsize;
</span></span><span style=display:flex><span> Elf32_Half e_phentsize;
</span></span><span style=display:flex><span> Elf32_Half e_phnum;
</span></span><span style=display:flex><span> Elf32_Half e_shentsize;
</span></span><span style=display:flex><span> Elf32_Half e_shnum;
</span></span><span style=display:flex><span> Elf32_Half e_shstrndx;
</span></span><span style=display:flex><span>} Elf32_Ehdr;
</span></span></code></pre></div><p>这里 <code>Elf32_Half</code> 类型占 2 字节，<code>Elf32_Word</code>、<code>ELF32_Addr</code> 和 <code>Elf32_Off</code> 三个类型都是 4 字节，偏移可以自己计算。这里面对我们有用的是 <code>e_phoff</code>、<code>e_phentsize</code> 和 <code>e_phnum</code> 三个成员变量 ，分别代表段表的偏移，段表的大小，段表的总数。</p><p>每一个段表项的结构如下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#007020;font-weight:700>struct</span> {
</span></span><span style=display:flex><span> Elf32_Word p_type;	<span>\\</span> <span>段的类型</span>
</span></span><span style=display:flex><span> Elf32_Off p_offset;	<span>\\</span> <span>段距文件头的偏移</span>
</span></span><span style=display:flex><span> Elf32_Addr p_vaddr;	<span>\\</span> <span>该段应该处于的虚拟地址</span>
</span></span><span style=display:flex><span> Elf32_Addr p_paddr;
</span></span><span style=display:flex><span> Elf32_Word p_filesz;	<span>\\</span> <span>该段的文件长度（即在文件中的长度，下面哪个是段在内存中占的长度）</span>
</span></span><span style=display:flex><span> Elf32_Word p_memsz;
</span></span><span style=display:flex><span> Elf32_Word p_flags;
</span></span><span style=display:flex><span> Elf32_Word p_align;
</span></span><span style=display:flex><span>} Elf32_Phdr;
</span></span></code></pre></div><p>这里有用到四个变量，已经注释出来了。</p><p>那么我们如何导出呢？其实比较容易，首先获得段表基地址和段表项总数，然后遍历段表，通过内存拷贝把对应的数据拷到对应的地址就可以了。</p><h3 id=总结>总结</h3><p>好吧我承认这里我没有说的很清楚，一方面是对 ELF 格式我虽然尝试学了很多次，但是一直没法记下来，所以也不是特别了解，另一方面我觉得说实话也不是很重要；-）</p><h3 id=实现代码>实现代码</h3><p>之前虽然说的很简略，但是看着代码应该就可以理解了</p><p>boot.inc 中新增</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>KERNEL_START_SECTOR equ 0x9
</span></span><span style=display:flex><span>KERNEL_SUM_SECTOR equ 200
</span></span><span style=display:flex><span>KERNEL_BIN_BASE_ADDR equ 0x60000            ; where we put the kernel.bin
</span></span><span style=display:flex><span>KERNEL_ENTER_POINT equ 0xC0001500           ; the kernel enter point addr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>;--------- elf related ----------
</span></span><span style=display:flex><span>PT_NULL equ 0                               ; segment type 
</span></span></code></pre></div><p>loader.S</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>%include &#34;boot.inc&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>section loader vstart=LOADER_BASE_ADDR
</span></span><span style=display:flex><span>LOADER_STACK_TOP equ LOADER_BASE_ADDR
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>jmp LoaderStart                         ; 3 bytes
</span></span><span style=display:flex><span>db 0
</span></span><span style=display:flex><span>dd 0,0,0                                ; addr align
</span></span><span style=display:flex><span>; offset 0x10
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; set up GOT and descriptor
</span></span><span style=display:flex><span>GDT_BASE: dd 0x00000000   
</span></span><span style=display:flex><span>          dd 0x00000000   
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CODE_DESC: dd 0x0000FFFF                ; low 32 bits
</span></span><span style=display:flex><span>           dd DESC_CODE_HIGH4           ; high 32 bits
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DATA_STACK_DESC: dd 0x0000FFFF          ; used by stack and data seg
</span></span><span style=display:flex><span>            dd DESC_DATA_HIGH4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; text-mode display
</span></span><span style=display:flex><span>; limit = (0xBFFFF - 0xB8000) / 4K = 0x7
</span></span><span style=display:flex><span>VIDEO_DESC: dd 0x80000007 
</span></span><span style=display:flex><span>            dd DESC_VIDEO_HIGH4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>GDT_SIZE  equ $ - GDT_BASE
</span></span><span style=display:flex><span>GDT_LIMIT equ GDT_SIZE - 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>times 60 dq 0                           ; reserve 60 GDTs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TOTAL_MEM_BYTES dd 0                    ; memory of the machine
</span></span><span style=display:flex><span>                                        ; addr: LOADER_BASE_ADDR + 0x10 + 0x200 = 0x800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SELECTOR_CODE equ ((CODE_DESC - GDT_BASE) / 8) &lt;&lt; 3 + TI_GDT + RPL0
</span></span><span style=display:flex><span>SELECTOR_DATA equ ((DATA_STACK_DESC - GDT_BASE) / 8) &lt;&lt; 3 + TI_GDT + RPL0
</span></span><span style=display:flex><span>SELECTOR_VIDEO equ ((VIDEO_DESC - GDT_BASE) / 8) &lt;&lt; 3 + TI_GDT + RPL0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; pointer point to GDT
</span></span><span style=display:flex><span>gdt_ptr: dw GDT_LIMIT    ; low 16 bits of GDT reg
</span></span><span style=display:flex><span>         dd GDT_BASE     ; high 32 bits of GDT reg
</span></span><span style=display:flex><span>; end of GDT setup
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>LoaderStart:
</span></span><span style=display:flex><span>; ---------- first, get the total memory of the machine ----------
</span></span><span style=display:flex><span>; ---------- we must do it before enter the PE mode as we need the BIOS int ----------
</span></span><span style=display:flex><span>; use bios int 0x15 sub 0xE801
</span></span><span style=display:flex><span>    .LoaderStart_E801FailedRetry:
</span></span><span style=display:flex><span>        mov ax,0xE801
</span></span><span style=display:flex><span>        int 0x15
</span></span><span style=display:flex><span>    jc .LoaderStart_E801FailedRetry
</span></span><span style=display:flex><span>    ; calculate low 15MB memory
</span></span><span style=display:flex><span>    mov cx,0x400
</span></span><span style=display:flex><span>    mul cx
</span></span><span style=display:flex><span>    shl edx,16
</span></span><span style=display:flex><span>    and eax,0x0000FFFF
</span></span><span style=display:flex><span>    or edx,eax
</span></span><span style=display:flex><span>    add edx,0x100000                        ; add 1MB, this is caused by the memory hole
</span></span><span style=display:flex><span>    mov esi,edx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    xor eax,eax
</span></span><span style=display:flex><span>    mov ax,bx
</span></span><span style=display:flex><span>    mov ecx,0x10000                         ; 64 * 1024
</span></span><span style=display:flex><span>    mul ecx
</span></span><span style=display:flex><span>    add esi,eax                             ; esi store the
</span></span><span style=display:flex><span>    mov [TOTAL_MEM_BYTES],esi               ; now TOTAL_MEM_BYTES stores the total memory
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ; ---------- ready to enter Proctection mode ----------
</span></span><span style=display:flex><span>    ; 1 open A20 address line
</span></span><span style=display:flex><span>    ; 2 load GDT reg
</span></span><span style=display:flex><span>    ; 3 set pe of cr0 to 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ; open A20
</span></span><span style=display:flex><span>    in al,0x92   
</span></span><span style=display:flex><span>    or al,0000_0010B                        ; save existed status
</span></span><span style=display:flex><span>    out 0x92,al
</span></span><span style=display:flex><span>    ; load GDT reg
</span></span><span style=display:flex><span>    lgdt [gdt_ptr]
</span></span><span style=display:flex><span>    ; set cr0, let&#39;s roll!
</span></span><span style=display:flex><span>    mov eax,cr0
</span></span><span style=display:flex><span>    or eax,0x00000001                       ; save existed status
</span></span><span style=display:flex><span>    mov cr0,eax                             ; enter Protection mode
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    jmp dword SELECTOR_CODE:ProctectionModeStart    ; reflesh assembly line
</span></span><span style=display:flex><span>; ---------- end of function LoaderStart ----------
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; ---------- now we are in 32-bits PE mode ----------
</span></span><span style=display:flex><span>[bits 32]
</span></span><span style=display:flex><span>ProctectionModeStart:
</span></span><span style=display:flex><span>; set selectors
</span></span><span style=display:flex><span>    mov ax,SELECTOR_DATA
</span></span><span style=display:flex><span>    mov ds,ax
</span></span><span style=display:flex><span>    mov es,ax
</span></span><span style=display:flex><span>    mov ss,ax
</span></span><span style=display:flex><span>    mov esp,LOADER_STACK_TOP
</span></span><span style=display:flex><span>    mov ax,SELECTOR_VIDEO
</span></span><span style=display:flex><span>    mov gs,ax
</span></span><span style=display:flex><span>    mov byte [gs:2],&#39;P&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; first thing we do is load the kernel.bin to the RAM 
</span></span><span style=display:flex><span>    mov esi,KERNEL_START_SECTOR
</span></span><span style=display:flex><span>    mov edi,KERNEL_BIN_BASE_ADDR
</span></span><span style=display:flex><span>    mov edx,KERNEL_SUM_SECTOR               ; read this much sectors
</span></span><span style=display:flex><span>    call ReadDiskSector_32
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; second thing we do is start the page mode
</span></span><span style=display:flex><span>    ; 1 setup PDE and related PTE
</span></span><span style=display:flex><span>    call SetupPage
</span></span><span style=display:flex><span>    ; 2 modify the GDT to make it work in paging mode
</span></span><span style=display:flex><span>    sgdt [gdt_ptr]
</span></span><span style=display:flex><span>    mov ebx,[gdt_ptr + 2]
</span></span><span style=display:flex><span>    or dword [ebx + 0x18 + 4],0xC0000000    ; modify the VIDEO_DESC
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    add dword [gdt_ptr + 2],0xC0000000      ; pre modify the GDTR value 
</span></span><span style=display:flex><span>    add esp,0xC0000000                      ; also modify the stack 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mov eax,PAGE_DIR_TABLE_POS
</span></span><span style=display:flex><span>    mov cr3,eax
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mov eax,cr0
</span></span><span style=display:flex><span>    or eax,0x80000000                       ; save existed status
</span></span><span style=display:flex><span>    mov cr0,eax                             ; enable paging mode
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    lgdt [gdt_ptr]                          ; change GDTR
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mov byte [gs:4],&#39;V&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; last thing we do is extract the Ttext to where it belongs
</span></span><span style=display:flex><span>    jmp SELECTOR_CODE:EnterKernel
</span></span><span style=display:flex><span>    EnterKernel:
</span></span><span style=display:flex><span>    call KernelInit
</span></span><span style=display:flex><span>    mov esp,0xC009F000                      ; set kernel stack
</span></span><span style=display:flex><span>    jmp KERNEL_ENTER_POINT                  ; enter kernel
</span></span><span style=display:flex><span>; end of ProctectionModeStart
</span></span><span style=display:flex><span>; end of loader, thank you and goodbye!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SetupPage:
</span></span><span style=display:flex><span>; ---------- this function setup the Page Directory Entry and Page Table Entry ----------
</span></span><span style=display:flex><span>    ; clear PTE
</span></span><span style=display:flex><span>    mov ecx,0x1000                          ; 4K PDE
</span></span><span style=display:flex><span>    mov esi,0                               ; use this reg the clear
</span></span><span style=display:flex><span>    .SetupPage_ClearPDE:
</span></span><span style=display:flex><span>        mov byte [PAGE_DIR_TABLE_POS + esi],0
</span></span><span style=display:flex><span>        inc esi
</span></span><span style=display:flex><span>    loop .SetupPage_ClearPDE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ; setup PDE
</span></span><span style=display:flex><span>    .SetupPage_CreatePDE:
</span></span><span style=display:flex><span>        mov eax,PAGE_DIR_TABLE_POS
</span></span><span style=display:flex><span>        add eax,0x1000                       ; addr of the first PTE 
</span></span><span style=display:flex><span>        mov ebx,eax                          ; ebx is the base addr of PTEs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ; make the PDE[0] and PDE[0xC00] point to the first PTE
</span></span><span style=display:flex><span>        or eax,PG_US_U | PG_RW_RW | PG_P     ; set user page status
</span></span><span style=display:flex><span>        mov [PAGE_DIR_TABLE_POS + 0x0],eax   ; the first PTE&#39;s place, mapping loader&#39;s addr to itself
</span></span><span style=display:flex><span>        mov [PAGE_DIR_TABLE_POS + 0xC00],eax ; the first PTE used by kernel, mapping to low 1M
</span></span><span style=display:flex><span>        ; 0xC0000000 ~ 0xFFFFFFFF belongs to kernel
</span></span><span style=display:flex><span>        sub eax,0x1000
</span></span><span style=display:flex><span>        mov [PAGE_DIR_TABLE_POS + 0xFFC],eax  ; make the last Entry point to PDE itself
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ; creat PTE for kernel
</span></span><span style=display:flex><span>        mov ecx,256                          ; 1M / 4K = 256
</span></span><span style=display:flex><span>        mov esi,0
</span></span><span style=display:flex><span>        mov edx,PG_US_U | PG_RW_RW | PG_P    ; User, RW, P
</span></span><span style=display:flex><span>        .SetupPage_CreatePTE:
</span></span><span style=display:flex><span>            mov [ebx + esi * 4],edx
</span></span><span style=display:flex><span>            add edx,0x1000
</span></span><span style=display:flex><span>            inc esi
</span></span><span style=display:flex><span>        loop .SetupPage_CreatePTE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        mov eax,PAGE_DIR_TABLE_POS
</span></span><span style=display:flex><span>        add eax,0x2000                      ; second PTE
</span></span><span style=display:flex><span>        or eax,PG_US_U | PG_RW_RW | PG_P
</span></span><span style=display:flex><span>        mov ebx,PAGE_DIR_TABLE_POS
</span></span><span style=display:flex><span>        mov ecx,254                         ; 1022 - 769 + 1
</span></span><span style=display:flex><span>        mov esi,769                         ; start from 769,the second PTE of kernel
</span></span><span style=display:flex><span>        .SetupPage_CreateKernelPDE:
</span></span><span style=display:flex><span>            mov [ebx + esi * 4],eax
</span></span><span style=display:flex><span>            inc esi
</span></span><span style=display:flex><span>            add eax,0x1000
</span></span><span style=display:flex><span>        loop .SetupPage_CreateKernelPDE
</span></span><span style=display:flex><span>        ret
</span></span><span style=display:flex><span>; ---------- end of function SetupPage ----------
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; ---------- start of function ReadDiskSector_32
</span></span><span style=display:flex><span>; function MBR_ReadDiskSector_32(LBA_addr, writing_addr, n), read n sectors from hard-disk in 32 bit mode
</span></span><span style=display:flex><span>; esi: LBA addr of start sector
</span></span><span style=display:flex><span>; edi: writing addr
</span></span><span style=display:flex><span>; edx: n
</span></span><span style=display:flex><span>ReadDiskSector_32:
</span></span><span style=display:flex><span>    ; read sectors
</span></span><span style=display:flex><span>    mov ebx,edx                     ; bx keeps the n
</span></span><span style=display:flex><span>    mov ax,bx                       ; n sectors
</span></span><span style=display:flex><span>    mov dx,0x1F2                    ; set reg Sector count 
</span></span><span style=display:flex><span>    out dx,al                       ; read n sectors
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ; set LBA addr
</span></span><span style=display:flex><span>    mov eax,esi
</span></span><span style=display:flex><span>    mov dx,0x1F3                    ; set reg LBA low
</span></span><span style=display:flex><span>    out dx,al                       ; write low 8 bits
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mov cl,8
</span></span><span style=display:flex><span>    shr eax,cl
</span></span><span style=display:flex><span>    mov dx,0x1F4                    ; set reg LBA mid
</span></span><span style=display:flex><span>    out dx,al                       ; write LBA mid
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    shr eax,cl
</span></span><span style=display:flex><span>    mov dx,0x1F5                    ; set reg LBA high
</span></span><span style=display:flex><span>    out dx,al                       ; write LBA high
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    shr eax,cl
</span></span><span style=display:flex><span>    and al,0xF                      ; only 4 bits
</span></span><span style=display:flex><span>    or al,0xE0                      ; 1110b: LBA mode, disk: master
</span></span><span style=display:flex><span>    mov dx,0x1F6                    ; set reg device
</span></span><span style=display:flex><span>    out dx,al                       ; set mode and LBA addr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ; ready to read
</span></span><span style=display:flex><span>    mov dx,0x1F7                    ; set reg command
</span></span><span style=display:flex><span>    mov al,0x20                     ; mode: read
</span></span><span style=display:flex><span>    out dx,al                       ; do read
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ; check disk status
</span></span><span style=display:flex><span>.ReadDiskSector_32_DiskNotReady:
</span></span><span style=display:flex><span>    in al,dx                        ; get disk status
</span></span><span style=display:flex><span>    and al,0x88                     ; result 0x8 =&gt; disk is read 
</span></span><span style=display:flex><span>                                    ; result 0x80 =&gt; disk is busy
</span></span><span style=display:flex><span>    cmp al,0x08
</span></span><span style=display:flex><span>    jnz .ReadDiskSector_32_DiskNotReady
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ; read data
</span></span><span style=display:flex><span>    mov ax,bx                       ; get n
</span></span><span style=display:flex><span>    mov dx,256                      ; read by word, so dx = 512 / 2
</span></span><span style=display:flex><span>    mul dx                          ; assum this mul won&#39;t overflow
</span></span><span style=display:flex><span>    mov cx,ax                       ; sum of words need to read
</span></span><span style=display:flex><span>    mov dx,0x1F0                    ; set reg data
</span></span><span style=display:flex><span>.ReadDiskSector_32_ReadingLoop:
</span></span><span style=display:flex><span>    in ax,dx                        ; read a word
</span></span><span style=display:flex><span>    mov [edi],ax                     ; write a word
</span></span><span style=display:flex><span>    add edi,2
</span></span><span style=display:flex><span>    loop .ReadDiskSector_32_ReadingLoop
</span></span><span style=display:flex><span>    ret
</span></span><span style=display:flex><span>; end of function ReadDiskSector_32
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>FatalKernelBroken:
</span></span><span style=display:flex><span>    mov byte [gs:0],&#39;F&#39;  
</span></span><span style=display:flex><span>    mov byte [gs:1],0xA4
</span></span><span style=display:flex><span>    mov byte [gs:2],&#39;A&#39;
</span></span><span style=display:flex><span>    mov byte [gs:3],0xA4
</span></span><span style=display:flex><span>    mov byte [gs:4],&#39;T&#39;
</span></span><span style=display:flex><span>    mov byte [gs:5],0xA4
</span></span><span style=display:flex><span>    mov byte [gs:6],&#39;A&#39;
</span></span><span style=display:flex><span>    mov byte [gs:7],0xA4
</span></span><span style=display:flex><span>    mov byte [gs:8],&#39;L&#39;
</span></span><span style=display:flex><span>    mov byte [gs:9],0xA4
</span></span><span style=display:flex><span>    mov byte [gs:10],&#39;:&#39;
</span></span><span style=display:flex><span>    mov byte [gs:11],0xA4
</span></span><span style=display:flex><span>    mov byte [gs:12],&#39; &#39;
</span></span><span style=display:flex><span>    mov byte [gs:14],&#39;K&#39;
</span></span><span style=display:flex><span>    mov byte [gs:16],&#39;E&#39;
</span></span><span style=display:flex><span>    mov byte [gs:18],&#39;R&#39;
</span></span><span style=display:flex><span>    mov byte [gs:20],&#39;N&#39;
</span></span><span style=display:flex><span>    mov byte [gs:22],&#39;E&#39;
</span></span><span style=display:flex><span>    mov byte [gs:24],&#39;L&#39;
</span></span><span style=display:flex><span>    mov byte [gs:26],&#39; &#39;
</span></span><span style=display:flex><span>    mov byte [gs:28],&#39;B&#39;
</span></span><span style=display:flex><span>    mov byte [gs:30],&#39;R&#39;
</span></span><span style=display:flex><span>    mov byte [gs:32],&#39;O&#39;
</span></span><span style=display:flex><span>    mov byte [gs:34],&#39;K&#39;
</span></span><span style=display:flex><span>    mov byte [gs:36],&#39;E&#39;
</span></span><span style=display:flex><span>    mov byte [gs:38],&#39;N&#39;
</span></span><span style=display:flex><span>    jmp $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>KernelInit:
</span></span><span style=display:flex><span>    mov eax,[KERNEL_BIN_BASE_ADDR]          ; check the magic number
</span></span><span style=display:flex><span>    cmp eax,0x464c457f
</span></span><span style=display:flex><span>    jne FatalKernelBroken  
</span></span><span style=display:flex><span>    mov al,[KERNEL_BIN_BASE_ADDR + 4]       ; make sure it is a 32 bits elf 
</span></span><span style=display:flex><span>    cmp al,1
</span></span><span style=display:flex><span>    jne FatalKernelBroken
</span></span><span style=display:flex><span>    mov al,[KERNEL_BIN_BASE_ADDR + 5]       ; make sure it is a LSB elf
</span></span><span style=display:flex><span>    cmp al,1
</span></span><span style=display:flex><span>    jne FatalKernelBroken
</span></span><span style=display:flex><span>    ; check done
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mov ebx,[KERNEL_BIN_BASE_ADDR + 28]     ; offset of program header table
</span></span><span style=display:flex><span>    add ebx,KERNEL_BIN_BASE_ADDR            ; address of program header table 
</span></span><span style=display:flex><span>    xor edx,edx
</span></span><span style=display:flex><span>    mov dx,[KERNEL_BIN_BASE_ADDR + 42]     ; program header size
</span></span><span style=display:flex><span>    mov cx,[KERNEL_BIN_BASE_ADDR + 44]      ; sum of segments
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    .LoadKernelEachSegment:
</span></span><span style=display:flex><span>        cmp byte [ebx],PT_NULL              ; skip th null segment
</span></span><span style=display:flex><span>        je .LoadKernelEachSegment_PT_NULL
</span></span><span style=display:flex><span>        push dword [ebx + 16]               ; nbytes, p_filesz
</span></span><span style=display:flex><span>        mov eax,[ebx + 4]   
</span></span><span style=display:flex><span>        add eax,KERNEL_BIN_BASE_ADDR        ; src
</span></span><span style=display:flex><span>        push eax
</span></span><span style=display:flex><span>        push dword [ebx + 8]                ; dst
</span></span><span style=display:flex><span>        call mem_cpy  
</span></span><span style=display:flex><span>        add esp,12                          ; unpush 3
</span></span><span style=display:flex><span>        .LoadKernelEachSegment_PT_NULL:  
</span></span><span style=display:flex><span>        add ebx,edx                         ; skip the header
</span></span><span style=display:flex><span>    loop .LoadKernelEachSegment
</span></span><span style=display:flex><span>    ret
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; ---------- function mem_cpy(dst,src,nbytes) ----------
</span></span><span style=display:flex><span>mem_cpy:
</span></span><span style=display:flex><span>    push ebp
</span></span><span style=display:flex><span>    mov ebp,esp
</span></span><span style=display:flex><span>    push edi
</span></span><span style=display:flex><span>    push esi
</span></span><span style=display:flex><span>    push ecx
</span></span><span style=display:flex><span>    mov edi,[ebp + 8]   ; dst
</span></span><span style=display:flex><span>    mov esi,[ebp + 12]   ; src
</span></span><span style=display:flex><span>    mov ecx,[ebp + 16]  ; nbytes
</span></span><span style=display:flex><span>    cld
</span></span><span style=display:flex><span>    rep movsb
</span></span><span style=display:flex><span>    pop ecx
</span></span><span style=display:flex><span>    pop esi
</span></span><span style=display:flex><span>    pop edi
</span></span><span style=display:flex><span>    leave
</span></span><span style=display:flex><span>    ret
</span></span></code></pre></div><p>kernel/main.c</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>_start</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#902000>int</span> i <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>while</span>(<span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        i<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>asm</span> <span style=color:#007020;font-weight:700>volatile</span>(
</span></span><span style=display:flex><span>            <span style=color:#4070a0>&#34;movb $</span><span style=color:#4070a0;font-weight:700>\&#39;</span><span style=color:#4070a0>K</span><span style=color:#4070a0;font-weight:700>\&#39;</span><span style=color:#4070a0>,%gs:6&#34;</span>
</span></span><span style=display:flex><span>           );
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>到现在为止，我们向屏幕输出了四个字符：&ldquo;MPVK&rdquo;，分别在 mbr，保护模式，分页模式，内核中输出，代表四模式的成功进入。</p><div style=text-align:center><img src=https://www.cjovi.icu/usr/uploads/2021/05/1894295228.png></div><p>之后我们就可以以 C 为主进行开发了。</p><p>另外说一下，这里的引导应该说是不太完整的，相应的段属性都没有设置，之后应该会逐渐完善。</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/os>OS</a></li></ul></nav></div><script src=https://giscus.app/client.js data-repo=chujDK/chujdk.github.io data-repo-id=R_kgDOI__mNg data-category=Announcements data-category-id=DIC_kwDOI__mNs4CYoyP data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/chujdk rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a></div><div class=footer-info>2023 © chuj | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>