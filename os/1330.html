<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>《操作系统真像还原》操作系统实现——引导内核 - blog of chuj</title><link rel=icon type=image/png href=https://chujdk.github.io/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="到现在为止，我们已经进入了保护模式并做好了虚拟地址映射、开启了分页模式，loader 的历史使命也差不多该完成了，现在它需要来引导我们的内核并移交控制权了。"><meta property="og:image" content><meta property="og:url" content="https://chujdk.github.io/os/1330.html"><meta property="og:site_name" content="blog of chuj"><meta property="og:title" content="《操作系统真像还原》操作系统实现——引导内核"><meta property="og:description" content="到现在为止，我们已经进入了保护模式并做好了虚拟地址映射、开启了分页模式，loader 的历史使命也差不多该完成了，现在它需要来引导我们的内核并移交控制权了。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-18T20:46:00+00:00"><meta property="article:modified_time" content="2021-05-18T20:46:00+00:00"><meta property="article:tag" content="OS"><meta name=twitter:card content="summary"><meta name=twitter:title content="《操作系统真像还原》操作系统实现——引导内核"><meta name=twitter:description content="到现在为止，我们已经进入了保护模式并做好了虚拟地址映射、开启了分页模式，loader 的历史使命也差不多该完成了，现在它需要来引导我们的内核并移交控制权了。"><script src=https://chujdk.github.io/js/feather.min.js></script><link href=https://chujdk.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://chujdk.github.io/css/main.6dc922b4122291f1967a53b3e802e564596ed5068a8571e4221c9ead17563c3a.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://chujdk.github.io/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://chujdk.github.io/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>《操作系统真像还原》操作系统实现——引导内核</h1><div class=meta>Posted on May 18, 2021</div></div><section class=body><p>到现在为止，我们已经进入了保护模式并做好了虚拟地址映射、开启了分页模式，loader 的历史使命也差不多该完成了，现在它需要来引导我们的内核并移交控制权了。</p><p>内核较为复杂，全部用汇编实现显然是不现实的，类似于大多数的操作系统，我们使用 C 来完成开发。</p><h3 id=关于编译方式>关于编译方式：</h3><p>高版本的 GCC 在编译代码的时候开启了许多优化和保护，我的虚拟机为 Ubuntu 20.04，gcc 版本为 9.0，难以生成我们希望的汇编代码，解决方法为降级为 gcc 4.8，使用</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcc -c -o main.o main.c -m32 -fno-asynchronous-unwind-tables
</span></span></code></pre></div><p>进行编译，可以获得希望最低程度改动的代码（指汇编代码和预期的基本一致）。</p><h3 id=关于文件格式>关于文件格式：</h3><p>现代操作系统基本都有对该操作系统的可执行文件的格式进行约定，Linux 下常用为 <strong>ELF</strong>（<strong>Executable and Linkable Format</strong>，可执行与可链接格式），Windows 下则为 <strong>PE</strong>（<strong>Portable Executable</strong>，可移植的可执行的文件）。我们的大象操作系统当然也可以约定一个格式，比如<em>大象格式</em>。</p><p>但是大可不必这样做，说到底来，格式不过是一种约定，浪费时间在约定格式上对我们的学习并无多少帮助，另一方面，使用 ELF 也代表我们可以直接用 Linux + gcc 进行开发，节省许多格式处理上的麻烦。最后 ELF 也是一个成熟的、标准化的格式，广为接受，直接拿来用完全没毛病。</p><h3 id=内核代码生成方式>内核代码生成方式</h3><p>我们的内核代码的入口地址需要我们自己指定，由于内核未来会比较小，所以可以直接放到 1M 空间以下，和书上相同，我也放在虚拟地址 0xC0001500 上，既然这样，就不能让 gcc 直接给我们链接掉，而是需要我们自己用 ld 链接。以 main.c 做例子，就是先用 gcc 生成目标文件 main.o</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>gcc -c -o main.o main.c -m32 -fno-asynchronous-unwind-tables
</span></span></code></pre></div><p>然后用 ld 指定入口点和代码段基地址</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ld main.o -Ttext 0xc0001500 -e _start -o kernel.bin -m elf_i386
</span></span></code></pre></div><p>注意命令中的 <code>-e _start</code>，这是指定入口点符号为 _start，其实默认就是使用这个函数做入口点的。如果习惯用 main 函数做入口点函数的话（其实事实上一般来说 ELF 文件都不是真的以 main 函数作为入口点的），只要把 <code>-e _start</code> 改为 <code>-e main</code> 就可以正常链接了。得到的 kernel.bin 就是我们未来要引导的内核文件了。</p><p>然后需要写入磁盘，和书中的选择一样，我也是从 0x9 扇区（第十个扇区）开始写 200 个扇区的，也就是</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>dd if=./kernel.bin of=/path/to/hd60M.img bs=512 count=200 seek=9 conv=notrunc
</span></span></code></pre></div><h3 id=读取-elf-文件>读取 ELF 文件</h3><p>之前的几步做好了准备工作，之后就是要 loader 来做引导了，首先先把 kernel.bin 的内容都读到内存里面来，避免频繁的磁盘 I/O 操作造成性能过低。和书上一样，我也在分页模式开启前读取，虽然其实开启前后读关系都不大。</p><p>这里的读取方式可以几乎直接沿用 mbr 中对 loader 的引用方式，只要改一下进行写入操作的寄存器为 32 位寄存器就可以了，看后面的代码就可以很容易理解。主要是读到内存的什么位置比较重要，其实也不是很重要，只要不会覆盖后面的页表，且在内核展开后不会被内核覆盖就可以。多次提到，底端 1M 的内存在未来会映射到自己身上，这 1M 我们准备防止内核代码，提一下其中 0x500 ~ 0x9FBFF 是没有被其他设备映射的，我们可以随便用。顺便提一下，其中 GDT 表处在 0x610 ~ 0x810 中，后面又跟了一些重要的变量。</p><p>内核代码放在虚拟地址 0xC00001500，也就是物理地址 0x1500 处。我们沿用 Linux 的习惯，代码从低地址开始向上增长，栈从高地址开始向下增长，中间余留一定空间保证不会交汇。我们可以把 kernel.bin 放在这中间的地方，和书上一样，我也放在了 0x60000 上。</p><h3 id=导出-elf-文件中各段>导出 ELF 文件中各段</h3><p>导出的过程涉及 ELF 的结构，这个结构里面东西挺多的，我觉得没必要死记硬背，这里只要知道我们需要的一些东西就可以了，由于是 32 位系统，所以只考虑 ELF32 的格式。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#define EI_NIDENT 16
</span></span></span><span style=display:flex><span><span style=color:#007020></span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#007020;font-weight:700>struct</span> {
</span></span><span style=display:flex><span> <span style=color:#902000>unsigned</span> <span style=color:#902000>char</span> e_ident[EI_NIDENT];
</span></span><span style=display:flex><span> Elf32_Half e_type;
</span></span><span style=display:flex><span> Elf32_Half e_machine;
</span></span><span style=display:flex><span> Elf32_Word e_version;
</span></span><span style=display:flex><span> Elf32_Addr e_entry;
</span></span><span style=display:flex><span> Elf32_Off e_phoff;
</span></span><span style=display:flex><span> Elf32_Off e_shoff;
</span></span><span style=display:flex><span> Elf32_Word e_flags;
</span></span><span style=display:flex><span> Elf32_Half e_ehsize;
</span></span><span style=display:flex><span> Elf32_Half e_phentsize;
</span></span><span style=display:flex><span> Elf32_Half e_phnum;
</span></span><span style=display:flex><span> Elf32_Half e_shentsize;
</span></span><span style=display:flex><span> Elf32_Half e_shnum;
</span></span><span style=display:flex><span> Elf32_Half e_shstrndx;
</span></span><span style=display:flex><span>} Elf32_Ehdr;
</span></span></code></pre></div><p>这里 <code>Elf32_Half</code> 类型占 2 字节，<code>Elf32_Word</code>、<code>ELF32_Addr</code> 和 <code>Elf32_Off</code> 三个类型都是 4 字节，偏移可以自己计算。这里面对我们有用的是 <code>e_phoff</code>、<code>e_phentsize</code> 和 <code>e_phnum</code> 三个成员变量 ，分别代表段表的偏移，段表的大小，段表的总数。</p><p>每一个段表项的结构如下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#007020;font-weight:700>struct</span> {
</span></span><span style=display:flex><span> Elf32_Word p_type;	<span>\\</span> <span>段的类型</span>
</span></span><span style=display:flex><span> Elf32_Off p_offset;	<span>\\</span> <span>段距文件头的偏移</span>
</span></span><span style=display:flex><span> Elf32_Addr p_vaddr;	<span>\\</span> <span>该段应该处于的虚拟地址</span>
</span></span><span style=display:flex><span> Elf32_Addr p_paddr;
</span></span><span style=display:flex><span> Elf32_Word p_filesz;	<span>\\</span> <span>该段的文件长度（即在文件中的长度，下面哪个是段在内存中占的长度）</span>
</span></span><span style=display:flex><span> Elf32_Word p_memsz;
</span></span><span style=display:flex><span> Elf32_Word p_flags;
</span></span><span style=display:flex><span> Elf32_Word p_align;
</span></span><span style=display:flex><span>} Elf32_Phdr;
</span></span></code></pre></div><p>这里有用到四个变量，已经注释出来了。</p><p>那么我们如何导出呢？其实比较容易，首先获得段表基地址和段表项总数，然后遍历段表，通过内存拷贝把对应的数据拷到对应的地址就可以了。</p><h3 id=总结>总结</h3><p>好吧我承认这里我没有说的很清楚，一方面是对 ELF 格式我虽然尝试学了很多次，但是一直没法记下来，所以也不是特别了解，另一方面我觉得说实话也不是很重要；-）</p><h3 id=实现代码>实现代码</h3><p>之前虽然说的很简略，但是看着代码应该就可以理解了</p><p>boot.inc 中新增</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>KERNEL_START_SECTOR equ 0x9
</span></span><span style=display:flex><span>KERNEL_SUM_SECTOR equ 200
</span></span><span style=display:flex><span>KERNEL_BIN_BASE_ADDR equ 0x60000            ; where we put the kernel.bin
</span></span><span style=display:flex><span>KERNEL_ENTER_POINT equ 0xC0001500           ; the kernel enter point addr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>;--------- elf related ----------
</span></span><span style=display:flex><span>PT_NULL equ 0                               ; segment type 
</span></span></code></pre></div><p>loader.S</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#666>%</span>include <span style=color:#4070a0>&#34;boot.inc&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>section loader vstart<span style=color:#666>=</span>LOADER_BASE_ADDR
</span></span><span style=display:flex><span>LOADER_STACK_TOP equ LOADER_BASE_ADDR
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>jmp LoaderStart                         ; <span style=color:#40a070>3</span> bytes
</span></span><span style=display:flex><span>db <span style=color:#40a070>0</span>
</span></span><span style=display:flex><span>dd <span style=color:#40a070>0</span>,<span style=color:#40a070>0</span>,<span style=color:#40a070>0</span>                                ; addr align
</span></span><span style=display:flex><span>; offset <span style=color:#40a070>0x10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; set up GOT <span style=color:#007020;font-weight:700>and</span> descriptor
</span></span><span style=display:flex><span>GDT_BASE: dd <span style=color:#40a070>0x00000000</span>   
</span></span><span style=display:flex><span>          dd <span style=color:#40a070>0x00000000</span>   
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CODE_DESC: dd <span style=color:#40a070>0x0000FFFF</span>                ; low <span style=color:#40a070>32</span> bits
</span></span><span style=display:flex><span>           dd DESC_CODE_HIGH4           ; high <span style=color:#40a070>32</span> bits
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DATA_STACK_DESC: dd <span style=color:#40a070>0x0000FFFF</span>          ; used by stack <span style=color:#007020;font-weight:700>and</span> data seg
</span></span><span style=display:flex><span>            dd DESC_DATA_HIGH4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; text<span style=color:#666>-</span>mode display
</span></span><span style=display:flex><span>; limit <span style=color:#666>=</span> (<span style=color:#40a070>0xBFFFF</span> <span style=color:#666>-</span> <span style=color:#40a070>0xB8000</span>) <span style=color:#666>/</span> <span style=color:#40a070>4</span>K <span style=color:#666>=</span> <span style=color:#40a070>0x7</span>
</span></span><span style=display:flex><span>VIDEO_DESC: dd <span style=color:#40a070>0x80000007</span> 
</span></span><span style=display:flex><span>            dd DESC_VIDEO_HIGH4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>GDT_SIZE  equ <span style=color:#666>$</span> <span style=color:#666>-</span> GDT_BASE
</span></span><span style=display:flex><span>GDT_LIMIT equ GDT_SIZE <span style=color:#666>-</span> <span style=color:#40a070>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>times <span style=color:#40a070>60</span> dq <span style=color:#40a070>0</span>                           ; reserve <span style=color:#40a070>60</span> GDTs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TOTAL_MEM_BYTES dd <span style=color:#40a070>0</span>                    ; memory of the machine
</span></span><span style=display:flex><span>                                        ; addr: LOADER_BASE_ADDR <span style=color:#666>+</span> <span style=color:#40a070>0x10</span> <span style=color:#666>+</span> <span style=color:#40a070>0x200</span> <span style=color:#666>=</span> <span style=color:#40a070>0x800</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SELECTOR_CODE equ ((CODE_DESC <span style=color:#666>-</span> GDT_BASE) <span style=color:#666>/</span> <span style=color:#40a070>8</span>) <span style=color:#666>&lt;&lt;</span> <span style=color:#40a070>3</span> <span style=color:#666>+</span> TI_GDT <span style=color:#666>+</span> RPL0
</span></span><span style=display:flex><span>SELECTOR_DATA equ ((DATA_STACK_DESC <span style=color:#666>-</span> GDT_BASE) <span style=color:#666>/</span> <span style=color:#40a070>8</span>) <span style=color:#666>&lt;&lt;</span> <span style=color:#40a070>3</span> <span style=color:#666>+</span> TI_GDT <span style=color:#666>+</span> RPL0
</span></span><span style=display:flex><span>SELECTOR_VIDEO equ ((VIDEO_DESC <span style=color:#666>-</span> GDT_BASE) <span style=color:#666>/</span> <span style=color:#40a070>8</span>) <span style=color:#666>&lt;&lt;</span> <span style=color:#40a070>3</span> <span style=color:#666>+</span> TI_GDT <span style=color:#666>+</span> RPL0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; pointer point to GDT
</span></span><span style=display:flex><span>gdt_ptr: dw GDT_LIMIT    ; low <span style=color:#40a070>16</span> bits of GDT reg
</span></span><span style=display:flex><span>         dd GDT_BASE     ; high <span style=color:#40a070>32</span> bits of GDT reg
</span></span><span style=display:flex><span>; end of GDT setup
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>LoaderStart:
</span></span><span style=display:flex><span>; <span style=color:#666>----------</span> first, get the total memory of the machine <span style=color:#666>----------</span>
</span></span><span style=display:flex><span>; <span style=color:#666>----------</span> we must <span style=color:#007020;font-weight:700>do</span> it before enter the PE mode as we need the BIOS <span style=color:#007020>int</span> <span style=color:#666>----------</span>
</span></span><span style=display:flex><span>; use bios <span style=color:#007020>int</span> <span style=color:#40a070>0x15</span> sub <span style=color:#40a070>0xE801</span>
</span></span><span style=display:flex><span>    <span style=color:#666>.</span>LoaderStart_E801FailedRetry:
</span></span><span style=display:flex><span>        mov ax,<span style=color:#40a070>0xE801</span>
</span></span><span style=display:flex><span>        <span style=color:#007020>int</span> <span style=color:#40a070>0x15</span>
</span></span><span style=display:flex><span>    jc <span style=color:#666>.</span>LoaderStart_E801FailedRetry
</span></span><span style=display:flex><span>    ; calculate low <span style=color:#40a070>15</span>MB memory
</span></span><span style=display:flex><span>    mov cx,<span style=color:#40a070>0x400</span>
</span></span><span style=display:flex><span>    mul cx
</span></span><span style=display:flex><span>    shl edx,<span style=color:#40a070>16</span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>and</span> eax,<span style=color:#40a070>0x0000FFFF</span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>or</span> edx,eax
</span></span><span style=display:flex><span>    add edx,<span style=color:#40a070>0x100000</span>                        ; add <span style=color:#40a070>1</span>MB, this is caused by the memory hole
</span></span><span style=display:flex><span>    mov esi,edx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    xor eax,eax
</span></span><span style=display:flex><span>    mov ax,bx
</span></span><span style=display:flex><span>    mov ecx,<span style=color:#40a070>0x10000</span>                         ; <span style=color:#40a070>64</span> <span style=color:#666>*</span> <span style=color:#40a070>1024</span>
</span></span><span style=display:flex><span>    mul ecx
</span></span><span style=display:flex><span>    add esi,eax                             ; esi store the
</span></span><span style=display:flex><span>    mov [TOTAL_MEM_BYTES],esi               ; now TOTAL_MEM_BYTES stores the total memory
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ; <span style=color:#666>----------</span> ready to enter Proctection mode <span style=color:#666>----------</span>
</span></span><span style=display:flex><span>    ; <span style=color:#40a070>1</span> open A20 address line
</span></span><span style=display:flex><span>    ; <span style=color:#40a070>2</span> <span style=color:#007020>load</span> GDT reg
</span></span><span style=display:flex><span>    ; <span style=color:#40a070>3</span> set pe of cr0 to <span style=color:#40a070>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ; open A20
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>in</span> al,<span style=color:#40a070>0x92</span>   
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>or</span> al,<span style=color:#40a070>0000</span>_0010B                        ; save existed status
</span></span><span style=display:flex><span>    out <span style=color:#40a070>0x92</span>,al
</span></span><span style=display:flex><span>    ; <span style=color:#007020>load</span> GDT reg
</span></span><span style=display:flex><span>    lgdt [gdt_ptr]
</span></span><span style=display:flex><span>    ; set cr0, let<span style=color:#4070a0>&#39;s roll!</span>
</span></span><span style=display:flex><span>    mov eax,cr0
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>or</span> eax,<span style=color:#40a070>0x00000001</span>                       ; save existed status
</span></span><span style=display:flex><span>    mov cr0,eax                             ; enter Protection mode
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    jmp dword SELECTOR_CODE:ProctectionModeStart    ; reflesh assembly line
</span></span><span style=display:flex><span>; <span style=color:#666>----------</span> end of function LoaderStart <span style=color:#666>----------</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; <span style=color:#666>----------</span> now we are <span style=color:#007020;font-weight:700>in</span> <span style=color:#40a070>32</span><span style=color:#666>-</span>bits PE mode <span style=color:#666>----------</span>
</span></span><span style=display:flex><span>[bits <span style=color:#40a070>32</span>]
</span></span><span style=display:flex><span>ProctectionModeStart:
</span></span><span style=display:flex><span>; set selectors
</span></span><span style=display:flex><span>    mov ax,SELECTOR_DATA
</span></span><span style=display:flex><span>    mov ds,ax
</span></span><span style=display:flex><span>    mov es,ax
</span></span><span style=display:flex><span>    mov ss,ax
</span></span><span style=display:flex><span>    mov esp,LOADER_STACK_TOP
</span></span><span style=display:flex><span>    mov ax,SELECTOR_VIDEO
</span></span><span style=display:flex><span>    mov gs,ax
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>2</span>],<span style=color:#4070a0>&#39;P&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; first thing we <span style=color:#007020;font-weight:700>do</span> is <span style=color:#007020>load</span> the kernel<span style=color:#666>.</span>bin to the RAM 
</span></span><span style=display:flex><span>    mov esi,KERNEL_START_SECTOR
</span></span><span style=display:flex><span>    mov edi,KERNEL_BIN_BASE_ADDR
</span></span><span style=display:flex><span>    mov edx,KERNEL_SUM_SECTOR               ; read this much sectors
</span></span><span style=display:flex><span>    call ReadDiskSector_32
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; second thing we <span style=color:#007020;font-weight:700>do</span> is start the page mode
</span></span><span style=display:flex><span>    ; <span style=color:#40a070>1</span> setup PDE <span style=color:#007020;font-weight:700>and</span> related PTE
</span></span><span style=display:flex><span>    call SetupPage
</span></span><span style=display:flex><span>    ; <span style=color:#40a070>2</span> modify the GDT to make it work <span style=color:#007020;font-weight:700>in</span> paging mode
</span></span><span style=display:flex><span>    sgdt [gdt_ptr]
</span></span><span style=display:flex><span>    mov ebx,[gdt_ptr <span style=color:#666>+</span> <span style=color:#40a070>2</span>]
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>or</span> dword [ebx <span style=color:#666>+</span> <span style=color:#40a070>0x18</span> <span style=color:#666>+</span> <span style=color:#40a070>4</span>],<span style=color:#40a070>0xC0000000</span>    ; modify the VIDEO_DESC
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    add dword [gdt_ptr <span style=color:#666>+</span> <span style=color:#40a070>2</span>],<span style=color:#40a070>0xC0000000</span>      ; pre modify the GDTR value 
</span></span><span style=display:flex><span>    add esp,<span style=color:#40a070>0xC0000000</span>                      ; also modify the stack 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mov eax,PAGE_DIR_TABLE_POS
</span></span><span style=display:flex><span>    mov cr3,eax
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mov eax,cr0
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>or</span> eax,<span style=color:#40a070>0x80000000</span>                       ; save existed status
</span></span><span style=display:flex><span>    mov cr0,eax                             ; enable paging mode
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    lgdt [gdt_ptr]                          ; change GDTR
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>4</span>],<span style=color:#4070a0>&#39;V&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; last thing we <span style=color:#007020;font-weight:700>do</span> is extract the Ttext to where it belongs
</span></span><span style=display:flex><span>    jmp SELECTOR_CODE:EnterKernel
</span></span><span style=display:flex><span>    EnterKernel:
</span></span><span style=display:flex><span>    call KernelInit
</span></span><span style=display:flex><span>    mov esp,<span style=color:#40a070>0xC009F000</span>                      ; set kernel stack
</span></span><span style=display:flex><span>    jmp KERNEL_ENTER_POINT                  ; enter kernel
</span></span><span style=display:flex><span>; end of ProctectionModeStart
</span></span><span style=display:flex><span>; end of loader, thank you <span style=color:#007020;font-weight:700>and</span> goodbye<span style=color:#666>!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SetupPage:
</span></span><span style=display:flex><span>; <span style=color:#666>----------</span> this function setup the Page <span style=color:#007020>Directory</span> Entry <span style=color:#007020;font-weight:700>and</span> Page Table Entry <span style=color:#666>----------</span>
</span></span><span style=display:flex><span>    ; clear PTE
</span></span><span style=display:flex><span>    mov ecx,<span style=color:#40a070>0x1000</span>                          ; <span style=color:#40a070>4</span>K PDE
</span></span><span style=display:flex><span>    mov esi,<span style=color:#40a070>0</span>                               ; use this reg the clear
</span></span><span style=display:flex><span>    <span style=color:#666>.</span>SetupPage_ClearPDE:
</span></span><span style=display:flex><span>        mov byte [PAGE_DIR_TABLE_POS <span style=color:#666>+</span> esi],<span style=color:#40a070>0</span>
</span></span><span style=display:flex><span>        inc esi
</span></span><span style=display:flex><span>    loop <span style=color:#666>.</span>SetupPage_ClearPDE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ; setup PDE
</span></span><span style=display:flex><span>    <span style=color:#666>.</span>SetupPage_CreatePDE:
</span></span><span style=display:flex><span>        mov eax,PAGE_DIR_TABLE_POS
</span></span><span style=display:flex><span>        add eax,<span style=color:#40a070>0x1000</span>                       ; addr of the first PTE 
</span></span><span style=display:flex><span>        mov ebx,eax                          ; ebx is the base addr of PTEs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ; make the PDE[<span style=color:#40a070>0</span>] <span style=color:#007020;font-weight:700>and</span> PDE[<span style=color:#40a070>0xC00</span>] point to the first PTE
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>or</span> eax,PG_US_U <span style=color:#666>|</span> PG_RW_RW <span style=color:#666>|</span> PG_P     ; set user page status
</span></span><span style=display:flex><span>        mov [PAGE_DIR_TABLE_POS <span style=color:#666>+</span> <span style=color:#40a070>0x0</span>],eax   ; the first PTE<span style=color:#4070a0>&#39;s place, mapping loader&#39;</span>s addr to itself
</span></span><span style=display:flex><span>        mov [PAGE_DIR_TABLE_POS <span style=color:#666>+</span> <span style=color:#40a070>0xC00</span>],eax ; the first PTE used by kernel, mapping to low <span style=color:#40a070>1</span>M
</span></span><span style=display:flex><span>        ; <span style=color:#40a070>0xC0000000</span> <span style=color:#666>~</span> <span style=color:#40a070>0xFFFFFFFF</span> belongs to kernel
</span></span><span style=display:flex><span>        sub eax,<span style=color:#40a070>0x1000</span>
</span></span><span style=display:flex><span>        mov [PAGE_DIR_TABLE_POS <span style=color:#666>+</span> <span style=color:#40a070>0xFFC</span>],eax  ; make the last Entry point to PDE itself
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ; creat PTE <span style=color:#007020;font-weight:700>for</span> kernel
</span></span><span style=display:flex><span>        mov ecx,<span style=color:#40a070>256</span>                          ; <span style=color:#40a070>1</span>M <span style=color:#666>/</span> <span style=color:#40a070>4</span>K <span style=color:#666>=</span> <span style=color:#40a070>256</span>
</span></span><span style=display:flex><span>        mov esi,<span style=color:#40a070>0</span>
</span></span><span style=display:flex><span>        mov edx,PG_US_U <span style=color:#666>|</span> PG_RW_RW <span style=color:#666>|</span> PG_P    ; User, RW, P
</span></span><span style=display:flex><span>        <span style=color:#666>.</span>SetupPage_CreatePTE:
</span></span><span style=display:flex><span>            mov [ebx <span style=color:#666>+</span> esi <span style=color:#666>*</span> <span style=color:#40a070>4</span>],edx
</span></span><span style=display:flex><span>            add edx,<span style=color:#40a070>0x1000</span>
</span></span><span style=display:flex><span>            inc esi
</span></span><span style=display:flex><span>        loop <span style=color:#666>.</span>SetupPage_CreatePTE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        mov eax,PAGE_DIR_TABLE_POS
</span></span><span style=display:flex><span>        add eax,<span style=color:#40a070>0x2000</span>                      ; second PTE
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>or</span> eax,PG_US_U <span style=color:#666>|</span> PG_RW_RW <span style=color:#666>|</span> PG_P
</span></span><span style=display:flex><span>        mov ebx,PAGE_DIR_TABLE_POS
</span></span><span style=display:flex><span>        mov ecx,<span style=color:#40a070>254</span>                         ; <span style=color:#40a070>1022</span> <span style=color:#666>-</span> <span style=color:#40a070>769</span> <span style=color:#666>+</span> <span style=color:#40a070>1</span>
</span></span><span style=display:flex><span>        mov esi,<span style=color:#40a070>769</span>                         ; start from <span style=color:#40a070>769</span>,the second PTE of kernel
</span></span><span style=display:flex><span>        <span style=color:#666>.</span>SetupPage_CreateKernelPDE:
</span></span><span style=display:flex><span>            mov [ebx <span style=color:#666>+</span> esi <span style=color:#666>*</span> <span style=color:#40a070>4</span>],eax
</span></span><span style=display:flex><span>            inc esi
</span></span><span style=display:flex><span>            add eax,<span style=color:#40a070>0x1000</span>
</span></span><span style=display:flex><span>        loop <span style=color:#666>.</span>SetupPage_CreateKernelPDE
</span></span><span style=display:flex><span>        ret
</span></span><span style=display:flex><span>; <span style=color:#666>----------</span> end of function SetupPage <span style=color:#666>----------</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; <span style=color:#666>----------</span> start of function ReadDiskSector_32
</span></span><span style=display:flex><span>; function MBR_ReadDiskSector_32(LBA_addr, writing_addr, n), read n sectors from hard<span style=color:#666>-</span>disk <span style=color:#007020;font-weight:700>in</span> <span style=color:#40a070>32</span> bit mode
</span></span><span style=display:flex><span>; esi: LBA addr of start sector
</span></span><span style=display:flex><span>; edi: writing addr
</span></span><span style=display:flex><span>; edx: n
</span></span><span style=display:flex><span>ReadDiskSector_32:
</span></span><span style=display:flex><span>    ; read sectors
</span></span><span style=display:flex><span>    mov ebx,edx                     ; bx keeps the n
</span></span><span style=display:flex><span>    mov ax,bx                       ; n sectors
</span></span><span style=display:flex><span>    mov dx,<span style=color:#40a070>0x1F2</span>                    ; set reg Sector count 
</span></span><span style=display:flex><span>    out dx,al                       ; read n sectors
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ; set LBA addr
</span></span><span style=display:flex><span>    mov eax,esi
</span></span><span style=display:flex><span>    mov dx,<span style=color:#40a070>0x1F3</span>                    ; set reg LBA low
</span></span><span style=display:flex><span>    out dx,al                       ; write low <span style=color:#40a070>8</span> bits
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mov cl,<span style=color:#40a070>8</span>
</span></span><span style=display:flex><span>    shr eax,cl
</span></span><span style=display:flex><span>    mov dx,<span style=color:#40a070>0x1F4</span>                    ; set reg LBA mid
</span></span><span style=display:flex><span>    out dx,al                       ; write LBA mid
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    shr eax,cl
</span></span><span style=display:flex><span>    mov dx,<span style=color:#40a070>0x1F5</span>                    ; set reg LBA high
</span></span><span style=display:flex><span>    out dx,al                       ; write LBA high
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    shr eax,cl
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>and</span> al,<span style=color:#40a070>0xF</span>                      ; only <span style=color:#40a070>4</span> bits
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>or</span> al,<span style=color:#40a070>0xE0</span>                      ; <span style=color:#40a070>1110</span>b: LBA mode, disk: master
</span></span><span style=display:flex><span>    mov dx,<span style=color:#40a070>0x1F6</span>                    ; set reg device
</span></span><span style=display:flex><span>    out dx,al                       ; set mode <span style=color:#007020;font-weight:700>and</span> LBA addr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ; ready to read
</span></span><span style=display:flex><span>    mov dx,<span style=color:#40a070>0x1F7</span>                    ; set reg command
</span></span><span style=display:flex><span>    mov al,<span style=color:#40a070>0x20</span>                     ; mode: read
</span></span><span style=display:flex><span>    out dx,al                       ; <span style=color:#007020;font-weight:700>do</span> read
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ; check disk status
</span></span><span style=display:flex><span><span style=color:#666>.</span>ReadDiskSector_32_DiskNotReady:
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>in</span> al,dx                        ; get disk status
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>and</span> al,<span style=color:#40a070>0x88</span>                     ; result <span style=color:#40a070>0x8</span> <span style=color:#666>=&gt;</span> disk is read 
</span></span><span style=display:flex><span>                                    ; result <span style=color:#40a070>0x80</span> <span style=color:#666>=&gt;</span> disk is busy
</span></span><span style=display:flex><span>    cmp al,<span style=color:#40a070>0x08</span>
</span></span><span style=display:flex><span>    jnz <span style=color:#666>.</span>ReadDiskSector_32_DiskNotReady
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ; read data
</span></span><span style=display:flex><span>    mov ax,bx                       ; get n
</span></span><span style=display:flex><span>    mov dx,<span style=color:#40a070>256</span>                      ; read by word, so dx <span style=color:#666>=</span> <span style=color:#40a070>512</span> <span style=color:#666>/</span> <span style=color:#40a070>2</span>
</span></span><span style=display:flex><span>    mul dx                          ; assum this mul won<span style=color:#4070a0>&#39;t overflow</span>
</span></span><span style=display:flex><span>    mov cx,ax                       ; sum of words need to read
</span></span><span style=display:flex><span>    mov dx,<span style=color:#40a070>0x1F0</span>                    ; set reg data
</span></span><span style=display:flex><span><span style=color:#666>.</span>ReadDiskSector_32_ReadingLoop:
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>in</span> ax,dx                        ; read a word
</span></span><span style=display:flex><span>    mov [edi],ax                     ; write a word
</span></span><span style=display:flex><span>    add edi,<span style=color:#40a070>2</span>
</span></span><span style=display:flex><span>    loop <span style=color:#666>.</span>ReadDiskSector_32_ReadingLoop
</span></span><span style=display:flex><span>    ret
</span></span><span style=display:flex><span>; end of function ReadDiskSector_32
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>FatalKernelBroken:
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>0</span>],<span style=color:#4070a0>&#39;F&#39;</span>  
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>1</span>],<span style=color:#40a070>0xA4</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>2</span>],<span style=color:#4070a0>&#39;A&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>3</span>],<span style=color:#40a070>0xA4</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>4</span>],<span style=color:#4070a0>&#39;T&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>5</span>],<span style=color:#40a070>0xA4</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>6</span>],<span style=color:#4070a0>&#39;A&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>7</span>],<span style=color:#40a070>0xA4</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>8</span>],<span style=color:#4070a0>&#39;L&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>9</span>],<span style=color:#40a070>0xA4</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>10</span>],<span style=color:#4070a0>&#39;:&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>11</span>],<span style=color:#40a070>0xA4</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>12</span>],<span style=color:#4070a0>&#39; &#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>14</span>],<span style=color:#4070a0>&#39;K&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>16</span>],<span style=color:#4070a0>&#39;E&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>18</span>],<span style=color:#4070a0>&#39;R&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>20</span>],<span style=color:#4070a0>&#39;N&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>22</span>],<span style=color:#4070a0>&#39;E&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>24</span>],<span style=color:#4070a0>&#39;L&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>26</span>],<span style=color:#4070a0>&#39; &#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>28</span>],<span style=color:#4070a0>&#39;B&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>30</span>],<span style=color:#4070a0>&#39;R&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>32</span>],<span style=color:#4070a0>&#39;O&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>34</span>],<span style=color:#4070a0>&#39;K&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>36</span>],<span style=color:#4070a0>&#39;E&#39;</span>
</span></span><span style=display:flex><span>    mov byte [gs:<span style=color:#40a070>38</span>],<span style=color:#4070a0>&#39;N&#39;</span>
</span></span><span style=display:flex><span>    jmp <span style=color:#666>$</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>KernelInit:
</span></span><span style=display:flex><span>    mov eax,[KERNEL_BIN_BASE_ADDR]          ; check the magic number
</span></span><span style=display:flex><span>    cmp eax,<span style=color:#40a070>0x464c457f</span>
</span></span><span style=display:flex><span>    jne FatalKernelBroken  
</span></span><span style=display:flex><span>    mov al,[KERNEL_BIN_BASE_ADDR <span style=color:#666>+</span> <span style=color:#40a070>4</span>]       ; make sure it is a <span style=color:#40a070>32</span> bits elf 
</span></span><span style=display:flex><span>    cmp al,<span style=color:#40a070>1</span>
</span></span><span style=display:flex><span>    jne FatalKernelBroken
</span></span><span style=display:flex><span>    mov al,[KERNEL_BIN_BASE_ADDR <span style=color:#666>+</span> <span style=color:#40a070>5</span>]       ; make sure it is a LSB elf
</span></span><span style=display:flex><span>    cmp al,<span style=color:#40a070>1</span>
</span></span><span style=display:flex><span>    jne FatalKernelBroken
</span></span><span style=display:flex><span>    ; check done
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mov ebx,[KERNEL_BIN_BASE_ADDR <span style=color:#666>+</span> <span style=color:#40a070>28</span>]     ; offset of program header table
</span></span><span style=display:flex><span>    add ebx,KERNEL_BIN_BASE_ADDR            ; address of program header table 
</span></span><span style=display:flex><span>    xor edx,edx
</span></span><span style=display:flex><span>    mov dx,[KERNEL_BIN_BASE_ADDR <span style=color:#666>+</span> <span style=color:#40a070>42</span>]     ; program header size
</span></span><span style=display:flex><span>    mov cx,[KERNEL_BIN_BASE_ADDR <span style=color:#666>+</span> <span style=color:#40a070>44</span>]      ; sum of segments
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#666>.</span>LoadKernelEachSegment:
</span></span><span style=display:flex><span>        cmp byte [ebx],PT_NULL              ; skip th null segment
</span></span><span style=display:flex><span>        je <span style=color:#666>.</span>LoadKernelEachSegment_PT_NULL
</span></span><span style=display:flex><span>        push dword [ebx <span style=color:#666>+</span> <span style=color:#40a070>16</span>]               ; nbytes, p_filesz
</span></span><span style=display:flex><span>        mov eax,[ebx <span style=color:#666>+</span> <span style=color:#40a070>4</span>]   
</span></span><span style=display:flex><span>        add eax,KERNEL_BIN_BASE_ADDR        ; src
</span></span><span style=display:flex><span>        push eax
</span></span><span style=display:flex><span>        push dword [ebx <span style=color:#666>+</span> <span style=color:#40a070>8</span>]                ; dst
</span></span><span style=display:flex><span>        call mem_cpy  
</span></span><span style=display:flex><span>        add esp,<span style=color:#40a070>12</span>                          ; unpush <span style=color:#40a070>3</span>
</span></span><span style=display:flex><span>        <span style=color:#666>.</span>LoadKernelEachSegment_PT_NULL:  
</span></span><span style=display:flex><span>        add ebx,edx                         ; skip the header
</span></span><span style=display:flex><span>    loop <span style=color:#666>.</span>LoadKernelEachSegment
</span></span><span style=display:flex><span>    ret
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>; <span style=color:#666>----------</span> function mem_cpy(dst,src,nbytes) <span style=color:#666>----------</span>
</span></span><span style=display:flex><span>mem_cpy:
</span></span><span style=display:flex><span>    push ebp
</span></span><span style=display:flex><span>    mov ebp,esp
</span></span><span style=display:flex><span>    push edi
</span></span><span style=display:flex><span>    push esi
</span></span><span style=display:flex><span>    push ecx
</span></span><span style=display:flex><span>    mov edi,[ebp <span style=color:#666>+</span> <span style=color:#40a070>8</span>]   ; dst
</span></span><span style=display:flex><span>    mov esi,[ebp <span style=color:#666>+</span> <span style=color:#40a070>12</span>]   ; src
</span></span><span style=display:flex><span>    mov ecx,[ebp <span style=color:#666>+</span> <span style=color:#40a070>16</span>]  ; nbytes
</span></span><span style=display:flex><span>    cld
</span></span><span style=display:flex><span>    rep movsb
</span></span><span style=display:flex><span>    pop ecx
</span></span><span style=display:flex><span>    pop esi
</span></span><span style=display:flex><span>    pop edi
</span></span><span style=display:flex><span>    leave
</span></span><span style=display:flex><span>    ret
</span></span></code></pre></div><p>kernel/main.c</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>_start</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#902000>int</span> i <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>while</span>(<span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        i<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>asm</span> <span style=color:#007020;font-weight:700>volatile</span>(
</span></span><span style=display:flex><span>            <span style=color:#4070a0>&#34;movb $</span><span style=color:#4070a0;font-weight:700>\&#39;</span><span style=color:#4070a0>K</span><span style=color:#4070a0;font-weight:700>\&#39;</span><span style=color:#4070a0>,%gs:6&#34;</span>
</span></span><span style=display:flex><span>           );
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>到现在为止，我们向屏幕输出了四个字符：&ldquo;MPVK&rdquo;，分别在 mbr，保护模式，分页模式，内核中输出，代表四模式的成功进入。</p><div style=text-align:center><img src=https://chujdk.github.io/usr/uploads/2021/05/1894295228.png></div><p>之后我们就可以以 C 为主进行开发了。</p><p>另外说一下，这里的引导应该说是不太完整的，相应的段属性都没有设置，之后应该会逐渐完善。</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/os>OS</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/chujdk rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=mailto:chujj31@gmail.com rel=me title=Mail><i data-feather=mail></i></a>
<a class=border></a><a class=soc href=https://chujdk.github.io/index.xml rel=me title=Rss><i data-feather=rss></i></a>
<a class=border></a></div><div class=footer-info>2024 © chuj | Based on <a href=https://github.com/athul/archie>Archie</a> | Built with <a href=https://gohugo.io>Hugo</a> | <a href=#>Goto Top</a></div></footer><script>feather.replace()</script></div></body></html>