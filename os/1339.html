<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>《操作系统真像还原》操作系统实现——中断 - blog of chuj</title><link rel=icon type=image/png href=https://www.cjovi.icu/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="中断这个东西说起来不是很难，实现起来比较麻烦，主要是和硬件有一定联系，会略显复杂。 宏观视角 宏观地来看，一个中断的过程就是 CPU 接受中断信号，然后"><meta property="og:image" content><meta property="og:title" content="《操作系统真像还原》操作系统实现——中断"><meta property="og:description" content="中断这个东西说起来不是很难，实现起来比较麻烦，主要是和硬件有一定联系，会略显复杂。 宏观视角 宏观地来看，一个中断的过程就是 CPU 接受中断信号，然后"><meta property="og:type" content="article"><meta property="og:url" content="https://www.cjovi.icu/os/1339.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-23T00:15:00+00:00"><meta property="article:modified_time" content="2021-05-23T00:15:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="《操作系统真像还原》操作系统实现——中断"><meta name=twitter:description content="中断这个东西说起来不是很难，实现起来比较麻烦，主要是和硬件有一定联系，会略显复杂。 宏观视角 宏观地来看，一个中断的过程就是 CPU 接受中断信号，然后"><script src=https://www.cjovi.icu/js/feather.min.js></script>
<link href=https://www.cjovi.icu/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.cjovi.icu/css/main.bfb8dec0e2220d86f104bd8230dbf2c35b583e46ccfef90bb620854db94ef7a5.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://www.cjovi.icu/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://www.cjovi.icu/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>《操作系统真像还原》操作系统实现——中断</h1><div class=meta>Posted on May 23, 2021</div></div><section class=body><p>中断这个东西说起来不是很难，实现起来比较麻烦，主要是和硬件有一定联系，会略显复杂。</p><h3 id=宏观视角>宏观视角</h3><p>宏观地来看，一个中断的过程就是 CPU 接受中断信号，然后执行对应的处理函数。这里的中断分外部中断和内部中断两种。</p><h4 id=外部中断>外部中断</h4><p>所谓外部中断，顾名思义就是外部设备产生的中断。CPU 中有两条型号线 <strong>INTR</strong>（<strong>INTeRrupt</strong>） 和 <strong>NMI</strong>（<strong>Non Maskable Interrupt</strong>）来接受外部中断信号。前者接受的是<strong>可屏蔽中断</strong>，后者则是<strong>不可屏蔽中断</strong>。</p><h5 id=可屏蔽中断>可屏蔽中断</h5><p>这种中断是各类外设向 CPU 发出的 ，由于不甚危急，CPU 可以选择不予理会。对于许多中断，也可以将对中断的响应和处理分开（Linux 就是这样做的）以加快对中断的响应速度。</p><p>对中断的屏蔽是通过 eflags 寄存器的 IF 位来实现的。此位为 1 的时候，CPU 不会再响应中断。</p><h5 id=不可屏蔽中断>不可屏蔽中断</h5><p>不可屏蔽中断往往代表非常严重的错误，往往会造成宕机，这种型号不能被屏蔽，任何时候 CPU 收到此型号都需要立即进行处理。</p><h4 id=内部中断>内部中断</h4><p>内部中断往往是由软件产生的，分为软中断和异常。</p><p>软中断大多由软件自己调用，一般的语法为 <code>int 8 位立即数</code>，此指令较常用，Linux 中就是通过 <code>int 0x80</code> 来进行系统调用的。类似的指令还有 <code>int3</code>（实现下断点）等。</p><p>异常则是运行时的错误，比如缺页异常、除数为零等。</p><p>内部中断<strong>往往不可屏蔽</strong>，因为如果屏蔽了这些中断往往会影响正常运行。比如如果屏蔽用户发出的软中断，就可能造成用户希望进行的系统调用无法执行，又比如屏蔽了缺页异常，就可能造成无法正确执行代码，所以这些中断不受 IF 控制。</p><h3 id=底层视角>底层视角</h3><p>CPU 对中断的响应必然需要通过特定的函数来响应，由于中断数量非常多（处理器支持 256 个中断，编号 0 ~ 255），自然需要一个数据结构来维护响应的函数并在中断到来时进行响应，这个结构就是中断描述符表。</p><h4 id=中断描述符表>中断描述符表</h4><p>和 GDT 类似，<strong>中断描述符表</strong>（<strong>IDT</strong>，<strong>Interrupt Descriptor Table</strong>）也是一个类似于数组的数据结构，通过中断号就可以寻址到每个特定的描述符项。特别的，一般情况下中断都会伴随着特权级的切换（比如系统调用进入内核态），为了实现这个切换，需要用到门，四个门中我们选用中断门（事实上，中断门只允许放在 IDT 中，可见两者有多么搭配），其结构为</p><p>高 32 位：</p><table><thead><tr><th>31~ 16</th><th>15</th><th>14 ~ 13</th><th>12</th><th>11 ~ 8</th><th>7</th><th>6</th><th>5</th><th>4 ~ 0</th></tr></thead><tbody><tr><td>中断处理程序在段中的偏移的<br>31 ~ 16 位</td><td>P</td><td>DPL</td><td>S = 0</td><td>TYPE</td><td>0</td><td>0</td><td>0</td><td>未使用</td></tr></tbody></table><p>低 32 位：</p><table><thead><tr><th>31 ~ 16</th><th>15 ~ 0</th></tr></thead><tbody><tr><td>中断处理程序的段选择子值</td><td>中断处理程序在段中的偏移的 15 ~ 0</td></tr></tbody></table><p>我们就在中断描述符表的每一项里放入中断门（事实上 IDT 中只存放门），这样就可以在中断到来时通过中断门来进行相应的处理。</p><p>每个中断门的结构可以用这样一个结构体来表示</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* interrupt gate descriptor */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>INT_gate_desc</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#902000>uint16_t</span> function_offset_low_word;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint16_t</span> selector;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint8_t</span> dword_count; <span style=color:#60a0b0;font-style:italic>/* fixed value */</span>
</span></span><span style=display:flex><span>    <span style=color:#902000>uint8_t</span> attribute;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint16_t</span> function_offset_high_word;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>通过建立一个结构体数组就可以建立起 IDT</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>INT_gate_desc</span> IDT[IDT_DESC_SUM]; <span style=color:#60a0b0;font-style:italic>/* Interrupt Descriptor Table */</span>
</span></span></code></pre></div><p>通过 <code>lidt 48 位数</code> 可以设置 LDTR 寄存器，类似于 GDTR，存储了 LDT 表的基址。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* load IDT */</span>
</span></span><span style=display:flex><span>    <span style=color:#902000>uint64_t</span> idt_operand <span style=color:#666>=</span> ((<span style=color:#007020;font-weight:700>sizeof</span>(IDT) <span style=color:#666>-</span> <span style=color:#40a070>1</span>) <span style=color:#666>|</span> ((<span style=color:#902000>uint64_t</span>)((<span style=color:#902000>uint32_t</span>) IDT <span style=color:#666>&lt;&lt;</span> <span style=color:#40a070>16</span>)));
</span></span><span style=display:flex><span>    __asm__ <span style=color:#06287e>volatile</span> (<span style=color:#4070a0>&#34;lidt %0&#34;</span><span style=color:#666>:</span> <span style=color:#666>:</span> <span style=color:#4070a0>&#34;m&#34;</span> (idt_operand));
</span></span></code></pre></div><p>这样就设置好了 LDT 表。</p><h4 id=中断处理过程>中断处理过程</h4><p>光有 IDT 肯定不够，还需要一个动态的过程来处理整个中断。下面先总结一下中断处理的过程</p><ul><li>外中断：外设向 CPU 发送中断信号，通过中断代理芯片的转换调度后使 CPU 收到中断，CPU 对 IDT 查表后执行对应的中断处理程序</li><li>内中断：CPU 对 IDT 查表后执行对应的中断处理程序</li></ul><p>若暂且不考虑硬件层面的处理，可知中断的处理过程主要就是查表执行，这个过程具体如下</p><ol><li>处理器根据中断号查表得到中断门。这个过程比较容易，只要将中断号 * 8 加上 IDTR 就可以了。</li><li>特权级检查：对于软中断，保证数值上 CPL &lt;= 中断门的 DPL，数值上 CPL >= 目标代码的 DPL；对于外中断，只要满足数值上 CPL >= 目标代码的 DPL 就可以了。</li><li>执行中断处理程序</li></ol><p>执行中断处理程序时，首先通过 IDT 和 GDT 协同的方式计算出目标代码的位置，也就是获得 IDT 中的段选择子后通过 GDT 计算出基地址再加上 IDT 中的偏移来计算。</p><p>跳转至目标函数的时候会进行多次压栈操作，首先处理特权级转移时栈寄存器的保存问题，即如果存在特权级转移，就将旧的 ss 和 esp 寄存器压入栈中。然后压入 eflags 进行备份，再压入 cs 和 eip 备份原来的代码地址，最后根据是否有异常错误码压入错误码，最后跳至异常处理函数处执行。注意在压入 eflags 备份之后、跳至异常处理函数执行之前 eflags 的 IF 位会被置 0，此时处理器不再接受可屏蔽中断，以避免相同中断嵌套造成 GP 中断。</p><p>对应于压栈过程，有 iret 语句来处理返回的情况，然而，iret 默认没有错误码的，也就是说，编写异常处理函数的人必须手动地清理掉错误码。一种解决方案是在函数开头时根据有无错误码进行一次压栈操作（异常有无错误码压栈是事先已知的，可以直接在编译期完成判断），这样在返回前就可以一并清空栈空间，避免代码冗余。</p><p><em>关于错误码：一般只有外部中断才会压入中断码。</em></p><h4 id=关于特权级检查>关于特权级检查</h4><p>对于软中断，经过了两步特权级检查：</p><ul><li>第一步是数值上 CPL &lt;= 中断门的 DPL。CPL 大于 DPL 代表调用者有调用该门的权限，这里检查的是权限级别。</li><li>第二步是数值上 CPL >= 目标代码的 DPL。CPL 大于目标代码的 DPL，代表特权级向高处转移，这里检查的是操作的合法性，是保证特权级只向高处转移（仅在返回时向低处转移）。</li></ul><p>外部中断比较简单，可以和软中断的第二步类比。</p><h4 id=总结>总结</h4><p>从内核外面向里面来看，一个中断的处理过程就是硬件或进程向 CPU 发送中断信号，CPU 通过 IDT 取得中断有关的信息（处理程序的段选择子和偏移地址以及权限信息），通过特权级检查后调用中断处理程序。而对应的中断处理程序需要处理好中断，并在返回前清理栈中的错误码。</p><h3 id=硬件视角>硬件视角</h3><p>这个主要是针对外部中断的，比较复杂。</p><p>CPU 自己无法接受所有的中断，因为每个中断都需要一条数据线接到 CPU 上的话，会导致 CPU 体积的大幅膨胀，为了解决这个问题，Intel 推出了一系列的中断代理芯片来进行对中断的缓冲，该芯片可以暂存并挑选中断后，将选中的中断发送给 CPU。这个系列就是 8259A 可编程中断控制器。书上花了大量篇幅介绍该芯片，我觉得不是很有必要，毕竟我们是在学习操作系统而不是硬件，而且花了很久看完我也基本上全忘了。我这里只随便说一下我记得的东西，具体操作方法不再赘述。</p><p>该芯片每一张都有 8 个接口来接入外设，一个接口来输出中断信号，通过级联（类似于电路中的串联，把一个芯片（从片）的输出口接入另一个芯片（主片）的输入口）的方法可以实现接口的扩展。每个外设都将其信号线接到芯片组的一个接口上，当有中断信号发出时，芯片组会接受信号并暂存（每个接口都对应了一个寄存器对中断信号进行处理），起到缓存的作用，并在合适的时机将信号发送给 CPU。</p><p>别的不记得了。需要用的时候再查吧。</p><p>内部中断在硬件层面上的工作方式我们不关心，因为其实这个不需要我们进行硬件层面的控制。</p><h3 id=时钟>时钟</h3><p>时钟分内部时钟和外部时钟，内部时钟在主板上，我们不可控，外部时钟往往由可编程芯片控制，我们通过与对应芯片 IO 可以设置时钟频率。</p><p>以 8253 芯片为例，其振晶发出的脉冲信号频率为 1.19318 MHZ，在芯片内部有一个计数器，计数器的结构这里不说了，每次芯片接受到脉冲信号时，计数器会减一，减到 0 时，会通过 OUT 端向 CPU 发出中断信号（实际上是由中断代理芯片代理接受的）。</p><p>此芯片有 6 中工作模式，我们使用其比率发生模式，设置其计数器起始值，然后芯片就会从起始值开始自减，减到 0 后会自动复位到我们设置的起始值进行下一轮自减。通过设置计数器起始值，我们可以控制中断的频率，公式为 起始值 = 1.19318MHZ / 中断频率。</p><h3 id=实现>实现</h3><p>代码比较多，这里也就不放了，可以看笔者的 <a href=https://github.com/chujDK/chuj-elephant-os/commit/31e2055bc3e257875d372ca95c3b673ec90b182d>commit</a>。</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/os>OS</a></li></ul></nav></div><script src=https://giscus.app/client.js data-repo=chujDK/chujdk.github.io data-repo-id=R_kgDOI__mNg data-category=Announcements data-category-id=DIC_kwDOI__mNs4CYoyP data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/chujdk rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=mailto:chujj31@gmail.com rel=me title=Mail><i data-feather=mail></i></a>
<a class=border></a></div><div class=footer-info>&nbsp2020 ~ 2023  © chuj |  Based on <a href=https://github.com/athul/archie>Archie</a> | Built with <a href=https://gohugo.io>Hugo</a> | <a href=#>Goto Top</a></div></footer><script>feather.replace()</script></div></body></html>