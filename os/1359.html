<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>《操作系统真像还原》操作系统实现——线程和锁 - blog of chuj</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="这篇文章写的比较乱且简略，要看的话建议跟着代码一起看。本文代码在此处 线程和进程是操作系统的重要概念。 线程和进程的区别 这似乎是一个面试中常见的"><meta property="og:image" content><meta property="og:title" content="《操作系统真像还原》操作系统实现——线程和锁"><meta property="og:description" content="这篇文章写的比较乱且简略，要看的话建议跟着代码一起看。本文代码在此处 线程和进程是操作系统的重要概念。 线程和进程的区别 这似乎是一个面试中常见的"><meta property="og:type" content="article"><meta property="og:url" content="https://chujdk.github.io/os/1359.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-03T16:19:00+00:00"><meta property="article:modified_time" content="2021-06-03T16:19:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="《操作系统真像还原》操作系统实现——线程和锁"><meta name=twitter:description content="这篇文章写的比较乱且简略，要看的话建议跟着代码一起看。本文代码在此处 线程和进程是操作系统的重要概念。 线程和进程的区别 这似乎是一个面试中常见的"><script src=https://chujdk.github.io/js/feather.min.js></script>
<link href=https://chujdk.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://chujdk.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://chujdk.github.io/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://chujdk.github.io/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>《操作系统真像还原》操作系统实现——线程和锁</h1><div class=meta>Posted on Jun 3, 2021</div></div><section class=body><p>这篇文章写的比较乱且简略，要看的话建议跟着代码一起看。本文代码在<a href=https://github.com/chujDK/chuj-elephant-os/tree/thread_and_lock>此处</a></p><p>线程和进程是操作系统的重要概念。</p><h3 id=线程和进程的区别>线程和进程的区别</h3><p>这似乎是一个面试中常见的问题了哈哈哈，这里我可能无法给出教科书级别的解释（实际上那也未必是最好的解释），只写一下自己的理解。</p><p>先考虑一下线程存在的意义，如果一个计算机系统是单线程的（即不能并发），显然这个机器也是可以工作的，但是每个线程在工作的时候可能会进行各种 IO 操作，此时进程会因为需要等待 IO（等待的时间的数量级可能是秒级的，相对于处理器和时钟的频率来讲非常巨大）而造成处理器的空转，这是极度浪费的。如果我们可以在等待的时间将处理器分配给别的线程，就可以大幅提高效率。又或者计算机上存在两个线程，一个需要运行数天时间，一个仅需几秒，由于前一个线程先上处理器运行，所以仅需几秒的线程就需要等待大量的时间才能执行。并发（由多线程实现）可以有效的解决这个问题。</p><p>而进程存在的意义，则主要是系统资源的隔离。一种常见的隔离方式是给每个进程分配不同的页表，这样虽然每个进程可能会有相同的虚拟地址，但是他们映射到的物理地址却是截然不同的，这样就将主存有效的隔离了开来。</p><p>有趣的是，在调度时，实际上是以线程为单位的，在此时进程实际上不再存在了。</p><h3 id=线程的类型>线程的类型</h3><p>根据内存管理器所处的优先级，分为两种线程，内核线程和用户态线程</p><ul><li>内核线程：优点是用户使用起来方便，缺陷在于由于需要进行特权级的切换，相对比较慢</li><li>用户态线程：优点是速度上会快许多（节省了系统调用的开销），缺陷是由于需要用户自己管理线程的调度，增加了开发难度，一般是由一些库来进行统一管理，比如 glibc 的 pthread 等。</li></ul><p>两种管理方式各有优劣，作为折中，现代操作系统将两者结合，在阻塞的时候使用内核线程，非阻塞时使用用户态线程。</p><h3 id=线程的管理>线程的管理</h3><p>主要需要：</p><ol><li>线程的创建和销毁</li><li>线程的特权级变更</li><li>线程的轮询和调度</li></ol><h4 id=pcb>PCB</h4><p>进程控制块（Process Control Block，<strong>PCB</strong>）是一种用于控制进程的结构体，相当于一个进程的身份证，我们用它也可以一起控制线程。一种简单的结构如下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>task_struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#902000>uint32_t</span> <span style=color:#666>*</span>self_kernel_stack;
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>enum</span> <span style=color:#0e84b5;font-weight:700>task_status</span> status;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint8_t</span> priority; <span style=color:#60a0b0;font-style:italic>/* how many ticks the thread running per round */</span>
</span></span><span style=display:flex><span>    <span style=color:#902000>char</span> name[<span style=color:#40a070>16</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#902000>uint8_t</span> cpu_ticks_left;
</span></span><span style=display:flex><span>    <span style=color:#902000>uint8_t</span> cpu_ticks_elapsed;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>list_elem</span> general_tag;
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>list_elem</span> all_list_tag;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    size_t PDE_addr;
</span></span><span style=display:flex><span>    size_t canary;
</span></span><span style=display:flex><span>}PCB;
</span></span></code></pre></div><p>使用 self_kernel_stack 来指向线程在内核态下使用的栈的栈顶，这样可以解决线程在特权级变更时的栈转移问题。</p><p>结构体中的 list_elem 结构体是一个双向链表，通过这个链表将所有线程的 PCB 串了起来，即可在轮询的时候进行遍历了。</p><p>cpu_ticks_left 表示当前的线程还可以运行多少个 ticks，以一个时钟中断为 1 tick。cpu_ticks_elapsed 则是线程已运行的 ticks。</p><p>用 task_status 枚举线程的状态</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>enum</span> <span style=color:#0e84b5;font-weight:700>task_status</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    TASK_RUNNING,
</span></span><span style=display:flex><span>    TASK_READY,
</span></span><span style=display:flex><span>    TASK_BLOCKD,
</span></span><span style=display:flex><span>    TASK_WAITING,
</span></span><span style=display:flex><span>    TASK_HANGING,
</span></span><span style=display:flex><span>    TASK_DIED
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=轮询和调度>轮询和调度</h4><p>这里的管理使用简单的轮询机制，每次时钟中断更新当前线程的 cpu_ticks_left，并在这个线程结束时把它换下 CPU。</p><h3 id=上下文保护>上下文保护</h3><p>调度的过程最重要的是上下文保护，此处的调度是对同一个优先级，同一个进程的不同线程的调度，需要进行两次上下文保护</p><p>首先是中断时的上下文保护</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#666>%</span>macro VECTOR <span style=color:#40a070>2</span>                                 ; VECTOR INTnumber <span style=color:#06287e>HAS</span>(NONE)_ERROR_CODE
</span></span><span style=display:flex><span>section .text
</span></span><span style=display:flex><span>INTR<span style=color:#666>%</span><span style=color:#40a070>1</span><span style=color:#002070;font-weight:700>Entry</span>:
</span></span><span style=display:flex><span>    <span style=color:#666>%</span><span style=color:#40a070>2</span>                                          ; make all kinds of INTeRrupt
</span></span><span style=display:flex><span>                                                ; has the same stack <span style=color:#007020;font-weight:700>struct</span>
</span></span><span style=display:flex><span>                                                <span>; </span><span style=color:#0e84b5;font-weight:700>means</span> a <span style=color:#902000>int</span> with error code, push noting
</span></span><span style=display:flex><span>                                                ; a <span style=color:#902000>int</span> without error code, push a <span style=color:#4070a0>&#34;error code&#34;</span>
</span></span><span style=display:flex><span>    push ds
</span></span><span style=display:flex><span>    push es
</span></span><span style=display:flex><span>    push fs
</span></span><span style=display:flex><span>    push gs
</span></span><span style=display:flex><span>    pushad                                      ; save the context
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    ; send <span style=color:#06287e>EOI</span>(End Of Interrupt) to the <span style=color:#40a070>8259</span>A
</span></span><span style=display:flex><span>    mov al,<span style=color:#40a070>0x20</span>                                 ; EOI
</span></span><span style=display:flex><span>    out <span style=color:#40a070>0xa0</span>,al                                 ; send to slave
</span></span><span style=display:flex><span>    out <span style=color:#40a070>0x20</span>,al                                 ; send to master
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    push <span style=color:#666>%</span><span style=color:#40a070>1</span>                                     ; push it anyway
</span></span><span style=display:flex><span>    call [idt_table <span style=color:#666>+</span> <span style=color:#666>%</span><span style=color:#40a070>1</span> <span style=color:#666>*</span> <span style=color:#40a070>4</span>]                   ; the the C function
</span></span><span style=display:flex><span>    jmp IntExit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>section .data
</span></span><span style=display:flex><span>    dd INTR<span style=color:#666>%</span><span style=color:#40a070>1</span>Entry
</span></span><span style=display:flex><span><span style=color:#666>%</span>endmacro
</span></span></code></pre></div><p>以上为中断的入口（IDT 向量表中指向的函数），这里是将线程的上下文完全保护的，所以在离开时也恢复的所有的寄存器</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>section .text
</span></span><span style=display:flex><span>global IntExit                            
</span></span><span style=display:flex><span>; <span style=color:#666>----------</span> <span style=color:#007020;font-weight:700>this</span> function mainly restored the context <span style=color:#666>----------</span>
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>IntExit</span>:
</span></span><span style=display:flex><span>    add esp,<span style=color:#40a070>4</span>                                   ; pass the <span style=color:#902000>int</span> number
</span></span><span style=display:flex><span>    popad
</span></span><span style=display:flex><span>    pop gs
</span></span><span style=display:flex><span>    pop fs
</span></span><span style=display:flex><span>    pop es
</span></span><span style=display:flex><span>    pop ds                                      ; restore the context
</span></span><span style=display:flex><span>    add esp,<span style=color:#40a070>4</span>                                   ; pass the error code
</span></span><span style=display:flex><span>    iretd
</span></span></code></pre></div><p>而进入中断后，对于时钟中断的中断处理函数就是我们的线程调度器</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>void</span> <span style=color:#06287e>IntTimerHandler</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>task_struct</span><span style=color:#666>*</span> current_thread <span style=color:#666>=</span> GetCurrentThreadPCB();
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* detect stack overflow */</span>
</span></span><span style=display:flex><span>    ASSERT(current_thread<span style=color:#666>-&gt;</span>canary <span style=color:#666>==</span> STACK_CANARY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    current_thread<span style=color:#666>-&gt;</span>cpu_ticks_elapsed<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>    ticks<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (current_thread<span style=color:#666>-&gt;</span>cpu_ticks_left <span style=color:#666>==</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ScheduleThread();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        current_thread<span style=color:#666>-&gt;</span>cpu_ticks_left<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>到这里，如果不需要进行线程调度，那么直接退出 IntExit 函数上，恢复线程上下文即可。</p><p>如果需要进行线程调度，就会执行 ScheduleThread() 函数</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>ScheduleThread</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ASSERT(GetIntStatus() <span style=color:#666>==</span> INT_OFF);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>task_struct</span><span style=color:#666>*</span> current_thread <span style=color:#666>=</span> GetCurrentThreadPCB();
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (current_thread<span style=color:#666>-&gt;</span>status <span style=color:#666>==</span> TASK_RUNNING)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ASSERT(<span style=color:#666>!</span>elem_find(<span style=color:#666>&amp;</span>ready_thread_list, <span style=color:#666>&amp;</span>current_thread<span style=color:#666>-&gt;</span>general_tag));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        list_append(<span style=color:#666>&amp;</span>ready_thread_list, <span style=color:#666>&amp;</span>current_thread<span style=color:#666>-&gt;</span>general_tag);
</span></span><span style=display:flex><span>        current_thread<span style=color:#666>-&gt;</span>cpu_ticks_left <span style=color:#666>=</span> current_thread<span style=color:#666>-&gt;</span>priority;
</span></span><span style=display:flex><span>        current_thread<span style=color:#666>-&gt;</span>status <span style=color:#666>=</span> TASK_READY;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>// noting to do for now
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ASSERT(<span style=color:#666>!</span>list_empty(<span style=color:#666>&amp;</span>ready_thread_list));
</span></span><span style=display:flex><span>    thread_tag <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* get the first READY task, send it to the CPU */</span>
</span></span><span style=display:flex><span>    thread_tag <span style=color:#666>=</span> list_pop(<span style=color:#666>&amp;</span>ready_thread_list);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>task_struct</span><span style=color:#666>*</span> next_thread <span style=color:#666>=</span> elem2entry(<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>task_struct</span>, \
</span></span><span style=display:flex><span>                                          general_tag, thread_tag);
</span></span><span style=display:flex><span>    next_thread<span style=color:#666>-&gt;</span>status <span style=color:#666>=</span> TASK_RUNNING;
</span></span><span style=display:flex><span>    switch_to(current_thread, next_thread);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>前面是对双向链表的操作，需要把当前的线程，也就是将要被换下 CPU 的线程放到 ready_thread_list 的队尾，并且取出 ready_thread_list 的队头，准备进行线程的切换，这个切换函数也比较简单</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>[bits <span style=color:#40a070>32</span>]
</span></span><span style=display:flex><span>section .text
</span></span><span style=display:flex><span>global switch_to
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>switch_to</span>:
</span></span><span style=display:flex><span>; callee only backup esi, edi, ebx, ebp <span style=color:#007020;font-weight:700>for</span> caller
</span></span><span style=display:flex><span>    push esi
</span></span><span style=display:flex><span>    push edi
</span></span><span style=display:flex><span>    push ebx
</span></span><span style=display:flex><span>    push ebp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mov eax,[esp <span style=color:#666>+</span> <span style=color:#40a070>20</span>]      ; get current_thread
</span></span><span style=display:flex><span>    mov [eax],esp           ; store current stack top to self_kernel_stack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mov eax,[esp <span style=color:#666>+</span> <span style=color:#40a070>24</span>]      ; get next_thread
</span></span><span style=display:flex><span>    mov esp,[eax]           ; get next_thread<span>&#39;</span>s self_kernel_stack back
</span></span><span style=display:flex><span>    pop ebp
</span></span><span style=display:flex><span>    pop ebx
</span></span><span style=display:flex><span>    pop edi
</span></span><span style=display:flex><span>    pop esi   
</span></span><span style=display:flex><span>    ret
</span></span></code></pre></div><p>可见这里仅备份了当前线程的 esi，edi，ebx，ebp，然后更新了当前线程 PCB 的栈顶指针，并用下一个线程的 PCB 的栈顶指针更新 esp，然后也仅还原 esi，edi，ebx，ebp。这里看起来比较难以理解，好像是有问题的，但是实际上这是一个很巧妙的实现。</p><p>首先 switch_to 函数在执行了 <code>mov esp,[eax]</code> 后其实就已经转到了下一个线程了，因为此时已经在另一个线程的栈上了。</p><p>然后用一张图来解释</p><div style=text-align:center><img src=https://www.cjovi.icu/usr/uploads/2021/06/1894143311.jpg></div><p>每一个被换下的线程的中断处理函数出口都是还没有被执行的，所以在切换完线程后，线程的上下文会通过未执行的中断处理函数出口来恢复。</p><p>接下来再解释 switch_to 中仅保护 esi，edi，ebx，ebp 的原因，由于这个函数实际上是由 ScheduleThread 函数调用的，根据 gcc 编译器的 ABI 约定，主调函数会自己保存处理 esi，edi，ebx，ebp 之外的寄存器，所以这里只要保存这四个寄存器就可以了。</p><p>main 函数为</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;print.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;init.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;debug.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;memory.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;thread.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;interrupt.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>KThreadTest</span>(<span style=color:#902000>void</span> <span style=color:#666>*</span>arg);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>_start</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    sys_putstr(<span style=color:#4070a0>&#34;this is kernel!</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#902000>char</span> a[<span style=color:#40a070>16</span>];
</span></span><span style=display:flex><span>    InitAll();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ThreadStart(<span style=color:#4070a0>&#34;KThreadTest&#34;</span>, <span style=color:#40a070>31</span>, KThreadTest, <span style=color:#4070a0>&#34;argA &#34;</span>);
</span></span><span style=display:flex><span>    ThreadStart(<span style=color:#4070a0>&#34;KThreadTest&#34;</span>, <span style=color:#40a070>8</span>, KThreadTest, <span style=color:#4070a0>&#34;argB &#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    EnableInt();
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>while</span>(<span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        sys_putstr(<span style=color:#4070a0>&#34;main &#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>KThreadTest</span>(<span style=color:#902000>void</span> <span style=color:#666>*</span>arg)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#902000>char</span> <span style=color:#666>*</span>para <span style=color:#666>=</span> (<span style=color:#902000>char</span> <span style=color:#666>*</span>) arg;
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>while</span>(<span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        sys_putstr(arg);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行的效果为</p><div style=text-align:center><img src=https://www.cjovi.icu/usr/uploads/2021/06/3691898066.png></div><p>可以看到线程调度起效，特别的，出现了 GP 错误，这是输出没有加锁造成的临界区错误。</p><h3 id=使用锁进行临界区保护>使用锁进行临界区保护</h3><p>有这些概念需要过一下，很简单很好理解</p><ul><li>公共资源：会被超过一个线程访问的内存资源</li><li>临界区：访问公共资源的<strong>代码</strong></li><li>信号量：一个有初值的计数器，减到 0 时代表信号的改变（从可使用变成不可使用）</li><li>P 操作：减小信号量</li><li>V 操作：增加信号量</li><li>锁：维护信号量和锁的持有者、等待者的数据结果</li><li>互斥锁：信号量初值为 1 的锁（即锁最多只有一个持有者）</li><li>阻塞：线程由于各种原因（此处为取锁失败）将自己阻塞，注意这是线程自己的行为，一个线程不能被别的线程阻塞；对应的别的线程可以恢复被阻塞的线程，此处使用锁的持有者在释放锁时恢复的。</li></ul><p>之前的输出中出现 GP 错误（GP 的一种情况是非法内存访问）就是典型的临界区错误，考虑这样一个情况，线程 A 开启了显卡的光标设置端口，在写入光标值低 8 位前一刻由于时间片耗尽，被换下处理器，线程 B 也开启显卡的光标设置端口，在写入光标值高 8 位前一刻由于时间片耗尽，Ａ 又被换上处理器，这样低 8 位值就会被写到 8 八位上，造成光标值更新错误。</p><p>一种简单粗暴的解决方法是在所有的临界区操作前关中断，操作后开终端，这样是有效的，但是实际上违背了多线程的充分利用系统资源的目标，因为许多临界区操作都是设备 IO 操作，如果暴力的开关中断，那么在此线程等待设备 IO 的时候别的线程就不能执行，CPU 仍然是空转。</p><p>所以就可以引入锁，首先解决输出临界区的问题，由于只有一个输出设备，所以可以使用互斥锁。</p><p>取得锁的操作为</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>sys_lock_lock</span>(<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>lock</span> <span style=color:#666>*</span>plock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (plock<span style=color:#666>-&gt;</span>holder <span style=color:#666>!=</span> GetCurrentThreadPCB())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        SemaphoreDown(<span style=color:#666>&amp;</span>plock<span style=color:#666>-&gt;</span>semaphore); 
</span></span><span style=display:flex><span>        plock<span style=color:#666>-&gt;</span>holder <span style=color:#666>=</span> GetCurrentThreadPCB();
</span></span><span style=display:flex><span>        ASSERT(plock<span style=color:#666>-&gt;</span>holder_repeat_request_sum <span style=color:#666>==</span> <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>        plock<span style=color:#666>-&gt;</span>holder_repeat_request_sum <span style=color:#666>=</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        plock<span style=color:#666>-&gt;</span>holder_repeat_request_sum<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>函数 <code>SemaphoreDown</code> 为 P 操作，若信号量为 1，代表没有线程持有该锁，将信号量减 1 并返回，获得锁，否则阻塞自己</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>SemaphoreDown</span>(<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>semaphore</span><span style=color:#666>*</span> psema)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>enum</span> <span style=color:#0e84b5;font-weight:700>int_status</span> old_int_statu <span style=color:#666>=</span> DisableInt();
</span></span><span style=display:flex><span>    PCB<span style=color:#666>*</span> current_thread <span style=color:#666>=</span> GetCurrentThreadPCB();
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>while</span>(psema<span style=color:#666>-&gt;</span>value <span style=color:#666>==</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ASSERT(<span style=color:#666>!</span>elem_find(<span style=color:#666>&amp;</span>psema<span style=color:#666>-&gt;</span>waiting_thread_list, <span style=color:#666>&amp;</span>current_thread<span style=color:#666>-&gt;</span>general_tag));
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (elem_find(<span style=color:#666>&amp;</span>psema<span style=color:#666>-&gt;</span>waiting_thread_list, <span style=color:#666>&amp;</span>current_thread<span style=color:#666>-&gt;</span>general_tag))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            PANIC(<span style=color:#4070a0>&#34;thread already in wating list&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        list_append(<span style=color:#666>&amp;</span>psema<span style=color:#666>-&gt;</span>waiting_thread_list, <span style=color:#666>&amp;</span>current_thread<span style=color:#666>-&gt;</span>general_tag);
</span></span><span style=display:flex><span>        BlockThread(TASK_BLOCKD);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    psema<span style=color:#666>-&gt;</span>value<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>    SetIntStatus(old_int_statu);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>类似的有释放锁的操作</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>sys_lock_unlock</span>(<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>lock</span><span style=color:#666>*</span> plock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ASSERT(plock<span style=color:#666>-&gt;</span>holder <span style=color:#666>==</span> GetCurrentThreadPCB());
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (plock<span style=color:#666>-&gt;</span>holder_repeat_request_sum <span style=color:#666>&gt;</span> <span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        plock<span style=color:#666>-&gt;</span>holder_repeat_request_sum<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ASSERT(plock<span style=color:#666>-&gt;</span>holder_repeat_request_sum <span style=color:#666>==</span> <span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>    plock<span style=color:#666>-&gt;</span>holder_repeat_request_sum <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>    plock<span style=color:#666>-&gt;</span>holder <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>    SemaphoreUp(<span style=color:#666>&amp;</span>plock<span style=color:#666>-&gt;</span>semaphore);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>SemaphoreUp</span>(<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>semaphore</span><span style=color:#666>*</span> psema)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>enum</span> <span style=color:#0e84b5;font-weight:700>int_status</span> old_int_statu <span style=color:#666>=</span> DisableInt();
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>list_empty(<span style=color:#666>&amp;</span>psema<span style=color:#666>-&gt;</span>waiting_thread_list))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        PCB<span style=color:#666>*</span> thread_blocked <span style=color:#666>=</span> elem2entry(PCB, general_tag, \
</span></span><span style=display:flex><span>        list_pop(<span style=color:#666>&amp;</span>psema<span style=color:#666>-&gt;</span>waiting_thread_list));
</span></span><span style=display:flex><span>        UnblockThread(thread_blocked); 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    psema<span style=color:#666>-&gt;</span>value<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>    SetIntStatus(old_int_statu);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>新增一个控制台设备，用于输出</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;console.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;print.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;stdint.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;sync.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>lock</span> console_lock;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>ConsoleInit</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    LockInit(<span style=color:#666>&amp;</span>console_lock);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>ConsoleAcquire</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    sys_lock_lock(<span style=color:#666>&amp;</span>console_lock);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>ConsoleRelease</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    sys_lock_unlock(<span style=color:#666>&amp;</span>console_lock);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>console_putstr</span>(<span style=color:#902000>char</span> <span style=color:#666>*</span>str)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ConsoleAcquire();
</span></span><span style=display:flex><span>    <span style=color:#902000>int</span> output_num <span style=color:#666>=</span> sys_putstr(str);
</span></span><span style=display:flex><span>    ConsoleRelease();
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> output_num;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>console_putchar</span>(<span style=color:#902000>char</span> char_asi)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ConsoleAcquire();
</span></span><span style=display:flex><span>    sys_putchar(char_asi);
</span></span><span style=display:flex><span>    ConsoleRelease();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>console_putint</span>(<span style=color:#902000>int</span> num)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ConsoleAcquire();
</span></span><span style=display:flex><span>    <span style=color:#902000>int</span> output_num <span style=color:#666>=</span> sys_putint(num);
</span></span><span style=display:flex><span>    ConsoleRelease();
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> output_num;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>修改 main 为</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;print.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;init.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;debug.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;memory.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;thread.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;interrupt.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&#34;console.h&#34;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>KThreadTest</span>(<span style=color:#902000>void</span> <span style=color:#666>*</span>arg);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>_start</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    sys_putstr(<span style=color:#4070a0>&#34;this is kernel!</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>    InitAll();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ThreadStart(<span style=color:#4070a0>&#34;KThreadTestA&#34;</span>, <span style=color:#40a070>31</span>, KThreadTest, <span style=color:#4070a0>&#34;argA &#34;</span>);
</span></span><span style=display:flex><span>    ThreadStart(<span style=color:#4070a0>&#34;KThreadTestB&#34;</span>, <span style=color:#40a070>8</span>, KThreadTest, <span style=color:#4070a0>&#34;argB &#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    EnableInt();
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>while</span>(<span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        console_putstr(<span style=color:#4070a0>&#34;main &#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>KThreadTest</span>(<span style=color:#902000>void</span> <span style=color:#666>*</span>arg)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#902000>char</span> <span style=color:#666>*</span>para <span style=color:#666>=</span> (<span style=color:#902000>char</span> <span style=color:#666>*</span>) arg;
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>while</span>(<span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        console_putstr(arg);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>后就可以正常输出了。</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/os>OS</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/jchu95495236 rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a></div><div class=footer-info>2023 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>