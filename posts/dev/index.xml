<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>blog of chuj</title><link>https://chujdk.github.io/posts/dev.html</link><description>Recent content on blog of chuj</description><generator>Hugo</generator><language>zh-cn</language><managingEditor>chujj31@gmail.com (chuj)</managingEditor><webMaster>chujj31@gmail.com (chuj)</webMaster><copyright>© chuj</copyright><lastBuildDate>Thu, 26 May 2022 11:26:00 +0000</lastBuildDate><atom:link href="https://chujdk.github.io/posts/dev/index.xml" rel="self" type="application/rss+xml"/><item><title>compose-a-tetris 使用 compose API 在安卓上实现一个俄罗斯方块</title><link>https://chujdk.github.io/dev/1645.html</link><pubDate>Thu, 26 May 2022 11:26:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/dev/1645.html</guid><description>&lt;h2 id="写在前面">写在前面&lt;/h2>
&lt;p>为了应付安卓课的大作业，又写了一个俄罗斯方块。很幸运的是，确实学到了很多知识，&lt;del>虽然这些知识可能没什么用&lt;/del>，但是还是非常的有意思。上一次写俄罗斯方块是高三的时候是在 hp-39gii 图形机上拿着简陋的 hp-basic 写的，最后写出来的结果是这样的&lt;/p></description></item><item><title>COOL 语义分析器实现</title><link>https://chujdk.github.io/dev/1548.html</link><pubDate>Mon, 06 Sep 2021 01:20:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/dev/1548.html</guid><description>&lt;p>COOL 的语义分析主要对作用域和类型做了检测，这是两个必要的检测。未定义或重复定义的变量会对代码生成造成影响；类型不匹配也会造成各种未定义行为。&lt;/p>
&lt;h2 id="作用域">作用域&lt;/h2>
&lt;p>语义分析中需要对每个标识符（变量、函数）做检测，主要需要检查是否有未定义的标识符和重复定义的标识符。以 COOL 为例，通过维护一个符号表即可实现检测。这个检测过程可能需要对 AST 进行多次遍历，因为在 COOL 中，全局变量可以在声明前引用，所以至少需要先遍历一次并记录所有的全局变量，这样在第二次遍历时就可以正确判断变量是否有定义。&lt;/p></description></item><item><title>语法分析简单总结</title><link>https://chujdk.github.io/dev/1546.html</link><pubDate>Fri, 27 Aug 2021 22:47:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/dev/1546.html</guid><description>&lt;p>语法分析是词法分析的后一步，主要的目的就是通过词法分析器生成的 tokens 来生成抽象语法树（&lt;strong>A&lt;/strong>bstract &lt;strong>S&lt;/strong>yntax &lt;strong>T&lt;/strong>ree，AST）。主要通过上下文无关文法（&lt;strong>C&lt;/strong>ontext &lt;strong>F&lt;/strong>ree &lt;strong>G&lt;/strong>rammar，CFG）来描述语言的语法，使用相应的算法更具 CFG 来解析 tokens 形成 AST。语法分析应该是编译原理中非常偏向数学的一个方面，并且已经有了很成熟的解决方案，这句话的意思就是语法分析和我学习的方向和目的关系不大。不过这个东西感觉还挺有意思，同时虽然关系不大，但是了解一下还是有必要的，这里简单总结一下，对于算法方面不准备详细写，之后有时间再补上吧（之后学校的编译原理课应该会在 LL，LR 这种地方花很多时间，到时候再来弄也无妨，现在就不浪费生命了）。在慕中语法分析占据了比较大的篇幅，我不觉得自己都听懂了，也有很多不记得了，所以下面写的东西里面可能有很多谬误，仅供参考了哈哈哈。&lt;/p></description></item><item><title>年轻人的第一个词法分析器——COOL 的 lexer</title><link>https://chujdk.github.io/dev/1538.html</link><pubDate>Fri, 20 Aug 2021 18:53:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/dev/1538.html</guid><description>&lt;p>花了一天多的时间实现了这个词法分析器，从骨架上开始写确实可以少关心很多繁杂的小问题，体验好了许多。&lt;/p>
&lt;p>词法分析是编译的第一步，做的事情就是对源代码按照语法规则进行分词，并为其指定对应的类型，形成一系列 &amp;lt;类型，词素&amp;gt; 这样的二元组（token，词法单元）。&lt;/p></description></item></channel></rss>