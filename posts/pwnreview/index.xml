<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>blog of chuj</title><link>https://chujdk.github.io/posts/pwnreview.html</link><description>Recent content on blog of chuj</description><generator>Hugo</generator><language>zh-cn</language><managingEditor>chujj31@gmail.com (chuj)</managingEditor><webMaster>chujj31@gmail.com (chuj)</webMaster><copyright>© chuj</copyright><lastBuildDate>Tue, 21 Feb 2023 21:21:00 +0000</lastBuildDate><atom:link href="https://chujdk.github.io/posts/pwnreview/index.xml" rel="self" type="application/rss+xml"/><item><title>内核堆喷学习——CVE-2021-22555</title><link>https://chujdk.github.io/pwnreview/1659.html</link><pubDate>Tue, 21 Feb 2023 21:21:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1659.html</guid><description>&lt;h2 id="总结">&lt;span class="section-num">1&lt;/span> 总结&lt;/h2>
&lt;p>触发漏洞需要 &lt;code>CPA_NET_ADMIN&lt;/code> ，我们先 &lt;code>unshare&lt;/code> 出自己的名称空间，把权限给自己拉满&lt;/p>
&lt;p>漏洞出现在内核的 netfilter 子系统，是一个防火墙系统。用户层中，iptable 即使通过该子系统实现的。&lt;/p></description></item><item><title>StarCTF-OOB-WP</title><link>https://chujdk.github.io/pwnreview/1561.html</link><pubDate>Tue, 16 Nov 2021 15:50:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1561.html</guid><description>&lt;p>博客很久没有更新了，wp 更是很久没有发过了。主要是最近的确没有刷什么题，比赛虽然打的还算多，但是都没有做什么有收获的题，所以都没有发 wp，毕竟没啥意思。不过上个星期的深育杯和 l3ctf 倒是都碰到了新东西，深育杯有一个 Jerry script pwn 和 fastjson pwn。jerryscript 这个之前津门杯也碰到了，但是没有找到 wp 就一直没去复现，所以一直没搞懂，这次又碰到了，既然有官方 wp，就尝试复现一下。fastjson 那个，确实没听说过，有机会也复现一下。l3ctf 则非常时髦，一个似乎是 window 内核 pwn，确实是超出知识面了，还有一个是带 llvm address sanitizer 的 pwn，具体由于时间不够也没仔细分析。不知道官方会不会发布 wp，希望可以跟着复现一下。看来最近能弄的东西还挺多，突然又有了明确的目标了，挺好。下一步先了解一下 Jerry Script 的基本利用方式吧。&lt;/p></description></item><item><title>祥云杯线下 baby_stack 中的 PAC</title><link>https://chujdk.github.io/pwnreview/1559.html</link><pubDate>Wed, 27 Oct 2021 09:00:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1559.html</guid><description>&lt;p>之前的祥云杯线下 AWDp 中碰到了一道 ARMv8.3 的题，题目自身有一个简单的栈溢出漏洞，所以修起来十分容易，到最后被修到每轮只有 72 分，但是直到结束也没有一支队伍攻击成功，我猜测大家应该都是被 &lt;code>PACIA&lt;/code> 这个神奇的指令卡住了。暂时不考虑在一个断网的比赛环境里面考这样一个比较冷门的防护合不合适，但就题来说还是挺有意思的，我们队在比赛时虽然成功实现了 protect 函数的绕过，但是之后的 rop 就不会了，一方面是不会绕过第一次的 AUTIASP 检测（不过这个可以爆破，1/256 还是可以接受的），另一方面也的确是不会写 aarch64 的 rop。&lt;/p></description></item><item><title>glibc 2.34 malloc 的变化</title><link>https://chujdk.github.io/pwnreview/1512.html</link><pubDate>Tue, 03 Aug 2021 09:58:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1512.html</guid><description>&lt;p>昨天突然发现 glibc 2.34 发布了，虽然偶数版本似乎一般不会发布在稳定发行版中，但是还是挺好奇的，花了几分钟看了看，发现主要的变动是取消了几个 hook。&lt;/p>
&lt;p>首先看原先的 hook 定义处&lt;/p></description></item><item><title>seccomp 中的 bpf</title><link>https://chujdk.github.io/pwnreview/1495.html</link><pubDate>Sat, 24 Jul 2021 15:26:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1495.html</guid><description>&lt;p>学习这个问题的原因是想做 pwnable.tw 的 seccomp-tool 一题，此题的 elf 可以读取、模拟、加载用户输入的 bpf 代码，其中加载使用的是 prctl 系统调用，功能号为 PR_GET_SECCOMP。&lt;/p>
&lt;p>暂时还不知道怎么做，原来觉得应该是通过 bpf 来完成利用，&lt;del>总不会是 elf 某处写渣了的溢出&lt;/del>。由于我对 bpf 和 seccomp 不甚了解，所以先花了点时间了解了一下。了解了之后我感觉还真可能是 elf 本身的洞，在 emulate 功能中，也实现了一个类似于 Linux cbpf 解码器和模拟器的虚拟机，这里的代码还是有一点的，还没来的及看，说不定就是这里存在问题。&lt;/p></description></item><item><title>Kernel PWN UAF 的利用和调试</title><link>https://chujdk.github.io/pwnreview/1408.html</link><pubDate>Sat, 19 Jun 2021 15:45:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1408.html</guid><description>&lt;p>进行调试，必然是 gdb attach 到 qemu 上了，在启动指令中加入 &lt;code>-S -gdb tcp::1234&lt;/code> 即可启动一个调试口，在一个新的终端中打开 gdb，使用 targe remote :1234 即可 attach 上去。&lt;/p>
&lt;p>光 attach 上去肯定不够，还需要能在恰当的地方打断点，以 CISCN 2017 babydrive 这题为例（题目可以在 &lt;a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/kernel/CISCN2017-babydriver">ctf-challenge&lt;/a> 上面下到）。&lt;/p></description></item><item><title>Kernel PWN 环境搭建</title><link>https://chujdk.github.io/pwnreview/1318.html</link><pubDate>Thu, 17 Jun 2021 21:45:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1318.html</guid><description>&lt;p>一直对 kernel pwn 挺感兴趣的，再加上 libc 那里也没什么新东西可学了，简单题没什么做的意义，难题也不会做，所以准备开始学习 kernel pwn。不过可能最近也没办法太深入的学习，总之先把环境搭起来再说。&lt;/p></description></item><item><title>pwn 指定程序运行时使用的 libc</title><link>https://chujdk.github.io/pwnreview/941.html</link><pubDate>Fri, 04 Jun 2021 15:29:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/941.html</guid><description>&lt;p>文章是一月份的时候写的了，那个时候比较稚嫩，当时并没有很好的解决这个问题，也没有写清楚，现在重写一下。&lt;/p>
&lt;h3 id="使用-patchelf-替换">使用 patchelf 替换&lt;/h3>
&lt;p>假如我们有靶机的 libc，那么通过 patchelf 就可以将二进制使用的 libc 硬改写成靶机的 libc。&lt;/p></description></item><item><title>PWN ARM 环境配置</title><link>https://chujdk.github.io/pwnreview/1353.html</link><pubDate>Tue, 25 May 2021 22:58:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1353.html</guid><description>&lt;p>主要使用的调试方法为：qemu + gdb-multiarch，再交叉编译得到有符号的 libc。&lt;/p>
&lt;h3 id="qemu-安装">qemu 安装&lt;/h3>
&lt;p>直接通过 apt 安装并不是一个很好的选择，因为版本往往不是最新的，而且对调试的支持并不是很好（内存分析的比较一般），我选择通过手动编译安装来安装。&lt;/p></description></item><item><title>ptmalloc 的简单分析</title><link>https://chujdk.github.io/pwnreview/1300.html</link><pubDate>Sun, 23 May 2021 22:42:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1300.html</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>断断续续写了一个多月，终于写完了。写本文的主要目的是获得一个对堆的理性认知，从知其然到知其所以然。主要分析了 __libc_malloc，_int_malloc，__libc_free，_int_free，malloc_consolidate 五个比较长且核心的函数。基本覆盖了较小（即未大到需要进行 sys_malloc）的情况。当然对于较大的请求的处理也是有必要学习的，之后应该会再写一篇。总的来说本文写的比较简略，且略过了对 malloc_chunk 结构体、unlink 函数的介绍，您在看之前应该需要对 ptmalloc 的流程和基础结构已有一定了解。&lt;/p></description></item><item><title>pwn arm 环境——重型解决方案</title><link>https://chujdk.github.io/pwnreview/1303.html</link><pubDate>Sat, 01 May 2021 21:54:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1303.html</guid><description>&lt;p>&lt;strong>写在一个月后：这个用法，说实话没什么用，建议不要这么想，光是虚拟机起一下要近十分钟就已经让人无法接受了，而且有各种各样鸡皮的问题，建议通过手动编译 qemu 来获得更好的调试体验。可以参考&lt;a href="https://chujdk.github.io/pwnreview/1353.html">此文&lt;/a>&lt;/strong>&lt;/p></description></item><item><title>pwn 白名单绕过总结</title><link>https://chujdk.github.io/pwnreview/1294.html</link><pubDate>Thu, 22 Apr 2021 15:37:10 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1294.html</guid><description>&lt;p>有些时候 pwn 题目中为了增加难度（实际是为了恶心选手），会使用类似 &lt;a href="https://en.wikipedia.org/wiki/Seccomp">seccomp&lt;/a> 的函数来禁用一部分系统调用，往往会把 execve 这种系统调用禁用掉，基本上拿 shell 是不可能了，但是我们 pwn 题是面向 flag 的，所以还是可以通过 orw（ open-read-write ）的方法来读出 flag 的。在栈上的 orw 和 普通 rop 其实没有什么特别大的区别，这里主要谈一谈堆利用中的白名单绕过。&lt;/p></description></item><item><title>_IO_FILE 相关源码阅读（一）——vtable 及其指向的函数:从 __finish 说起</title><link>https://chujdk.github.io/pwnreview/1171.html</link><pubDate>Sat, 10 Apr 2021 19:02:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1171.html</guid><description>&lt;p>&lt;code>__finish&lt;/code> 虚函数主要处理的是对文件结构体的析构操作，同时会根据情况进行对文件进行 &lt;code>close&lt;/code> 操作。通过本文的分析，应该可以基本理解 &lt;code>_IO_new_file_finish&lt;/code>、&lt;code>_IO_new_file_write&lt;/code>、&lt;code>__GI__IO_file_seek&lt;/code>、&lt;code>__GI__IO_file_close&lt;/code> 等函数的实现。同时可以对面向语言中&lt;strong>虚函数&lt;/strong>的实现有初步的了解，更重要的，可以明白面向对象是一种思维，而不是语法，使用面向过程式语言仍然可以实现面向对象的开发。&lt;/p></description></item><item><title>unsorted bin 利用的简单总结</title><link>https://chujdk.github.io/pwnreview/1216.html</link><pubDate>Mon, 05 Apr 2021 22:10:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1216.html</guid><description>&lt;p>学习堆利用也有一段时间了，基本上就是在和 fastbin 和 unsorted bin 打交道，最近这段时间 tcache 的题也做了一些。套路居多，想想还是应该总结一下。不会写的太详细，也可能无法写全。&lt;/p></description></item><item><title>虎符网络安全赛道参赛有感</title><link>https://chujdk.github.io/pwnreview/1246.html</link><pubDate>Sat, 03 Apr 2021 20:06:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1246.html</guid><description>&lt;p>今天去协会打了 8 个小时的比赛，这也是我第一次跟队参加比赛，还是非常激动的&lt;/p>
&lt;p>当然其实与其说是打比赛，不如说是被比赛打。整场比赛就只看了一道 pwn 题，此题也非常没品地换了个架构，是在 aarch64 架构下的。我大概花了一个多小时的时间配置环境，最后还是在语神和薯片二位学长的帮助下才成功把程序跑起来的。&lt;/p></description></item><item><title>HCTF-game 赛后总结</title><link>https://chujdk.github.io/pwnreview/1116.html</link><pubDate>Sat, 27 Feb 2021 22:37:26 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1116.html</guid><description>&lt;p>这个寒假主要做的事就是打 HCTF-game，毕竟在竞赛方面，并没有准备后路，如果这场比赛出现失误，基本就与竞赛无缘了，这个后果大概是我无法担当的，所以比赛期间的压力还是比较大的。最后的结果也还算可以接受，至少 PWN 是 AK 掉了的，也有几个前三血。比较遗憾的大概就是别的方向解出的题目不多，特别是 web，几乎是爆零了。这也导致了我的总分不够靠前。说实话 PWN 的总分并不是很高，特别是最后一周只有两道题，和 web 还是差了不少，客观来说还是有一定的劣势的。就我之前学习的学习而言，这种多方向都有要求的比赛其实还是不太适合。&lt;/p></description></item><item><title>如何利用Unsorted Bin泄露Libc基地址</title><link>https://chujdk.github.io/pwnreview/1089.html</link><pubDate>Tue, 16 Feb 2021 17:20:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1089.html</guid><description>&lt;p>这其实是一个很简单很枯燥的问题，许多题中都会用到，但是我发现好像并没有文章以该方法为主角介绍该方法，也没有对其原理做出详细解释。估计是大佬们都觉得这个问题太简单了不愿意费时间来写，而回想过去，做题时总是会记得有这样一个利用方法，但是却找不到具体的利用原理。所以我就来细讲一下这个问题。&lt;/p></description></item><item><title>关于/proc目录</title><link>https://chujdk.github.io/pwnreview/1070.html</link><pubDate>Tue, 09 Feb 2021 15:29:41 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/1070.html</guid><description>&lt;p>&lt;code>/proc&lt;/code> 这个目录很牛，充满了信息&lt;/p>
&lt;p>&lt;code>/proc&lt;/code> 应该说是 &lt;code>Linux&lt;/code> 一切皆文件的设计哲学的体现，其中的文件和目录本身都是虚拟的一个文件系统，提供理一些内核信息。里面的有些文件很有些用处，这里简单列举一下&lt;/p></description></item><item><title>11月回顾</title><link>https://chujdk.github.io/pwnreview/11%E6%9C%88%E5%9B%9E%E9%A1%BE.html</link><pubDate>Sun, 29 Nov 2020 15:42:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/11%E6%9C%88%E5%9B%9E%E9%A1%BE.html</guid><description>&lt;!-- wp:paragraph -->
&lt;p>之所以会写这一篇回顾是因为堆漏洞我还是学不进去，就先做一些体力劳动。&lt;/p>
&lt;!-- /wp:paragraph -->
&lt;!-- wp:paragraph -->
&lt;p>总体来讲11月在pwn上的成果我还是比较满意的，基本上做到了一天一题，栈上漏洞利用已经学会的有&lt;/p></description></item><item><title>学习 pwn 的过程中的一点心得</title><link>https://chujdk.github.io/pwnreview/%E6%88%91%E7%9A%84pwn%E5%BF%83%E5%BE%97.html</link><pubDate>Sat, 21 Nov 2020 22:01:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/%E6%88%91%E7%9A%84pwn%E5%BF%83%E5%BE%97.html</guid><description>&lt;h3 id="值得注意的东西">值得注意的东西&lt;/h3>
&lt;h4 id="与exp的动调">与exp的动调&lt;/h4>
&lt;p>在 exp 中先指定 terminal，即添加一句&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>context&lt;span style="color:#666">.&lt;/span>terminal &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#4070a0">&amp;#39;tmux&amp;#39;&lt;/span>,&lt;span style="color:#4070a0">&amp;#39;splitw&amp;#39;&lt;/span>,&lt;span style="color:#4070a0">&amp;#39;-h&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在创建进程变量后，添加&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>gdb&lt;span style="color:#666">.&lt;/span>attach(proc&lt;span style="color:#666">.&lt;/span>pidof(sh)[&lt;span style="color:#40a070">0&lt;/span>]) &lt;span style="color:#60a0b0;font-style:italic">#这里的sh是进程变量&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样调试时先打开tmux，然后就可以动态调试了&lt;/p>
&lt;h4 id="加载指定的libc">加载指定的libc：&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>io &lt;span style="color:#666">=&lt;/span> process([&lt;span style="color:#4070a0">&amp;#39;./bin&amp;#39;&lt;/span>],env&lt;span style="color:#666">=&lt;/span> {&lt;span style="color:#4070a0">&amp;#34;LD_PRELOAD&amp;#34;&lt;/span>:&lt;span style="color:#4070a0">&amp;#34;./libc-2.23.so&amp;#34;&lt;/span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="可能很有用的东西">可能很有用的东西&lt;/h4>
&lt;p>&lt;a href="https://blog.csdn.net/mrhesongze/article/details/81980397">gdb 调试二进制和符号表分开的程序&lt;/a>&lt;/p></description></item><item><title>格式化字符串——以printf为代表</title><link>https://chujdk.github.io/pwnreview/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2-%E4%BB%A5printf%E4%B8%BA%E4%BB%A3%E8%A1%A8.html</link><pubDate>Sat, 14 Nov 2020 16:05:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2-%E4%BB%A5printf%E4%B8%BA%E4%BB%A3%E8%A1%A8.html</guid><description>&lt;p>span&lt;/p>
&lt;p>首先我想说，格式化字符串漏洞，会出现再形如&lt;code>printf(&amp;s);&lt;/code>这样的语句中，如果输出的参数等与输入有关，那么，就可能会自然的使用这样的方法，然鹅另一方面，漏洞本身有极高的危险性。&lt;/p></description></item><item><title>C语言函数调用栈</title><link>https://chujdk.github.io/pwnreview/c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88.html</link><pubDate>Thu, 29 Oct 2020 21:10:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/pwnreview/c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88.html</guid><description>&lt;p>span&lt;/p>
&lt;!-- wp:paragraph -->
&lt;p>&lt;sub>注：接下来如无特殊说明，汇编语法都是intel语法，同时讨论的是 32 位的调用流程。64 位由于使用寄存器传参比较简单类比即可，这里不再讨论
&lt;!-- wp:heading {"level":4} -->
&lt;h4>前置：寄存器&lt;/h4>
&lt;!-- /wp:heading -->
&lt;!-- wp:paragraph -->
&lt;p>与8086相比，x86与x86-64在寄存器使用上变得自由了许多，不再会有各种奇怪的限制，八个通用寄存器真正意义上的变成了通用的寄存器。&lt;/p></description></item></channel></rss>