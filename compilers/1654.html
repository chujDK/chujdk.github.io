<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Sea-of-nodes 论文阅读笔记 - blog of chuj</title><link rel=icon type=image/png href=https://chujdk.github.io/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A Simple Graph-Based Intermediate Representation 论文地址。这是 Sea-of-nodes IR 提出者 Cliff Click 的论文，之前“意识流学” V8 的时候，一直搞不明白 sea of nodes 的思想是什么，也尝试的找了很多资料想学习，但是感觉确实是没看明白。今天，我们通过看论文来学习。论文不难懂，很建议看看论文学习，这篇文章只是我自己的简单总结。"><meta property="og:image" content><meta property="og:url" content="https://chujdk.github.io/compilers/1654.html"><meta property="og:site_name" content="blog of chuj"><meta property="og:title" content="Sea-of-nodes 论文阅读笔记"><meta property="og:description" content="A Simple Graph-Based Intermediate Representation 论文地址。这是 Sea-of-nodes IR 提出者 Cliff Click 的论文，之前“意识流学” V8 的时候，一直搞不明白 sea of nodes 的思想是什么，也尝试的找了很多资料想学习，但是感觉确实是没看明白。今天，我们通过看论文来学习。论文不难懂，很建议看看论文学习，这篇文章只是我自己的简单总结。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-13T16:18:00+00:00"><meta property="article:modified_time" content="2022-09-13T16:18:00+00:00"><meta property="article:tag" content="Compilers"><meta property="article:tag" content="Sea-of-Nodes"><meta property="article:tag" content="IR"><meta name=twitter:card content="summary"><meta name=twitter:title content="Sea-of-nodes 论文阅读笔记"><meta name=twitter:description content="A Simple Graph-Based Intermediate Representation 论文地址。这是 Sea-of-nodes IR 提出者 Cliff Click 的论文，之前“意识流学” V8 的时候，一直搞不明白 sea of nodes 的思想是什么，也尝试的找了很多资料想学习，但是感觉确实是没看明白。今天，我们通过看论文来学习。论文不难懂，很建议看看论文学习，这篇文章只是我自己的简单总结。"><script src=https://chujdk.github.io/js/feather.min.js></script><link href=https://chujdk.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://chujdk.github.io/css/main.d24d3471089d3a4f095edc4a6857e25a9f1c6dd3e7d17026141ccad319438873.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://chujdk.github.io/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://chujdk.github.io/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about.html>About</a>
<a href=/tags>Tags</a></nav></header><main><article><div class=title><h1 class=title>Sea-of-nodes 论文阅读笔记</h1><div class=meta>Posted on Sep 13, 2022</div></div><section class=body><p><a href=https://www.oracle.com/technetwork/java/javase/tech/c2-ir95-150110.pdf>A Simple Graph-Based Intermediate Representation 论文地址</a>。这是 Sea-of-nodes IR 提出者 Cliff Click 的论文，之前“意识流学” V8 的时候，一直搞不明白 sea of nodes 的思想是什么，也尝试的找了很多资料想学习，但是感觉确实是没看明白。今天，我们通过看论文来学习。论文不难懂，很建议看看论文学习，这篇文章只是我自己的简单总结。</p><p><em>注：下面的图片都是截取自论文</em></p><p>目前我看到 C++ 实现一章之前，之后我有打算把 Sea-of-nodes 生成整合到我的 toy 编译器上，但是现在只是为了阐明 IR 的设计，我们先不考虑那么多具体的实现。</p><p>在我看来，Sea-of-nodes IR 是一个单向图。这样做的主要特点就是去除了传统 IR 的 CFG 和 Basic Blocks 两层，将 IR 成一层单独的图，可以使优化变得更容易：修改 IR 只要添加/减少节点，添加/减少边的连接就可以了。同时 IR 中的边是“unlabelled”的，也就是说每条边的本质只是一根指向后继的指针，这样也可以大幅增加分析时的性能（用作者原话就是 &ldquo;fit in L1 cache&rdquo;）。构建出的图，也可以（隐式地）一分为二成控制流图和数据流图。</p><p>同时我还认为，Sea-of-nodes 的目的是用一种更有利于优化的数据结构来表示程序的控制流和数据流信息。所以在之后可以看到，IR 的设计都是为了既满足简单，即所有的边都是 unlabelled 的，又能够拥有传统 IR 的表达能力的（甚至可能在某些方面有更强的表达能力）。</p><h3 id=图的设计>图的设计</h3><p>首先 Sea-of-nodes 是 SSA 形式的。IR 的图是一个有向图，图中的节点称为 Nodes，节点是有 label 的，对于原语类操作，比如加法原语，就会带一个 $Add$ label。我们用 node.opcode 来表示这个 $Add$ 操作。</p><p><img src=https://raw.githubusercontent.com/chujDK/ImageHost/main/PicGoIMage/20220913120647.png alt></p><p>每个节点的输入是有序的，输出是无序的，很好理解：比如对于减法操作，减数和被减数自然不能混淆方向，输入需要有序。而由于 IR 是 SSA 的，输出是一个可以被任何 nodes 使用的 value（也可能不是 value，而是 CONTROL 等别的信息），不需要有顺序。同时每个节点的输入数量都是固定的，而输出的数量则不限。而且在实现时，对于每个 node 其实只会维护输入，不会维护自身的输出。输入使用一个指针数组即可维护，比如对于上图中的 $b$，作为 $a$ 的第一个输入，就可以记作 $a[0]$。也就是 $a[0] \equiv b,\ a[1] \equiv c, \ a.opcode \equiv Add$ 。</p><h4 id=region-node>Region Node</h4><p>在 Sea-of-nodes 中，丢失了传统 IR 的 CFG + Basic Blocks 的双层表示。在原来的双层表示下，CFG 用来描述控制流，Basic Blocks 用来描述数据流。为了在 Sea-of-nodes 下也有同样的能力，在 IR 中添加了 Region Node 这样特殊的 nodes，</p><p><img src=https://raw.githubusercontent.com/chujDK/ImageHost/main/PicGoIMage/20220913121720.png alt></p><p>Region Node 会接受带有 CONTROL 信息的入边，并且将 CONTROL 信息传出。注意到图中 Add 节点接受了一个 Region Node 发出的 CONTROL 边，代表这个原语操作处于这个基本块中。不过实际上这条 CONTROL 边不是必须的（考虑到 IR 是 SSA 的，Add 接受的输入必然是正确的 b 和 c 的值，所以 Add 只要在 input 节点后执行就行了，并不是一定要在 Region node 这个基本块中执行），将这条边移除可以进行更多的全局优化，但是也会给之后序列化执行流造成难度。这类可以去除的边在论文配图中用虚线来表示。</p><h4 id=phi-node>Phi Node</h4><p>SSA 形式的 IR 一般都需要用 $\phi$-functions 来处理一些特殊情况，比如</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>int</span> a;
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (some<span style=color:#666>-</span>condition) {
</span></span><span style=display:flex><span>	a <span style=color:#666>=</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>} <span style=color:#007020;font-weight:700>else</span> {
</span></span><span style=display:flex><span>	a <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这种时候在 if 后就会出现两个不同的值汇聚到一个标识符的情况，SSA 不允许重复赋值，就需要引入 $\phi$-functions 来代表标识符会从多个可能的值中选出一个。在 Sea-of-nodes 中，Phi Node 就承担了 $\phi$-functions 的功能。不过我们可以看到，$\phi$-functions 不仅仅需要将数据作为输入，还需要对应的控制流来选择正确的数据，这样就需要将 Phi Node 的输入边设计成 CONTROL 和 value 信息的 pair 了，这样破坏掉 IR 的简单性。所以我们选择使用 Region Node 来辅助 Phi Node，如下图</p><p><img src=https://raw.githubusercontent.com/chujDK/ImageHost/main/PicGoIMage/20220913123116.png alt></p><p>Region Node 有和 Phi Node 对齐的输入，而 Region Node 会根据 B1 和 B2 的 CONTROL 输入而输出对应的 CONTROL 信息，这样 Phi Node 就可以选出正确的输入，从而输出正确的值。</p><p>和传统 SSA IR 一样，Phi Nodes 只存在于 IR 中，并不会生成对应的 machine code。</p><h4 id=if-node-and-projections>If Node and Projections</h4><p><img src=https://raw.githubusercontent.com/chujDK/ImageHost/main/PicGoIMage/20220913123603.png alt></p><p>在 Sea-of-nodes 中，if 条件分支被替换成了 If 节点，他会接受 CONTROL 输入和 predicate，也就是判断的谓词（语法我一点都不懂，所谓谓词其实就是一个判断，类似于 a == b 这样）。实际上这里应该是接受 predicate 求解后的值。如果值为 True 就输出 True，否则输出 False 给后继的 Region Node，让一个新的“基本块”得以执行。</p><p>不过很重要的是，我们看到上面的 If Node 的 output edge 是带 True 和 False 的信息的，也就是 labeled 的。If 只会输出 True 和 False 两种信息，但是还有很多操作会输出多种信息，比如子方法调用，会有更多的不同种类的输出，如果对这些 node 都加上 label 来辨明是什么类型的输出的话，就会对性能和简单性有很大的负面影响。所以我们会让每一条 output edge 都带有同样的信息，也就是带有同样的 tuple，包含了所有输出结果。然后通过一个 projection node 来选出我们想要的特定信息，也就是下图所表示的。</p><p><img src=https://raw.githubusercontent.com/chujDK/ImageHost/main/PicGoIMage/20220913123611.png alt></p><p>记 If 的输出为 <code>{true : 0, false : 1}</code> 这样的 tuple，Projection True node 只会从 If 的输出中裁出 true 的 0，Projection False node 只会裁出 false 的 1，然后传到 Region Node 中。</p><h4 id=memory-and-io>Memory and I/O</h4><p>对于 Memory 操作，其实只有两种，Store 和 Load，Store 操作向内存中<strong>写入</strong>，Load 操作从内存中<strong>读取</strong>。在 IR 中，内存相关的操作也就是由 Store Node 和 Load Node 两种节点完成的。</p><p>思考 Store 和 Load 的操作的顺序应当如何组织，在最开始，为了简单，我们把 Memory 当作一个特殊的 Value，和其他的寄存器这样的值一样（也就是把两个实际上写入区域不重叠的 Store 操作当作是重叠的）</p><ul><li>对于 Store-Load-Store 这样的操作，两个 Store 的顺序不能调换，不然就会影响 Load 出来的值的准确性</li><li>对于 Store-Load-Load 这样的操作，两个 Load 的顺序并不重要</li><li>对于 Load-Store-Load 这样的操作，两个 Load 的顺序不能替换</li></ul><p>所以最后的设计就是每个 Store Node 会产生一个 STORE 输出，每个 Load Node 都需要以一个 STORE 和一个地址作为输入。每个 Store Node 都需要以一个 STORE 和一个地址作为输入，同时以 STORE 作为输出。（这里的 STORE 可以理解为类似于 Region Node 的 CONTROL 的“信号”）</p><p>对于 I/O，如果是 memory-mapped I/O，那么就和 memory 的处理一样。否则就需要进行子方法调用。</p><p>上面说到的对 memory 抽象为一整块的 Value，过于粗粒度，更好的设计是将 Store 操作划为互不相关的 Store Node。</p><h3 id=execution-model>Execution Model</h3><p>执行时，总体就是根据 CONTROL 信息的传递，来执行对应的“基本块”，或者说被 Region Node 围起来的子图。</p><p>下面是一个循环的 IR 表示</p><p><img src=https://raw.githubusercontent.com/chujDK/ImageHost/main/PicGoIMage/20220913125328.png alt></p><h3 id=c-implementation>C++ Implementation</h3><p>这里我只简述一下，论文中写的非常详细了</p><ul><li>每种 Node 都是一个独立的类，超基类是一个统一的 Node class，通过虚函数来实现不同的 node.opcode</li><li>每种 Node 都可以继承自与自己相似的别的 Node 来实现代码复用，比如 AddNode -> IntAddNode 这样的继承关系</li><li>在前面所说到的边，都是 $Def \rightarrow Use$，但是每个 Node 都是输入有限（并且往往可以提前预知）而输出无限（可能会在优化时随时增减）。所以实际实现时使用的是 $Use \rightarrow Def$ 边。也就是只维护 input，不维护 output。</li></ul></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/compilers>compilers</a></li><li><a href=/tags/sea-of-nodes>sea-of-nodes</a></li><li><a href=/tags/ir>IR</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/chujdk rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=mailto:chujj31@gmail.com rel=me title=Mail><i data-feather=mail></i></a>
<a class=border></a><a class=soc href=https://chujdk.github.io/index.xml rel=me title=Rss><i data-feather=rss></i></a>
<a class=border></a></div><div class=footer-info>2025 © chuj | Based on <a href=https://github.com/athul/archie>Archie</a> | Built with <a href=https://gohugo.io>Hugo</a> | <a href=#>Goto Top</a></div></footer><script>feather.replace()</script></div></body></html>