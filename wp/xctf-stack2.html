<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>XCTF-stack2-WP - blog of chuj</title><link rel=icon type=image/png href=https://chujdk.github.io/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="
 这道题确实是给我整吐了。其实思路非常简单，就是通过数组越界来达到栈溢出，并且这样可以跨越canary，然后就可以控制程序的执行流程。


然后我们可以看到"><meta property="og:image" content><meta property="og:url" content="https://chujdk.github.io/wp/xctf-stack2.html"><meta property="og:site_name" content="blog of chuj"><meta property="og:title" content="XCTF-stack2-WP"><meta property="og:description" content="这道题确实是给我整吐了。其实思路非常简单，就是通过数组越界来达到栈溢出，并且这样可以跨越canary，然后就可以控制程序的执行流程。
然后我们可以看到"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-04T21:59:33+00:00"><meta property="article:modified_time" content="2020-11-04T21:59:33+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="XCTF-stack2-WP"><meta name=twitter:description content="这道题确实是给我整吐了。其实思路非常简单，就是通过数组越界来达到栈溢出，并且这样可以跨越canary，然后就可以控制程序的执行流程。
然后我们可以看到"><script src=https://chujdk.github.io/js/feather.min.js></script><link href=https://chujdk.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://chujdk.github.io/css/main.d24d3471089d3a4f095edc4a6857e25a9f1c6dd3e7d17026141ccad319438873.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://chujdk.github.io/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://chujdk.github.io/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>XCTF-stack2-WP</h1><div class=meta>Posted on Nov 4, 2020</div></div><section class=body><p>这道题确实是给我整吐了。其实思路非常简单，就是通过数组越界来达到栈溢出，并且这样可以跨越canary，然后就可以控制程序的执行流程。</p><p>然后我们可以看到</p><div class=wp-block-image><figure class="aligncenter size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104155053.png alt class=wp-image-402></figure></div><p>这里有一个叫hackme的函数，这么嚣张，点进去看一下</p><div class=wp-block-image><figure class="aligncenter size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104155613.png alt class=wp-image-403></figure></div><p>呦呵直接给bash，那我就hack你吧。</p><p>然后再看一下主函数</p><div class=wp-block-image><figure class="aligncenter size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104155718.png alt class=wp-image-404></figure></div><p>发现这里有个数组越界，可以进行溢出。</p><p>然后我们算一下偏移，这里的偏移不能直接用0x70+4来算，为什么不能呢，是因为这个程序的栈帧生成方式是非常规的，我们来看一下</p><div class=wp-block-image><figure class="aligncenter size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104191719.png alt class=wp-image-415><figcaption>这是本程序的入口</figcaption></figure></div><div class=wp-block-image><figure class="aligncenter size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104192021.png alt class=wp-image-416><figcaption>这是一般程序的入口</figcaption></figure></div><p>会发现esp和0FFFFFFF0h的与操作的位置是不一样的</p><figure class="wp-block-image size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104192310.png alt class=wp-image-417><figcaption>这是本程序的出口</figcaption></figure><div class=wp-block-image><figure class="aligncenter size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104192439.png alt class=wp-image-418><figcaption>这是一般程序的出口</figcaption></figure></div><p>所以我们可以发现他的栈帧生成是动过手脚的。</p><p>那么我们可以考虑在调试的时候算出偏移。首先我们看一下ida中的代码</p><div class=wp-block-image><figure class="aligncenter size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104165715.png alt class=wp-image-406></figure></div><p>发现他是先读入一个临时变量，再存到数组里面的。</p><div class=wp-block-image><figure class="aligncenter size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104165831.png alt class=wp-image-407></figure></div><p>对应的就是这两条语句。那么明显，v7就是cl（注意v13是char数组），那么eax就是数组v13的首地址了。</p><p>再到gdb里面下好断点（我下了两个，一个在<code>mov [eax],cl</code>上，另一个在<code>ret</code>上）然后在第一次输入数字后，可以看到</p><div class=wp-block-image><figure class="aligncenter size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104170341.png alt class=wp-image-409></figure></div><p>我们就得到了EAX的值，也就是数组的首地址。</p><p>类似的方法，我们可以获得retrun的地址</p><div class=wp-block-image><figure class="aligncenter size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104170456.png alt class=wp-image-410><figcaption><s>其实也不是很类似</s></figcaption></figure></div><p>然后相减就获得了正确的偏移0x84。</p><p>这个时候我很高兴的写好了exp，把返回地址变成了hackhere的地址，然后发现报错了，在主机上找不到bash，真是会玩。</p><p>那么我们只好自己调用system函数了，这里就出现了一个卡了我一个多小时的问题，</p><div class=wp-block-image><figure class="aligncenter size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104171146.png alt class=wp-image-412></figure></div><p>我一直尝试通过这里的地址调用system，结果程序总是没法进入那里。让我百思不得其解。（这大概只能体现我蠢，函数的真实地址应当是通过got表的到的。）于是我又补了一下got，plt表和延迟绑定机制的知识。在这里我只解释与题目有关的部分。</p><p>一方面，由于动态链接往往会装载大量的函数，处理这些函数的重定位并生成got表会在程序执行前花费大量的时间，所以ELF使用了延迟绑定机制。在函数被调用前都不进行绑定。那么如果先前没有执行过system的话，实际上system函数是可以说不存在的，那当然是无法调用的；另一方面，extern段，只是说明从外部会调用这些函数，并不是说这里就是函数的地址了。</p><p>所以我们只能通过调用代码段中的system来获得sh</p><figure class="wp-block-image size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104213840.png alt class=wp-image-422></figure><p>接下来就是找sh的位置了，在ida里面shift+F12，找不到，到ROPgadaget中找一下</p><figure class="wp-block-image size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104215640.png alt class=wp-image-424></figure><p>诶找不到</p><figure class="wp-block-image size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104215740.png alt class=wp-image-425></figure><p>那我们就退一步吧，之前我还确实不知道可以直接用sh调出sh的哈哈哈</p><p>最好的exp就是这样了</p><div class=wp-block-image><figure class="aligncenter size-large"><img src=https://chujdk.github.io/usr/uploads/2020/11/QQ截图20201104215910.png alt class=wp-image-426></figure></div></section><div class=post-tags></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/chujdk rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=mailto:chujj31@gmail.com rel=me title=Mail><i data-feather=mail></i></a>
<a class=border></a><a class=soc href=https://chujdk.github.io/index.xml rel=me title=Rss><i data-feather=rss></i></a>
<a class=border></a></div><div class=footer-info>2024 © chuj | Based on <a href=https://github.com/athul/archie>Archie</a> | Built with <a href=https://gohugo.io>Hugo</a> | <a href=#>Goto Top</a></div></footer><script>feather.replace()</script></div></body></html>