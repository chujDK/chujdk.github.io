<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>PWNABLE.TW-De-ASLR-WP - blog of chuj</title><link rel=icon type=image/png href=https://www.cjovi.icu/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="这个 ROP 非常的麻烦 分析 流程就两句话 看起来似乎非常的简单，就是一个 gets 造成的无限溢出。但是并没有任何输出函数，所以 leak 非常困难。 思路 没有任何的 libc 地址"><meta property="og:image" content><meta property="og:title" content="PWNABLE.TW-De-ASLR-WP"><meta property="og:description" content="这个 ROP 非常的麻烦 分析 流程就两句话 看起来似乎非常的简单，就是一个 gets 造成的无限溢出。但是并没有任何输出函数，所以 leak 非常困难。 思路 没有任何的 libc 地址"><meta property="og:type" content="article"><meta property="og:url" content="https://www.cjovi.icu/wp/1227.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-30T14:53:00+00:00"><meta property="article:modified_time" content="2021-03-30T14:53:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="PWNABLE.TW-De-ASLR-WP"><meta name=twitter:description content="这个 ROP 非常的麻烦 分析 流程就两句话 看起来似乎非常的简单，就是一个 gets 造成的无限溢出。但是并没有任何输出函数，所以 leak 非常困难。 思路 没有任何的 libc 地址"><script src=https://www.cjovi.icu/js/feather.min.js></script>
<link href=https://www.cjovi.icu/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.cjovi.icu/css/main.858703d01d3c45e6b3e5964f9788e10759b7deb2158ea92653787f83364a9899.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://www.cjovi.icu/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://www.cjovi.icu/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>PWNABLE.TW-De-ASLR-WP</h1><div class=meta>Posted on Mar 30, 2021</div></div><section class=body><p>这个 ROP 非常的麻烦</p><h3 id=分析>分析</h3><p>流程就两句话</p><div style=text-align:center><img src=https://www.cjovi.icu/usr/uploads/2021/03/3937036548.png></div><p>看起来似乎非常的简单，就是一个 gets 造成的无限溢出。但是并没有任何输出函数，所以 leak 非常困难。</p><h3 id=思路>思路</h3><p>没有任何的 libc 地址，想要 leak 只能用栈上的残留数据，程序没有开启 PIE，所以我们可以通过栈迁移将栈迁移至地址固定的段上，比如进程末尾的可读可写页。然后在此处执行一个 gets，就可以把一些 libc 的地址留在这里了。</p><p>调试一下就可以发现会残留一个与 gets 有固定偏移的地址，这个时候有一个自然的想法，由于 puts 和 gets 相距甚近，那我们可以直接把残留的地址部分覆写，就可以获得一个 puts 的地址，就可以 leak 了。但是 gets 会在末尾补 &lsquo;\x00&rsquo;，本来只需要爆破 4 位，现在就需要爆破 12 位了，这种解法的 exp 我写了，爆破了一个小时没跑出来，放弃了。</p><p>后来换用一个更好的爆破方法，通过 ROPgadget 可以查到这个神奇的 gadget</p><div style=text-align:center><img src=https://www.cjovi.icu/usr/uploads/2021/03/2034500113.png></div><p>也就是 <code>add ebx, esi ; ret</code>，我们把残留的地址 pop 到 rbx 里面（可以利用 csu），提前算好偏移，一加就可以获得一个 one_gadget 的地址，就可以 getshell 了，当然这里会碰到一个问题，就是这个 gadget 会自动将 ebx 的高 32 位清零，所以最后还是需要爆破 8 位。不过二百五十六分之一的概率也尚可接受了。</p><p>关于这一点，引用 intel 的手册中的说明</p><blockquote><p>Because the upper 32 bits of 64-bit general-purpose registers are undefined in 32-bit modes, the upper 32 bits of any general-purpose register are not preserved when switching from 64-bit mode to a 32-bit mode (to protected mode or compatibility mode). Software must not depend on these bits to maintain a value after a 64-bit to 32-bit mode switch.</p></blockquote><p>大概意思就是由于通用寄存器的高 32 位在 32 位中没有定义，所以对所有的通用寄存器进行 32 位模式操作时都会造成高 32 位的清零。（说是通用寄存器，实际上 rsp 也一样）</p><div style=text-align:center><img src=https://www.cjovi.icu/usr/uploads/2021/03/1406264670.png></div><p>为了将 rbx 放回到栈里，仍然可以用 csu 中的 gadget，同时下面的 jz 不需要特别担心，在进入前把 rbp 和 r12 置零就可以实现跳转。</p><h3 id=总结>总结</h3><p>最后的思路就是</p><ol><li>栈迁移到固定可读写页</li><li>在该页上执行 gets</li><li>通过 csu 把 gets 残留的地址 pop 出来</li><li>通过 <code>add ebx, esi ; ret</code> 的 gadget 把 ebx 改成 one_gadget 的低四字节</li><li>通过 csu 把 rbx push 到栈里</li><li>通过 gets 把 push 进去的 one_gadget 地址补全（补两个字节，由于最高位恒定为 0x7F，所以这里只需要爆破 8 位）</li><li>通过 csu call one_gadget 成功 getshell</li></ol><p>这样看起来也挺简单的，但是调试和各种地址的布置还是有些麻烦，题目也是值这 500 分的。</p><hr><p>exp 建议自己写一下，爆破应该多试试，我爆破了 1000 次左右才出来</p><h3 id=exp>exp</h3><p>这应该属于高分题了，完整 exp 是不能公开的，所以就不放了。当然如果你非常需要，也可以通过联系我来取得。</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/write-up>write-up</a></li></ul></nav></div><script src=https://giscus.app/client.js data-repo=chujDK/chujdk.github.io data-repo-id=R_kgDOI__mNg data-category=Announcements data-category-id=DIC_kwDOI__mNs4CYoyP data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/chujdk rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=mailto:chujj31@gmail.com rel=me title=Mail><i data-feather=mail></i></a>
<a class=border></a></div><div class=footer-info>&nbsp2020 ~ 2023  © chuj |  Based on <a href=https://github.com/athul/archie>Archie</a> | Built with <a href=https://gohugo.io>Hugo</a> | <a href=#>Goto Top</a></div></footer><script>feather.replace()</script></div></body></html>