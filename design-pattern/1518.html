<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>设计模式 - blog of chuj</title><link rel=icon type=image/png href=https://chujdk.github.io/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="个人对设计模式的一点理解，由于没有专研于开发，可能会有不恰当之处，欢迎批评
策略模式

策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。——《HEAD FIRST 设计模式》"><meta property="og:image" content><meta property="og:url" content="https://chujdk.github.io/design-pattern/1518.html"><meta property="og:site_name" content="blog of chuj"><meta property="og:title" content="设计模式"><meta property="og:description" content="个人对设计模式的一点理解，由于没有专研于开发，可能会有不恰当之处，欢迎批评
策略模式 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。——《HEAD FIRST 设计模式》"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-05T23:36:00+00:00"><meta property="article:modified_time" content="2021-08-05T23:36:00+00:00"><meta property="article:tag" content="Design-Pattern"><meta name=twitter:card content="summary"><meta name=twitter:title content="设计模式"><meta name=twitter:description content="个人对设计模式的一点理解，由于没有专研于开发，可能会有不恰当之处，欢迎批评
策略模式 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。——《HEAD FIRST 设计模式》"><script src=https://chujdk.github.io/js/feather.min.js></script><link href=https://chujdk.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://chujdk.github.io/css/main.d24d3471089d3a4f095edc4a6857e25a9f1c6dd3e7d17026141ccad319438873.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://chujdk.github.io/css/font.e98a2c89163f90d6fa6d8baf5a50a6561f8ff3d0be1551265f364d138d75df33.css></head><body><div class=content><header><div class=main><a href=https://chujdk.github.io/>blog of chuj</a></div><nav><a href=/>Home</a>
<a href=/posts.html>All posts</a>
<a href=/about.html>About</a>
<a href=/tags.html>Tags</a></nav></header><main><article><div class=title><h1 class=title>设计模式</h1><div class=meta>Posted on Aug 5, 2021</div></div><section class=body><p><em>个人对设计模式的一点理解，由于没有专研于开发，可能会有不恰当之处，欢迎批评</em></p><h2 id=策略模式>策略模式</h2><blockquote><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。——《HEAD FIRST 设计模式》</p></blockquote><p>就我个人对 OO 的理解来看，抽象是 OO 中最重要的思想之一，也就是从多个具体的对象中抽象出相似之处。有的时候相似之处可能不够相似，抽象就会变得困难，策略模式就是一种抽象具有相似“算法”的一族对象的一种模式。《HEAD FIRST 设计模式》中举的鸭子的例子挺有意思的，不够既然这里在定义里面说到了“算法”，我就用狭义的算法来举例。</p><p>假设我们要解决一个最速问题——比如从城市的一个点到另一个点怎么样才能最快到达。首先我们会把城市抽象成一张图，然后对它求最短路，这再明显不过。那么我们很容易得出这样一个继承关系</p><p><img src=https://chujdk.github.io/usr/uploads/2021/08/866422525.png alt=糟糕的设计></p><p>这个设计是非常糟糕的，因为我们在选择最短路算法时，必然要考虑到算法的效率和功能性问题，比如 Dijkstra 算法可能是平均表现最好的算法，但是它不能处理负权边和负环（虽然我想不出来哪个道路会是负权边，但是这里为了举例就不管了），SPFA 在某些特殊情况下可能会死掉，但是它可以处理负环，Floyd 可以处理多源最短路。那么这里 Dijkstra，SPFA，Floyd 就组成了一个最短路算法族，对于不同的情况我们选择不同的算法（也就是不同的策略）：</p><ul><li>没有负权边和负环：Dijkstra</li><li>有负权边：SPFA</li><li>要求求得多个点到点的最短路径：Floyd</li></ul><p>打一个比方，上面的 HangZhou 继承类，（假设）由于杭州市有负权边，所以必须用 SPFA，如果杭州没有了负权边，那么可能把它换成 Dijkstra 才是最好的选择，这样在维护的时候就不得不重写杭州类的 calcFastest 函数，假设我们有一百个城市要维护，今天北京获得了外星人的支持造出来一条通过时间为负数的道路，明天杭州的负权路被反科技恐怖分子炸了，维护者就不得不一直修改代码，这样维护起来肯定是非常痛苦的。使用策略模式就可以解决这个问题，使对象甚至可以在运行时改变其使用的算法。具体的做法，就是把使用算法计算“委托”给别的对象来做：</p><p><img src=https://chujdk.github.io/usr/uploads/2021/08/3291726639.png alt=使用策略模式的设计></p><p>使用这样的方式，我们就可以在运行时修改使用的算法，调用下面这个函数即可</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>changeCalcWay(Calcer<span style=color:#bbb> </span>newWay)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020;font-weight:700>this</span>.<span style=color:#4070a0>calcer</span><span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>newWay;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>事实上，我们可以在运行时让对象自己选择最合适的算法</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span><span style=color:#bbb> </span>(hasNegtiveEdge(hangZhou))<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>newWay<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>new</span><span style=color:#bbb> </span>Spfa();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>hangZhou.<span style=color:#4070a0>changeCalcWay</span>(newWay);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#007020;font-weight:700>else</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>if</span><span style=color:#bbb> </span>(hasLotsFastestProblems(hangZhou))<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>newWay<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>new</span><span style=color:#bbb> </span>Floyd();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>hangZhou.<span style=color:#4070a0>changeCalcWay</span>(newWay);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#007020;font-weight:700>else</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>newWay<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>new</span><span style=color:#bbb> </span>Dijkstra();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>hangZhou.<span style=color:#4070a0>changeCalcWay</span>(newWay);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>如果我们需要添加新的最短路计算方式，只需要再继承一个 Calcer 即可。如果我们对 Spfa 进行了改进，所有使用 Spfa 的对象都可以获得这个改进，并且对象自身甚至不需要知道这一点。</p><p>和《HEAD FIRST 设计模式》中的鸭子的飞行方法和叫法一样，这里的计算最短路就是解决问题的策略，我们有很多策略可选，策略模式就提供给了我们一个良好的切换策略的设计方法。</p><blockquote><p>这个设计模式体现了这些 OO 设计原则</p><ul><li>封装变化</li><li>多用组合，少用继承</li><li>针对接口编程，不针对实现编程</li></ul></blockquote><p>所谓的针对接口编程，其实就是 OO 的运行时多态的体现。</p><h2 id=观察者模式>观察者模式</h2><blockquote><p>观察者模式在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。</p></blockquote><p>观察者模式是松耦合的，主题（即被依赖的对象）和观察者互相不知道也不关心对方的具体实现，更具有弹性，更能应对变化。</p><p>实现观察者模式其实比较容易，所有的观察者只需要实现一个统一的接口让主题进行 update 操作，主题本身只要维护一个观察者列表并且提供注册为观察者和注销的方法即可。每次主题发生变化时只要遍历观察者列表并调用 update 操作就可以让所有的观察者获得更新。</p><p><img src=https://chujdk.github.io/usr/uploads/2021/08/4104271082.png alt=观察者模式></p><p>那么每次 CentralData 中的私有数据变化时，只要调用 notifyObserver 方法，就会依次调用每个观察者的 update 方法。</p><p>观察者模式其实比较容易理解，这种设计模式最重要的是实现了互相依赖的对象间的松耦合，同时建立了一套触发机制，使数据的更改可以根据需求传递给观察者。</p><p>考虑到观察者本身也可以成为主题，当出现循环观察的情况时，可能会造成严重的错误。</p><blockquote><p>观察者模式体现的 OO 原则：</p><p>为交互对象之间的松耦合设计而努力。</p></blockquote><h2 id=装饰者模式>装饰者模式</h2><blockquote><p>装饰者模式动态的将责任附加到对象上。想要拓展功能，装饰者提供有别于继承的另一种选择。</p></blockquote><p>OO 中如果需要扩展一个类的功能，继承是一有力机制，但是继承是编译期完成的，无法在运行时动态完成功能的拓展。装饰者模式提供了一种动态的拓展功能的设计方法。</p><p>java.io 包就是使用装饰者模式的典型，举例而言</p><p><img src=https://chujdk.github.io/usr/uploads/2021/08/4278033824.png alt=java.io></p><p>FilterInputStream 虚类是一个抽象装饰器，通过继承该虚类可以装饰它左边三个具体的继承自 InputStream 的类。</p><p>装饰者模式虽然说是有别于继承的，但是这里仍然继承了 InputStream 超类，这是因为每一个装饰器和被装饰对象都需要是同一个类型，这样才可以用统一的方法来访问装饰器，也可以保证装饰器本身可以再被装饰。也就是说这里的继承并非继承功能，而是继承结构。</p><p>当我们需要添加新的功能时，只需要建立新的装饰者并用装饰器装饰需要被继承的对象即可，而不需要修改原先的代码，做到了“对扩展开放，对修改关闭”。</p><p>比如如果我们需要添加一个将所有的输入都转为小写的功能，就只需要建立一个对应的装饰器</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#007020;font-weight:700>import</span><span style=color:#bbb> </span><span style=color:#0e84b5;font-weight:700>java.io.FilterInputStream</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#007020;font-weight:700>import</span><span style=color:#bbb> </span><span style=color:#0e84b5;font-weight:700>java.io.IOException</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#007020;font-weight:700>import</span><span style=color:#bbb> </span><span style=color:#0e84b5;font-weight:700>java.io.InputStream</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#007020;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>class</span> <span style=color:#0e84b5;font-weight:700>LowerCaseInputStream</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>extends</span><span style=color:#bbb> </span>FilterInputStream<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#06287e>LowerCaseInputStream</span>(InputStream<span style=color:#bbb> </span>in)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#007020;font-weight:700>super</span>(in);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#902000>int</span><span style=color:#bbb> </span><span style=color:#06287e>read</span>()<span style=color:#bbb> </span><span style=color:#007020;font-weight:700>throws</span><span style=color:#bbb> </span>IOException<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#902000>int</span><span style=color:#bbb> </span>c<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>super</span>.<span style=color:#4070a0>read</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#007020;font-weight:700>return</span><span style=color:#bbb> </span>(c<span style=color:#bbb> </span><span style=color:#666>==</span><span style=color:#bbb> </span><span style=color:#666>-</span>1<span style=color:#bbb> </span><span style=color:#666>?</span><span style=color:#bbb> </span>c<span style=color:#bbb> </span>:<span style=color:#bbb> </span>Character.<span style=color:#4070a0>toLowerCase</span>((<span style=color:#902000>char</span>)<span style=color:#bbb> </span>c));<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#902000>int</span><span style=color:#bbb> </span><span style=color:#06287e>read</span>(<span style=color:#902000>byte</span><span style=color:#666>[]</span><span style=color:#bbb> </span>b,<span style=color:#bbb> </span><span style=color:#902000>int</span><span style=color:#bbb> </span>offset,<span style=color:#bbb> </span><span style=color:#902000>int</span><span style=color:#bbb> </span>len)<span style=color:#bbb> </span><span style=color:#007020;font-weight:700>throws</span><span style=color:#bbb> </span>IOException<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#902000>int</span><span style=color:#bbb> </span>result<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>super</span>.<span style=color:#4070a0>read</span>(b,<span style=color:#bbb> </span>offset,<span style=color:#bbb> </span>len);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#007020;font-weight:700>for</span><span style=color:#bbb> </span>(<span style=color:#902000>int</span><span style=color:#bbb> </span>i<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>0;<span style=color:#bbb> </span>i<span style=color:#bbb> </span><span style=color:#666>&lt;</span><span style=color:#bbb> </span>result;<span style=color:#bbb> </span>i<span style=color:#666>++</span>)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>b<span style=color:#666>[</span>i<span style=color:#666>]</span><span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>(<span style=color:#902000>byte</span>)<span style=color:#bbb> </span>Character.<span style=color:#4070a0>toLowerCase</span>((<span style=color:#902000>char</span>)<span style=color:#bbb> </span>b<span style=color:#666>[</span>i<span style=color:#666>]</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#007020;font-weight:700>return</span><span style=color:#bbb> </span>result;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>然后用该装饰器装饰别的输入流即可</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>InputStream<span style=color:#bbb> </span>in<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:#007020;font-weight:700>new</span><span style=color:#bbb> </span>LowerCaseInputStream(<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                    </span><span style=color:#007020;font-weight:700>new</span><span style=color:#bbb> </span>BufferedInputStream(<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                        </span><span style=color:#007020;font-weight:700>new</span><span style=color:#bbb> </span>FileInputStream(<span style=color:#4070a0>&#34;test.txt&#34;</span>)));<span style=color:#bbb>
</span></span></span></code></pre></div><p>之后都会总结在时光机里面，具体的写出来似乎没什么必要，网络上已有大量的资料。我只在时光机里面简单地记录一下自己的心得。</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/design-pattern>design-pattern</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/chujDK rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/chujdk rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=mailto:chujj31@gmail.com rel=me title=Mail><i data-feather=mail></i></a>
<a class=border></a><a class=soc href=https://chujdk.github.io/index.xml rel=me title=Rss><i data-feather=rss></i></a>
<a class=border></a></div><div class=footer-info>2024 © chuj | Based on <a href=https://github.com/athul/archie>Archie</a> | Built with <a href=https://gohugo.io>Hugo</a> | <a href=#>Goto Top</a></div></footer><script>feather.replace()</script></div></body></html>