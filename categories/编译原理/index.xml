<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编译原理 on blog of chuj</title><link>https://chujdk.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.html</link><description>Recent content in 编译原理 on blog of chuj</description><generator>Hugo</generator><language>zh-cn</language><managingEditor>chujj31@gmail.com (chuj)</managingEditor><webMaster>chujj31@gmail.com (chuj)</webMaster><copyright>© chuj</copyright><lastBuildDate>Tue, 13 Sep 2022 16:18:00 +0000</lastBuildDate><atom:link href="https://chujdk.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Sea-of-nodes 论文阅读笔记</title><link>https://chujdk.github.io/compilers/1654.html</link><pubDate>Tue, 13 Sep 2022 16:18:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/compilers/1654.html</guid><description>&lt;p>&lt;a href="https://www.oracle.com/technetwork/java/javase/tech/c2-ir95-150110.pdf">A Simple Graph-Based Intermediate Representation 论文地址&lt;/a>。这是 Sea-of-nodes IR 提出者 Cliff Click 的论文，之前“意识流学” V8 的时候，一直搞不明白 sea of nodes 的思想是什么，也尝试的找了很多资料想学习，但是感觉确实是没看明白。今天，我们通过看论文来学习。论文不难懂，很建议看看论文学习，这篇文章只是我自己的简单总结。&lt;/p></description></item><item><title>COOL 语义分析器实现</title><link>https://chujdk.github.io/dev/1548.html</link><pubDate>Mon, 06 Sep 2021 01:20:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/dev/1548.html</guid><description>&lt;p>COOL 的语义分析主要对作用域和类型做了检测，这是两个必要的检测。未定义或重复定义的变量会对代码生成造成影响；类型不匹配也会造成各种未定义行为。&lt;/p>
&lt;h2 id="作用域">作用域&lt;/h2>
&lt;p>语义分析中需要对每个标识符（变量、函数）做检测，主要需要检查是否有未定义的标识符和重复定义的标识符。以 COOL 为例，通过维护一个符号表即可实现检测。这个检测过程可能需要对 AST 进行多次遍历，因为在 COOL 中，全局变量可以在声明前引用，所以至少需要先遍历一次并记录所有的全局变量，这样在第二次遍历时就可以正确判断变量是否有定义。&lt;/p></description></item><item><title>语法分析简单总结</title><link>https://chujdk.github.io/dev/1546.html</link><pubDate>Fri, 27 Aug 2021 22:47:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/dev/1546.html</guid><description>&lt;p>语法分析是词法分析的后一步，主要的目的就是通过词法分析器生成的 tokens 来生成抽象语法树（&lt;strong>A&lt;/strong>bstract &lt;strong>S&lt;/strong>yntax &lt;strong>T&lt;/strong>ree，AST）。主要通过上下文无关文法（&lt;strong>C&lt;/strong>ontext &lt;strong>F&lt;/strong>ree &lt;strong>G&lt;/strong>rammar，CFG）来描述语言的语法，使用相应的算法更具 CFG 来解析 tokens 形成 AST。语法分析应该是编译原理中非常偏向数学的一个方面，并且已经有了很成熟的解决方案，这句话的意思就是语法分析和我学习的方向和目的关系不大。不过这个东西感觉还挺有意思，同时虽然关系不大，但是了解一下还是有必要的，这里简单总结一下，对于算法方面不准备详细写，之后有时间再补上吧（之后学校的编译原理课应该会在 LL，LR 这种地方花很多时间，到时候再来弄也无妨，现在就不浪费生命了）。在慕中语法分析占据了比较大的篇幅，我不觉得自己都听懂了，也有很多不记得了，所以下面写的东西里面可能有很多谬误，仅供参考了哈哈哈。&lt;/p></description></item><item><title>年轻人的第一个词法分析器——COOL 的 lexer</title><link>https://chujdk.github.io/dev/1538.html</link><pubDate>Fri, 20 Aug 2021 18:53:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://chujdk.github.io/dev/1538.html</guid><description>&lt;p>花了一天多的时间实现了这个词法分析器，从骨架上开始写确实可以少关心很多繁杂的小问题，体验好了许多。&lt;/p>
&lt;p>词法分析是编译的第一步，做的事情就是对源代码按照语法规则进行分词，并为其指定对应的类型，形成一系列 &amp;lt;类型，词素&amp;gt; 这样的二元组（token，词法单元）。&lt;/p></description></item></channel></rss>