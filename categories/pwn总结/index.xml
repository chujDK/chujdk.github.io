<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>pwn总结 on blog of chuj</title><link>https://cjovi.icu/categories/pwn%E6%80%BB%E7%BB%93.html</link><description>Recent content in pwn总结 on blog of chuj</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>chujj31@gmail.com (chuj)</managingEditor><webMaster>chujj31@gmail.com (chuj)</webMaster><lastBuildDate>Tue, 21 Feb 2023 21:21:00 +0000</lastBuildDate><atom:link href="https://cjovi.icu/categories/pwn%E6%80%BB%E7%BB%93/index.xml" rel="self" type="application/rss+xml"/><item><title>内核堆喷学习——CVE-2021-22555</title><link>https://cjovi.icu/pwnreview/1659.html</link><pubDate>Tue, 21 Feb 2023 21:21:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1659.html</guid><description>1 总结 触发漏洞需要 CPA_NET_ADMIN ，我们先 unshare 出自己的名称空间，把权限给自己拉满 漏洞出现在内核的 netfilter 子系统，是一个防火墙系统。用户层中，iptable 即使通过</description></item><item><title>StarCTF-OOB-WP</title><link>https://cjovi.icu/pwnreview/1561.html</link><pubDate>Tue, 16 Nov 2021 15:50:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1561.html</guid><description>博客很久没有更新了，wp 更是很久没有发过了。主要是最近的确没有刷什么题，比赛虽然打的还算多，但是都没有做什么有收获的题，所以都没有发 wp，毕</description></item><item><title>祥云杯线下 baby_stack 中的 PAC</title><link>https://cjovi.icu/pwnreview/1559.html</link><pubDate>Wed, 27 Oct 2021 09:00:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1559.html</guid><description>之前的祥云杯线下 AWDp 中碰到了一道 ARMv8.3 的题，题目自身有一个简单的栈溢出漏洞，所以修起来十分容易，到最后被修到每轮只有 72 分，但是直到结束也没有一支队</description></item><item><title>glibc 2.34 malloc 的变化</title><link>https://cjovi.icu/pwnreview/1512.html</link><pubDate>Tue, 03 Aug 2021 09:58:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1512.html</guid><description>昨天突然发现 glibc 2.34 发布了，虽然偶数版本似乎一般不会发布在稳定发行版中，但是还是挺好奇的，花了几分钟看了看，发现主要的变动是取消了几个 hook。</description></item><item><title>seccomp 中的 bpf</title><link>https://cjovi.icu/pwnreview/1495.html</link><pubDate>Sat, 24 Jul 2021 15:26:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1495.html</guid><description>学习这个问题的原因是想做 pwnable.tw 的 seccomp-tool 一题，此题的 elf 可以读取、模拟、加载用户输入的 bpf 代码，其中加载使用的是 prctl 系统调用，功能号为 PR_GET_SECC</description></item><item><title>ptmalloc 之 sysmalloc 分析</title><link>https://cjovi.icu/pwnreview/1418.html</link><pubDate>Tue, 22 Jun 2021 18:07:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1418.html</guid><description>最近这段时间是考试周，所以 kernel pwn 的学习我暂时放了下来，先做一点体力活，一直不了解 ptmalloc 怎么通过系统调用增加内存池大小的，这里分析一下。、 我们知道，</description></item><item><title>Kernel PWN UAF 的利用和调试</title><link>https://cjovi.icu/pwnreview/1408.html</link><pubDate>Sat, 19 Jun 2021 15:45:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1408.html</guid><description>进行调试，必然是 gdb attach 到 qemu 上了，在启动指令中加入 -S -gdb tcp::1234 即可启动一个调试口，在一个新的终端中打开 gdb，使用 targe remote :1234 即可 attach 上去。 光 attach 上去肯定不够，</description></item><item><title>Kernel PWN 环境搭建</title><link>https://cjovi.icu/pwnreview/1318.html</link><pubDate>Thu, 17 Jun 2021 21:45:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1318.html</guid><description>一直对 kernel pwn 挺感兴趣的，再加上 libc 那里也没什么新东西可学了，简单题没什么做的意义，难题也不会做，所以准备开始学习 kernel pwn。不过可能最近也没办法太</description></item><item><title>pwn 指定程序运行时使用的 libc</title><link>https://cjovi.icu/pwnreview/941.html</link><pubDate>Fri, 04 Jun 2021 15:29:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/941.html</guid><description>文章是一月份的时候写的了，那个时候比较稚嫩，当时并没有很好的解决这个问题，也没有写清楚，现在重写一下。 使用 patchelf 替换 假如我们有靶机的 libc，那</description></item><item><title>PWN ARM 环境配置</title><link>https://cjovi.icu/pwnreview/1353.html</link><pubDate>Tue, 25 May 2021 22:58:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1353.html</guid><description>主要使用的调试方法为：qemu + gdb-multiarch，再交叉编译得到有符号的 libc。 qemu 安装 直接通过 apt 安装并不是一个很好的选择，因为版</description></item><item><title>ptmalloc 的简单分析</title><link>https://cjovi.icu/pwnreview/1300.html</link><pubDate>Sun, 23 May 2021 22:42:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1300.html</guid><description>前言 断断续续写了一个多月，终于写完了。写本文的主要目的是获得一个对堆的理性认知，从知其然到知其所以然。主要分析了 __libc_malloc，</description></item><item><title>pwn arm 环境——重型解决方案</title><link>https://cjovi.icu/pwnreview/1303.html</link><pubDate>Sat, 01 May 2021 21:54:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1303.html</guid><description>写在一个月后：这个用法，说实话没什么用，建议不要这么想，光是虚拟机起一下要近十分钟就已经让人无法接受了，而且有各种各样鸡皮的问题，建议通过手</description></item><item><title>pwn 白名单绕过总结</title><link>https://cjovi.icu/pwnreview/1294.html</link><pubDate>Thu, 22 Apr 2021 15:37:10 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1294.html</guid><description>有些时候 pwn 题目中为了增加难度（实际是为了恶心选手），会使用类似 seccomp 的函数来禁用一部分系统调用，往往会把 execve 这种系统调用禁用掉，基本上拿 shell 是不可能</description></item><item><title>_IO_FILE 相关源码阅读（二）——vtable 及其指向的函数:__overflow</title><link>https://cjovi.icu/pwnreview/1288.html</link><pubDate>Fri, 16 Apr 2021 21:22:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1288.html</guid><description>int _IO_new_file_overflow (FILE *f, int ch) { if (f-&amp;gt;_flags &amp;amp; _IO_NO_WRITES) /* SET ERROR */ { f-&amp;gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; } /* If currently reading or no buffer allocated. */ if ((f-&amp;gt;_flags &amp;amp; _IO_CURRENTLY_PUTTING) == 0 || f-&amp;gt;_IO_write_base == NULL) { /* Allocate a buffer if needed. */ if (f-&amp;gt;_IO_write_base == NULL) { _IO_doallocbuf (f); _IO_setg (f, f-&amp;gt;_IO_buf_base, f-&amp;gt;_IO_buf_base, f-&amp;gt;_IO_buf_base); } /* Otherwise must be currently reading.</description></item><item><title>leak 小 trick—— 对 _IO_2_1_stdout_ 的攻击</title><link>https://cjovi.icu/pwnreview/1259.html</link><pubDate>Sat, 10 Apr 2021 20:01:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1259.html</guid><description>有一些堆利用菜单题，不提供输出的功能，这个时候即使弄出了一个带有 main_arena 的 chunk，想要直接 leak 也是比较困难的，有些情况下可以通过攻击 _IO_2_1_stdout_ 实现有效的</description></item><item><title>_IO_FILE 相关源码阅读（一）——vtable 及其指向的函数:从 __finish 说起</title><link>https://cjovi.icu/pwnreview/1171.html</link><pubDate>Sat, 10 Apr 2021 19:02:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1171.html</guid><description>__finish 虚函数主要处理的是对文件结构体的析构操作，同时会根据情况进行对文件进行 close 操作。通过本文的分析，应该可以基本理解 _IO_new_file_f</description></item><item><title>unsorted bin 利用的简单总结</title><link>https://cjovi.icu/pwnreview/1216.html</link><pubDate>Mon, 05 Apr 2021 22:10:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1216.html</guid><description>学习堆利用也有一段时间了，基本上就是在和 fastbin 和 unsorted bin 打交道，最近这段时间 tcache 的题也做了一些。套路居多，想想还是应该总结一下。不会写的太详细，也可能</description></item><item><title>虎符网络安全赛道参赛有感</title><link>https://cjovi.icu/pwnreview/1246.html</link><pubDate>Sat, 03 Apr 2021 20:06:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1246.html</guid><description>今天去协会打了 8 个小时的比赛，这也是我第一次跟队参加比赛，还是非常激动的 当然其实与其说是打比赛，不如说是被比赛打。整场比赛就只看了一道 pwn 题，</description></item><item><title>HCTF-game 赛后总结</title><link>https://cjovi.icu/pwnreview/1116.html</link><pubDate>Sat, 27 Feb 2021 22:37:26 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1116.html</guid><description>这个寒假主要做的事就是打 HCTF-game，毕竟在竞赛方面，并没有准备后路，如果这场比赛出现失误，基本就与竞赛无缘了，这个后果大概是我无法担</description></item><item><title>如何利用Unsorted Bin泄露Libc基地址</title><link>https://cjovi.icu/pwnreview/1089.html</link><pubDate>Tue, 16 Feb 2021 17:20:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1089.html</guid><description>这其实是一个很简单很枯燥的问题，许多题中都会用到，但是我发现好像并没有文章以该方法为主角介绍该方法，也没有对其原理做出详细解释。估计是大佬们</description></item><item><title>关于/proc目录</title><link>https://cjovi.icu/pwnreview/1070.html</link><pubDate>Tue, 09 Feb 2021 15:29:41 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1070.html</guid><description>/proc 这个目录很牛，充满了信息 /proc 应该说是 Linux 一切皆文件的设计哲学的体现，其中的文件和目录本身都是虚拟的一个文件系统，提供理一些内核信息。里面的有些</description></item><item><title>ptmalloc的深入分析</title><link>https://cjovi.icu/pwnreview/1013.html</link><pubDate>Fri, 22 Jan 2021 23:43:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/1013.html</guid><description>好吧，这篇文章应该是不会发布的。 看这个东西主要的目的是为了获得一个对堆的理性认知，从知其然到知其所以然。当然由于本人才学疏浅，肯定会有许多纰</description></item><item><title>从源码看glibc中scanf的实现</title><link>https://cjovi.icu/pwnreview/963.html</link><pubDate>Wed, 06 Jan 2021 15:45:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/963.html</guid><description>关于 这是可能会成为一个新的专栏，主要想学习一下glibc对IO这一方面的实现，顺便记录一下。有这个打算的主要原因是最近做题做的心态有些小崩，</description></item><item><title>11月回顾</title><link>https://cjovi.icu/pwnreview/11%E6%9C%88%E5%9B%9E%E9%A1%BE.html</link><pubDate>Sun, 29 Nov 2020 15:42:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/11%E6%9C%88%E5%9B%9E%E9%A1%BE.html</guid><description>之所以会写这一篇回顾是因为堆漏洞我还是学不进去，就先做一些体力劳动。 总体来讲11月在pwn上的成果我还是比较满意的，基本上做到了一天一题，栈</description></item><item><title>学习 pwn 的过程中的一点心得</title><link>https://cjovi.icu/pwnreview/%E6%88%91%E7%9A%84pwn%E5%BF%83%E5%BE%97.html</link><pubDate>Sat, 21 Nov 2020 22:01:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/%E6%88%91%E7%9A%84pwn%E5%BF%83%E5%BE%97.html</guid><description>值得注意的东西 与exp的动调 在 exp 中先指定 terminal，即添加一句 context.terminal = [&amp;#39;tmux&amp;#39;,&amp;#39;splitw&amp;#39;,&amp;#39;-h&amp;#39;] 然后在创建进程变量后，添加 gdb.attach(proc.pidof(sh)[0]) #这里的sh是进程变量 这样调试时先打开</description></item><item><title>格式化字符串——以printf为代表</title><link>https://cjovi.icu/pwnreview/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2-%E4%BB%A5printf%E4%B8%BA%E4%BB%A3%E8%A1%A8.html</link><pubDate>Sat, 14 Nov 2020 16:05:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2-%E4%BB%A5printf%E4%B8%BA%E4%BB%A3%E8%A1%A8.html</guid><description>span 首先我想说，格式化字符串漏洞，会出现再形如printf(&amp;s);这样的语句中，如果输出的参数等与输入有关，那么，就可能会自然的使用这样的方</description></item><item><title>C语言函数调用栈</title><link>https://cjovi.icu/pwnreview/c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88.html</link><pubDate>Thu, 29 Oct 2020 21:10:00 +0000</pubDate><author>chujj31@gmail.com (chuj)</author><guid>https://cjovi.icu/pwnreview/c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88.html</guid><description>span 注：接下来如无特殊说明，汇编语法都是intel语法，同时讨论的是 32 位的调用流程。64 位由于使用寄存器传参比较简单类比即可，这里不再讨论 前置</description></item></channel></rss>